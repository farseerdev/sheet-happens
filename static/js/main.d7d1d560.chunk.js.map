{"version":3,"sources":["assets/logo.svg","assets/git.svg","components/Menu.js","../../src/constants.ts","../../src/util.ts","../../src/coordinate.ts","../../src/group.ts","../../src/props.ts","../../src/mouse.ts","../../src/keyboard.ts","../../src/scroll.ts","../../node_modules/babel-plugin-transform-async-to-promises/helpers.js","components/SheetBox.js","../../src/clipboard.ts","../../src/layout.ts","../../src/style.ts","../../src/render.ts","../../src/sheet.tsx","../../src/autosize.ts","components/Header.js","components/TitleSeparator.js","components/Wrap.js","components/Code.js","components/Footer.js","App.js","index.js"],"names":["module","exports","Menu","scrollTo","elId","element","document","getElementById","headerOffset","offsetPosition","window","pageYOffset","getBoundingClientRect","top","behavior","className","src","Logo","alt","onClick","INITIAL_MAX_SCROLL","ORIGIN","ONE_ONE","NEG_NEG","NO_CELL","NO_SELECTION","NO_SELECTIONS","NO_CLICKABLES","NO_STYLE","COLORS","SIZES","DEFAULT_CELL_STYLE","textAlign","fontSize","marginRight","marginLeft","color","fontFamily","weight","fillColor","backgroundColor","DEFAULT_COLUMN_HEADER_STYLE","HEADER_ACTIVE_STYLE","HEADER_SELECTED_STYLE","HEADER_GROUP_SELECTED_STYLE","ARROW_KEYS","ArrowRight","ArrowLeft","ArrowUp","ArrowDown","seq","n","s","d","Array","length","isInRange","x","min","isInRangeLeft","isInRangeCenter","addXY","a","b","subXY","maxXY","Math","minXY","getDirectionStep","direction","isSameXY","forRange","i","callback","forSelectionColumns","selection","normalizeSelection","left","right","forSelectionRows","bottom","forToMap","out","forLoop","map","mapSelectionColumns","mapSelectionRows","isMaybeRowSelection","isRowSelection","isColumnSelection","isEmptySelection","isPointInsideSelection","point","y","validateSelection","anchor","head","scanGroup","limit","index","key","keys","matchKeys","expandSelectionToRowOrColumnGroups","first","second","start","end","startIndex","groupKeys","endIndex","expanded","normalized","to","ax","ay","swapX","swapY","orientSelection","isBoundaryInsideGroup","before","after","createRowOrColumnProp","rowOrColIndex","rowColProp","createCellProp","cellProp","findApproxMaxEditDataIndex","editData","howManyEmpty","growthIncrement","growthIncrementFactor","allEmpty","yy","data","xx","parseKnobOperation","knobArea","kx1","ky1","kx2","ky2","sx1","sy1","sx2","sy2","fx1","fy1","fx2","fy2","changes","srcY","value","sourceData","cellReadOnly","source","srcX","useKeyboard","useLayoutEffect","overlay","overlayRef","current","editMode","activeTagName","preventScroll","onInputKeyDown","e","arrowKeyCommitMode","step","editCell","onCommit","onSelectionChange","onCancel","onGridFocus","onFocusChange","onGridBlur","onGridKeyDown","String","cell","cellX","cellY","onEdit","rawSelection","shift","displayData","firstFilled","maxX","maxY","findInDisplayData","x1","y1","x2","y2","onChange","onClipboardCopy","getViewExtent","cellToAbsolute","cellLayout","absoluteToColumn","columnToAbsolute","absoluteToRow","rowToAbsolute","getIndentX","getIndentY","offset","w","view","h","freeze","frozenX","frozenY","scrollW","scrollH","leftEdge","topEdge","edge","viewport","Symbol","iterator","asyncIterator","_catch","body","recover","result","then","EMPTY_TABLE","rows","useClipboardAPI","useState","peek","setPeek","softRefresh","navigator","name","status","hardRefresh","item","items","parseClipboardTable","delayedRefresh","setTimeout","canPaste","useCallback","copyTable","pasteTable","pasteClipboardTable","useClipboardTable","pasteIntoSelection","table","payload","minX","minY","width","height","newSelection","onPaste","shouldPaste","row","copySelection","cut","formatSelectionAsRows","onCopy","change","pasteSelection","onClipboardPaste","clipboardData","clipboardApi","useMemo","canPasteSelection","copyClipboardTable","text","formatRowsAsTSV","html","formatRowsAsHTML","ClipboardItem","Blob","type","event","Event","has","get","blob","pastedHtml","parsePastedHtml","parsePastedText","tds","formatTextAsHTML","JSON","isMaybeColumnSelection","findTag","child","maybeTag","div","sheetNode","json","tableNode","tableChild","tr","td","str","p","line","makeLayoutCache","sizer","offsets","makeIntMap","sizes","version","getSize","size","getOffset","j","getStart","getEnd","getVersion","lookupIndex","last","mid","setSizer","clearAfter","initialSize","allocate","newUsed","Uint8Array","newValues","Uint32Array","copy","used","values","from","truncate","l","set","grow","ensure","tail","applyAlignment","alignment","style","cellSize","imageWidth","renderCell","clickables","cellContent","context","yCoord","cellHeight","xCoord","cellWidth","obj","finalX","measure","rect","resolveSelection","cellToPixel","rowSelectionActive","columnSelectionActive","max","resolveFrozenSelection","freezeX","freezeY","indentX","indent","indentY","offsetX","offsetY","hideKnob","lastInvisibleX","lastInvisibleY","resizeCanvas","canvas","devicePixelRatio","ratio","newCanvasWidth","newCanvasHeight","excelHeaderString","num","t","halfShadowGradient","gradient","hex","adjust","f","rgb","opacity","forwardRef","canvasRef","useRef","maxScroll","setMaxScroll","dataOffset","setDataOffset","selectionProp","props","setRawSelection","setKnobArea","dragOffset","setDragOffset","dragIndices","setDragIndices","dropTarget","setDropTarget","setEditCell","focused","setFocused","lastSelectionProp","setLastSelectionProp","editValue","setEditValue","setArrowKeyCommitMode","useResizeObserver","ref","canvasWidth","canvasHeight","columnHeaders","columnHeaderStyle","canSizeColumn","canSizeRow","canOrderColumn","canOrderRow","rowGroupKeys","columnGroupKeys","editKeys","cellStyle","sheetStyle","freezeColumns","freezeRows","hideColumnHeaders","hideRowHeaders","hideGridlines","hideScrollBars","columnHeaderHeight","rowHeaderWidth","shadowBlur","shadowOpacity","shadowColor","resolveSheetStyle","secondarySelections","selectedColumnGroups","Set","selectedRowGroups","maxScrollX","maxScrollY","editCellX","editCellY","shouldCacheLayout","layoutVersion","columnLayout","rowLayout","getBaseOriginFor","columnToPixel","column","base","relative","columns","rowToPixel","anchorX","anchorY","pixelToIndex","pixel","layout","pixelToColumn","pixelX","pixelToRow","pixelY","absoluteToIndex","getVisibleIndices","indices","frozen","notFrozen","pixelToCell","absoluteToCell","getVisibleCells","viewX","viewY","makeCellLayout","visibleCells","scrollToSelection","toHead","newX","newY","newOffset","scroll","nudgeX","nudgeY","scrollX","scrollY","scrollToCell","changeSelection","a1","a2","b1","b2","isSameSelection","commitEditingCell","startEditingCell","editDataValue","val","setLastEditKey","maxColumns","Infinity","maxRows","maxCells","rightEdge","bottomEdge","remainder","clipDataOffset","hitmapRef","isFocused","onScroll","xy","onOffsetChange","growX","growY","onMaxScrollChange","useScroll","getAutoSizeWidth","getWidth","inlineMargin","maxWidth","extraWidth","headerStyle","headerContent","useAutoSizeColumn","hitTarget","setHitTarget","columnResize","setColumnResize","rowResize","setRowResize","columnDrag","setColumnDrag","rowDrag","setRowDrag","draggingKnob","setDraggingKnob","draggingSelection","setDraggingSelection","draggingRowSelection","setDraggingRowSelection","draggingColumnSelection","setDraggingColumnSelection","knobPosition","isCellSelection","refState","getMousePosition","getScrollPosition","target","scrollLeft","scrollTop","getMouseHit","hitmap","object","onPointerLeave","onPointerDown","selectedColumns","selectedRows","connected","dragStart","dragEnd","onDragOffsetChange","onDragIndicesChange","asGroup","knobX","knobY","onKnobAreaChange","onPointerUp","onDropTargetChange","insideSelection","insideGroup","preceding","order","dontChangeSelectionOnOrderChange","onColumnOrderChange","onInvalidateColumn","onRowOrderChange","onInvalidateRow","onPointerMove","currentScroll","newWidth","onCellWidthChange","newHeight","onCellHeightChange","headX","headY","xCellDiff","yCellDiff","onDoubleClick","autosized","onContextMenu","onRightClick","mouseHandlers","useMouse","animationFrameId","selectionActive","selected","gridRight","gridBottom","drawGridLineX","drawGridLineY","content","isActive","groupKey","isInRowGroup","resolvedStyle","isInColumnGroup","selectedStyle","activeStyle","secondarySelection","shiftX","shiftY","dragColumns","dragRows","hasRowShadow","hasColumnShadow","renderSheet","lastEditKey","editTextPosition","editTextWidth","editTextHeight","editTextTextAlign","textX","textY","inputProps","autoFocus","onKeyDown","position","padding","outline","border","input","overlayDivClassName","styles","overlayDivStyles","overflow","borderBottom","canvasStyles","renderedInside","renderedOutside","useImperativeHandle","onFocus","onBlur","tabIndex","pointerEvents","initialDataBig","r","col","push","initialDataBasic","initialDataFormatting","random","triangleDown","Image","useWidthHeightControl","initialWidths","initialHeights","getColumnOrder","getRowOrder","setCellWidth","setCellHeight","newWidths","cw","entries","idx","newHeights","ch","useOrderControl","initialColumns","initialRows","columnOrder","setColumnOrder","rowOrder","setRowOrder","co","reduce","splice","ro","SheetBoxHeader","setData","onSelectionChanged","newData","cx","cy","readOnly","cacheLayout","SheetBoxBasic","parse","stringify","faCheck","SheetBoxStyle","colors","horizontalAlign","console","log","undefined","incrementCell","SheetBoxFormatting","toFixed","Number","SheetBoxRender","renderInside","noteOpen","includes","marker","borderTop","borderLeft","note","background","stopPropagation","SheetBoxGrouped","orderedGroupKeys","_","alternatingGroups","list","at","bit","SheetBoxVeryBigData","loadingStatus","setLoadingStatus","href","preventDefault","fetch","response","dataset","toString","padStart","g","customInputOptions","customInputOptions2","customInputData","SheetBoxCustomInput","inputComponent","CustomInput","boxShadow","opt","CustomOption","clickHandler","hover","setHover","onMouseEnter","onMouseLeave","cursor","SheetBoxSourceDisplayData","Header","textAreaRef","copySuccess","setCopySuccess","id","select","execCommand","focus","rel","GitIcon","TitleSeparator","title","Wrap","children","SourceDisplayDataCode","xcode2","xcode","hljs","language","InitSheetCode","InitSheetWithDataCode","EditDataCode","CellStyleSizeCode","borderRadius","Footer","Emphased","App","overflowX","ReactDOM","render"],"mappings":"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","file":"static/js/main.d7d1d560.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/logo.aef13910.svg\";","module.exports = __webpack_public_path__ + \"static/media/git.f818b886.svg\";","import React from 'react';\nimport Logo from '../assets/logo.svg';\n\nfunction Menu() {\n    const scrollTo = (elId) => {\n        var element = document.getElementById(elId);\n        var headerOffset = elId === 'home' ? 0 : 86;\n        var elementPosition = window.pageYOffset + element.getBoundingClientRect().top;\n        var offsetPosition = elementPosition - headerOffset;\n\n        window.scrollTo({\n            top: offsetPosition,\n            behavior: 'smooth',\n        });\n    };\n\n    return (\n        <div className=\"container blue-bg menu\">\n            <div className=\"content flex-row\">\n                <div className=\"logo-box\">\n                    <img src={Logo} alt=\"Logo\" />\n                    <h2 className=\"page-title\">sheet - happens</h2>\n                </div>\n                <div className=\"nav\">\n                    <div className=\"nav-item\" onClick={() => scrollTo('home')}>\n                        home\n                    </div>\n                    <div className=\"nav-item\" onClick={() => scrollTo('usage')}>\n                        usage\n                    </div>\n                    <div className=\"nav-item\" onClick={() => scrollTo('features')}>\n                        features\n                    </div>\n                    <div className=\"nav-item\" onClick={() => scrollTo('documentation')}>\n                        documentation\n                    </div>\n                </div>\n            </div>\n        </div>\n    );\n}\n\nexport default Menu;\n","import { XY, Rectangle, Selection, Clickable, Direction, Style } from './types';\n\nexport const INITIAL_MAX_SCROLL: XY = [2000, 1000];\n\nexport const ORIGIN: XY = [0, 0];\nexport const ONE_ONE: XY = [1, 1];\nexport const NEG_NEG: XY = [-1, -1];\n\nexport const NO_CELL: XY = [-1, -1];\nexport const NO_SELECTION: Rectangle = [NO_CELL, NO_CELL];\nexport const NO_SELECTIONS: Selection[] = [];\nexport const NO_CLICKABLES: Clickable[] = [];\nexport const NO_STYLE = {};\n\nexport const MAX_SEARCHABLE_INDEX = 100000;\n\nexport const COLORS = {\n    selectionBorder: '#1a66ff',\n    selectionBackground: '#d8e6ff80',\n\n    gridLine: '#0000001f',\n\n    dragGhost: '#1a66ff30',\n    dropTarget: '#1a66ff',\n    knobAreaBorder: '#707070',\n\n    headerBackground: '#f6f9fc',\n    headerText: '#666666',\n    headerActive: '#e8f0ff',\n    headerActiveText: '#1a66ff',\n\n    headerSelected: '#1a66ff',\n    headerSelectedGroup: '#1a66ff70',\n    headerSelectedText: '#ffffff',\n    headerSelectedGroupText: '#ffffff',\n\n    shadowColor: '#000000',\n};\n\nexport const SIZES = {\n    knobArea: 6,\n    headerWidth: 50,\n    headerHeight: 22,\n    minimumWidth: 50,\n    minimumHeight: 22,\n    resizeZone: 4,\n    scrollZone: 50,\n    scrollSpeed: 30,\n\n    shadowBlur: 12,\n    shadowOpacity: 0.05,\n};\n\nexport const DEFAULT_CELL_STYLE: Required<Style> = {\n    textAlign: 'left',\n    fontSize: 12,\n    marginRight: 5,\n    marginLeft: 5,\n    color: '#000',\n    fontFamily: 'sans-serif',\n    weight: '',\n    fillColor: '',\n    backgroundColor: '',\n};\n\nexport const DEFAULT_COLUMN_HEADER_STYLE: Required<Style> = {\n    textAlign: 'center',\n    fontSize: 12,\n    marginRight: 5,\n    marginLeft: 5,\n    color: '#000',\n    fontFamily: 'sans-serif',\n    weight: '',\n    fillColor: '',\n    backgroundColor: '',\n};\n\nexport const HEADER_ACTIVE_STYLE = {\n    color: COLORS.headerActiveText,\n};\n\nexport const HEADER_SELECTED_STYLE = {\n    backgroundColor: COLORS.headerSelected,\n    color: COLORS.headerSelectedText,\n};\n\nexport const HEADER_GROUP_SELECTED_STYLE = {\n    backgroundColor: COLORS.headerSelectedGroup,\n    color: COLORS.headerSelectedGroupText,\n};\n\nexport const ARROW_KEYS: Record<string, Direction> = {\n    ArrowRight: 'right',\n    ArrowLeft: 'left',\n    ArrowUp: 'up',\n    ArrowDown: 'down',\n};\n","export const tail = <T>(list: T[]): T => list[list.length - 1];\n\nexport const clamp = (x: number, min: number, max: number) => Math.max(Math.min(max, x), min);\n\nexport const seq = (n: number, s: number = 0, d: number = 1): number[] =>\n    Array.from({ length: n }).map((_, i: number) => s + d * i);\n\nexport const isInRange = (x: number, min: number, max: number) => min <= x && x <= max;\nexport const isInRangeLeft = (x: number, min: number, max: number) => min <= x && x < max;\nexport const isInRangeRight = (x: number, min: number, max: number) => min < x && x <= max;\nexport const isInRangeCenter = (x: number, min: number, max: number) => min < x && x < max;\n","import { XY, Rectangle } from './types';\nimport { clamp } from './util';\n\nexport const addXY = (a: XY, b: XY): XY => [a[0] + b[0], a[1] + b[1]];\nexport const subXY = (a: XY, b: XY): XY => [a[0] - b[0], a[1] - b[1]];\nexport const mulXY = (a: XY, b: XY): XY => [a[0] * b[0], a[1] * b[1]];\nexport const maxXY = (a: XY, b: XY): XY => [Math.max(a[0], b[0]), Math.max(a[1], b[1])];\nexport const minXY = (a: XY, b: XY): XY => [Math.min(a[0], b[0]), Math.min(a[1], b[1])];\nexport const clampXY = (p: XY, min: XY, max: XY = [Infinity, Infinity]): XY => [\n    clamp(p[0], min[0], max[0]),\n    clamp(p[1], min[1], max[1]),\n];\n\nexport const getDirectionStep = (direction: string): XY => {\n    if (direction === 'left') return [-1, 0];\n    if (direction === 'right') return [1, 0];\n    if (direction === 'up') return [0, -1];\n    if (direction === 'down') return [0, 1];\n    return [0, 0];\n};\n\nexport const isSameXY = (a: XY, b: XY) => a[0] === b[0] && a[1] === b[1];\n\nexport const isSameSelection = (a: Rectangle, b: Rectangle) => {\n    const [a1, a2] = a;\n    const [b1, b2] = b;\n    return isSameXY(a1, b1) && isSameXY(a2, b2);\n};\n\nexport const forRange = (min: number, max: number, callback: (i: number) => void) => {\n    for (let i = min; i <= max; ++i) callback(i);\n};\n\nexport const forSelectionColumns = (selection: Rectangle) => (callback: (i: number) => void) => {\n    const [[left], [right]] = normalizeSelection(selection);\n    forRange(left, right, callback);\n};\n\nexport const forSelectionRows = (selection: Rectangle) => (callback: (i: number) => void) => {\n    const [[, top], [, bottom]] = normalizeSelection(selection);\n    forRange(top, bottom, callback);\n};\n\nconst forToMap = <A extends Array<any>>(forLoop: (callback: (...args: A) => void) => void) => <B>(\n    map: (...args: A) => B\n) => {\n    const out: B[] = [];\n    forLoop((...args: A) => out.push(map(...args)));\n    return out;\n};\n\nexport const mapSelectionColumns = (selection: Rectangle) => forToMap(forSelectionColumns(selection));\nexport const mapSelectionRows = (selection: Rectangle) => forToMap(forSelectionRows(selection));\n\n// Selection is infinite horizontally\nexport const isMaybeRowSelection = (selection: Rectangle) => {\n    const [[left], [right]] = selection;\n    return left === -1 && right === -1;\n};\n\n// Selection is infinite vertically\nexport const isMaybeColumnSelection = (selection: Rectangle) => {\n    const [[, top], [, bottom]] = selection;\n    return top === -1 && bottom === -1;\n};\n\n// Selection is ONLY infinite horizontally\nexport const isRowSelection = (selection: Rectangle) => {\n    const [[left, top], [right, bottom]] = selection;\n    return left === -1 && right === -1 && top !== -1 && bottom !== -1;\n};\n\n// Selection is ONLY infinite vertically\nexport const isColumnSelection = (selection: Rectangle) => {\n    const [[left, top], [right, bottom]] = selection;\n    return top === -1 && bottom === -1 && left !== -1 && right !== -1;\n};\n\n// Selection is not infinite\nexport const isCellSelection = (selection: Rectangle) => {\n    const [[left, top], [right, bottom]] = selection;\n    return left !== -1 && right !== -1 && top !== -1 && bottom !== -1;\n};\n\n// Selection is null\nexport const isEmptySelection = (selection: Rectangle) => {\n    const [[left, top], [right, bottom]] = selection;\n    return left === -1 && right === -1 && top === -1 && bottom === -1;\n};\n\n// Test cell inside selection (inclusive edges)\nexport const isPointInsideSelection = (selection: Rectangle, point: XY) => {\n    const [[left, top], [right, bottom]] = normalizeSelection(selection);\n    const [x, y] = point;\n    return x >= left && x <= right && y >= top && y <= bottom;\n};\n\n// Validate selections to avoid half-infinite anchor/head\nexport const validateSelection = (selection: Rectangle): Rectangle => {\n    let [anchor, head] = selection;\n    anchor = anchor.slice() as XY;\n    head = head.slice() as XY;\n\n    const min = minXY(anchor, head);\n    if (min[0] === -1) anchor[0] = head[0] = -1;\n    if (min[1] === -1) anchor[1] = head[1] = -1;\n\n    return [anchor, head];\n};\n\n// Normalize rectangle to min/max pair\nexport const normalizeSelection = (selection: Rectangle): Rectangle => {\n    const [anchor, head] = selection;\n    return [minXY(anchor, head), maxXY(anchor, head)];\n};\n\n// Orient normalized rectangle to match existing orientation\nexport const orientSelection = (normalized: Rectangle, to: Rectangle): Rectangle => {\n    const [[left, top], [right, bottom]] = normalized;\n\n    const [anchor, head] = to;\n    const [ax, ay] = anchor;\n    const [hx, hy] = head;\n\n    const swapX = (ax - hx || 1) * (right - left || 1) < 0;\n    const swapY = (ay - hy || 1) * (bottom - top || 1) < 0;\n\n    return [\n        [swapX ? right : left, swapY ? bottom : top],\n        [swapX ? left : right, swapY ? top : bottom],\n    ];\n};\n\n// Clip rectangle to max range\nexport const clipSelection = (selection: Rectangle, max: XY): Rectangle => {\n    const [anchor, head] = selection;\n    return [minXY(anchor, max), minXY(head, max)];\n};\n","import { XY, Rectangle, RowOrColumnPropertyFunction } from './types';\nimport { normalizeSelection, orientSelection } from './coordinate';\n\nconst LIMIT = 1000;\n\nconst scanGroup = (\n    keys: RowOrColumnPropertyFunction<string | number | null>,\n    index: number,\n    direction: number,\n    matchKeys: Set<string | number | null>\n) => {\n    let i = 1;\n    const limit = direction > 0 ? LIMIT : Math.min(LIMIT, index + 1);\n    for (; i < limit; i++) {\n        const key = keys(index + i * direction);\n        if (key == null || !matchKeys.has(key)) break;\n    }\n    return index + (i - 1) * direction;\n};\n\n// Expand a selection to its adjacent row or column group\nexport const expandSelectionToRowOrColumnGroups = (\n    selection: Rectangle,\n    groupKeys: RowOrColumnPropertyFunction<string | number | null>,\n    matchKeys: Set<string | number | null> | null,\n    coordinate: number // 0/1 for X/Y\n) => {\n    if (!matchKeys) return selection;\n\n    const [first, second] = normalizeSelection(selection);\n\n    const start = first[coordinate];\n    const end = second[coordinate];\n\n    const startIndex = scanGroup(groupKeys, start, -1, matchKeys);\n    const endIndex = scanGroup(groupKeys, end, 1, matchKeys);\n\n    const expanded: Rectangle = [first.slice() as XY, second.slice() as XY];\n    expanded[0][coordinate] = startIndex;\n    expanded[1][coordinate] = endIndex;\n\n    const oriented = orientSelection(expanded, selection);\n    return oriented;\n};\n\nexport const isBoundaryInsideGroup = (\n    index: number,\n    groupKeys: RowOrColumnPropertyFunction<string | number | null>\n) => {\n    const before = groupKeys(index - 1);\n    const after = groupKeys(index);\n    return before != null && after != null && before === after;\n};\n","import {\n    Direction,\n    XY,\n    CellContentType,\n    CellProperty,\n    CellPropertyFunction,\n    CellPropertyStyled,\n    CellPropertyStyledFunction,\n    PropTypes,\n    RowOrColumnProperty,\n    RowOrColumnPropertyFunction,\n    RowOrColumnPropertyStyled,\n    RowOrColumnPropertyStyledFunction,\n} from './types';\nimport { MAX_SEARCHABLE_INDEX, ORIGIN, DEFAULT_CELL_STYLE } from './constants';\nimport { addXY, subXY, maxXY, getDirectionStep } from './coordinate';\n\n// Inject row/column props from an array, function, constant or default value\nexport const createRowOrColumnProp = <T extends PropTypes>(\n    rowColProp: RowOrColumnProperty<T> | undefined,\n    defaultValue: T\n): RowOrColumnPropertyFunction<T> => {\n    if (Array.isArray(rowColProp)) {\n        return (rowOrColIndex: number) => {\n            if (rowOrColIndex >= 0 && rowOrColIndex < rowColProp.length) {\n                return rowColProp[rowOrColIndex];\n            } else {\n                return defaultValue;\n            }\n        };\n    } else if (typeof rowColProp === 'function') {\n        return rowColProp;\n    } else if (rowColProp !== null && rowColProp !== undefined) {\n        return () => rowColProp;\n    } else {\n        return () => defaultValue;\n    }\n};\n\n// Inject cell props from a nested array, function, constant or default value\nexport const createCellProp = <T extends PropTypes>(\n    cellProp: CellProperty<T> | undefined,\n    defaultValue: T\n): CellPropertyFunction<T> => {\n    if (Array.isArray(cellProp)) {\n        return (x: number, y: number) => {\n            if (y >= 0 && y < cellProp.length) {\n                if (x >= 0 && x < cellProp[y].length) {\n                    return cellProp[y][x];\n                } else {\n                    return defaultValue;\n                }\n            } else {\n                return defaultValue;\n            }\n        };\n    } else if (typeof cellProp === 'function') {\n        return cellProp;\n    } else if (cellProp !== null && cellProp !== undefined) {\n        return () => cellProp;\n    } else {\n        return () => defaultValue;\n    }\n};\n\n// Inject row/column props from an array, function, constant or default value\nexport const createRowOrColumnStyledProp = <T extends PropTypes>(\n    rowColProp: RowOrColumnPropertyStyled<T> | undefined,\n    defaultValue: T\n): RowOrColumnPropertyStyledFunction<T> => {\n    if (Array.isArray(rowColProp)) {\n        return (rowOrColIndex: number) => {\n            if (rowOrColIndex >= 0 && rowOrColIndex < rowColProp.length) {\n                return rowColProp[rowOrColIndex];\n            } else {\n                return defaultValue;\n            }\n        };\n    } else if (typeof rowColProp === 'function') {\n        return rowColProp;\n    } else if (rowColProp !== null && rowColProp !== undefined) {\n        return () => rowColProp;\n    } else {\n        return () => defaultValue;\n    }\n};\n\n// Inject cell props from a nested array, function, constant or default value\nexport const createCellStyledProp = <T extends PropTypes>(\n    cellProp: CellPropertyStyled<T> | undefined,\n    defaultValue: T\n): CellPropertyStyledFunction<T> => {\n    if (Array.isArray(cellProp)) {\n        return (x: number, y: number) => {\n            if (y >= 0 && y < cellProp.length) {\n                if (x >= 0 && x < cellProp[y].length) {\n                    return cellProp[y][x];\n                } else {\n                    return defaultValue;\n                }\n            } else {\n                return defaultValue;\n            }\n        };\n    } else if (typeof cellProp === 'function') {\n        return cellProp;\n    } else if (cellProp !== null && cellProp !== undefined) {\n        return () => cellProp;\n    } else {\n        return () => defaultValue;\n    }\n};\n\nexport const findApproxMaxEditDataIndex = (editData: CellPropertyFunction<string>): XY => {\n    let x = 0;\n    let y = 0;\n    let howManyEmpty = 0;\n    let growthIncrement = 10;\n    let growthIncrementFactor = 1.5;\n\n    // x\n    while (howManyEmpty < 4) {\n        let allEmpty = true;\n        for (let yy = 0; yy < 10; yy++) {\n            const data = editData(x, yy);\n            if (data !== null && data !== undefined && data !== '') {\n                allEmpty = false;\n                break;\n            }\n        }\n        if (allEmpty) {\n            howManyEmpty += 1;\n        }\n        x += growthIncrement;\n        if (x > MAX_SEARCHABLE_INDEX) {\n            break;\n        }\n        growthIncrement = Math.floor(growthIncrement * growthIncrementFactor);\n    }\n\n    howManyEmpty = 0;\n    growthIncrement = 10;\n    growthIncrementFactor = 1.5;\n\n    // y\n    while (howManyEmpty < 4) {\n        let allEmpty = true;\n        for (let xx = 0; xx < 10; xx++) {\n            const data = editData(xx, y);\n            if (data !== null && data !== undefined && data !== '') {\n                allEmpty = false;\n                break;\n            }\n        }\n        if (allEmpty) {\n            howManyEmpty += 1;\n        }\n        y += growthIncrement;\n        if (y > MAX_SEARCHABLE_INDEX) {\n            break;\n        }\n        growthIncrement = Math.floor(growthIncrement * growthIncrementFactor);\n    }\n    return [x, y];\n};\n\nexport const findInDisplayData = (\n    displayData: CellPropertyStyledFunction<CellContentType>,\n    start: XY,\n    direction: Direction\n): XY => {\n    const step = getDirectionStep(direction);\n\n    let cell = maxXY(start, ORIGIN);\n    const [x, y] = addXY(cell, step);\n    const first = displayData(x, y, DEFAULT_CELL_STYLE);\n    const firstFilled = first !== '' && first !== null && first !== undefined;\n\n    if (!firstFilled) {\n        cell = addXY(cell, step);\n    }\n\n    let [cellX, cellY] = cell;\n    const maxX = cellX + MAX_SEARCHABLE_INDEX - 1;\n    const maxY = cellY + MAX_SEARCHABLE_INDEX - 1;\n\n    while (cellX < maxX && cellY < maxY && cellX >= 0 && cellY >= 0) {\n        const data = displayData(cellX, cellY, DEFAULT_CELL_STYLE);\n\n        // if first cell is filled, find the last filled cell, so first look for first unfilled\n        if (firstFilled && (data === '' || data === null || data === undefined)) {\n            return subXY(cell, step);\n        }\n        // if first cell is not filled, just find the first filled\n        if (!firstFilled && data !== '' && data !== null && data !== undefined) {\n            return cell;\n        }\n\n        [cellX, cellY] = cell = addXY(cell, step);\n    }\n\n    return maxXY(cell, [0, 0]);\n};\n","import {\n    CellLayout,\n    CellPropertyFunction,\n    Change,\n    Clickable,\n    Rectangle,\n    RowOrColumnPropertyFunction,\n    SheetMouseEvent,\n    SheetStyle,\n    VisibleLayout,\n    XY,\n} from './types';\nimport { MouseEvent, PointerEvent, RefObject, useCallback, useMemo, useRef, useState } from 'react';\nimport {\n    normalizeSelection,\n    mapSelectionColumns,\n    mapSelectionRows,\n    isColumnSelection,\n    isRowSelection,\n    isCellSelection,\n    isMaybeRowSelection,\n    isPointInsideSelection,\n    addXY,\n    subXY,\n    maxXY,\n} from './coordinate';\nimport { ONE_ONE, ORIGIN, SIZES } from './constants';\nimport { isBoundaryInsideGroup, expandSelectionToRowOrColumnGroups } from './group';\nimport { findApproxMaxEditDataIndex } from './props';\nimport { isInRange, seq } from './util';\n\ntype DragOp = {\n    anchor: number;\n    scroll: number;\n    size: number;\n    indices: number[];\n};\n\nexport const useMouse = (\n    hitmapRef: RefObject<Clickable[]>,\n    selection: Rectangle,\n    knobArea: Rectangle | null,\n    editMode: boolean,\n    editData: CellPropertyFunction<string>,\n    sourceData: CellPropertyFunction<string | number | null>,\n    cellReadOnly: CellPropertyFunction<boolean | null>,\n\n    canSizeColumn: RowOrColumnPropertyFunction<boolean | null>,\n    canSizeRow: RowOrColumnPropertyFunction<boolean | null>,\n    canOrderColumn: RowOrColumnPropertyFunction<boolean | null>,\n    canOrderRow: RowOrColumnPropertyFunction<boolean | null>,\n\n    cellLayout: CellLayout,\n    visibleCells: VisibleLayout,\n    sheetStyle: SheetStyle,\n\n    columnGroupKeys: RowOrColumnPropertyFunction<string | number | null>,\n    rowGroupKeys: RowOrColumnPropertyFunction<string | number | null>,\n    selectedColumnGroups: Set<string | number | null> | null,\n    selectedRowGroups: Set<string | number | null> | null,\n\n    getAutoSizeWidth: (column: number) => number,\n\n    onEdit?: (cell: XY) => void,\n    onCommit?: () => void,\n    onKnobAreaChange?: (knobArea: Rectangle | null) => void,\n    onDragIndicesChange?: (indices: [number[] | null, number[] | null]) => void,\n    onDragOffsetChange?: (dragOffset: XY | null) => void,\n    onDropTargetChange?: (selection: Rectangle | null) => void,\n    onSelectionChange?: (selection: Rectangle, scrollTo?: boolean, toHead?: boolean) => void,\n    onFocusChange?: (focus: boolean) => void,\n\n    onInvalidateColumn?: (column: number) => void,\n    onInvalidateRow?: (row: number) => void,\n\n    onChange?: (changes: Change[]) => void,\n    onColumnOrderChange?: (indices: number[], order: number) => void,\n    onRowOrderChange?: (indices: number[], order: number) => void,\n    onCellWidthChange?: (indices: number[], values: number[]) => void,\n    onCellHeightChange?: (indices: number[], values: number[]) => void,\n    onRightClick?: (e: SheetMouseEvent) => void,\n\n    dontCommitEditOnSelectionChange?: boolean,\n    dontChangeSelectionOnOrderChange?: boolean\n) => {\n    const [hitTarget, setHitTarget] = useState<Clickable | null>(null);\n\n    const [columnResize, setColumnResize] = useState<DragOp | null>(null);\n    const [rowResize, setRowResize] = useState<DragOp | null>(null);\n    const [columnDrag, setColumnDrag] = useState<DragOp | null>(null);\n    const [rowDrag, setRowDrag] = useState<DragOp | null>(null);\n\n    const [draggingKnob, setDraggingKnob] = useState(false);\n    const [draggingSelection, setDraggingSelection] = useState(false);\n    const [draggingRowSelection, setDraggingRowSelection] = useState(false);\n    const [draggingColumnSelection, setDraggingColumnSelection] = useState(false);\n\n    const { hideRowHeaders, hideColumnHeaders } = sheetStyle;\n    const { cellToPixel, getVersion } = cellLayout;\n    const version = getVersion();\n\n    const knobPosition = useMemo((): XY | null => {\n        const [, [maxX, maxY]] = normalizeSelection(selection);\n        if (isRowSelection(selection)) {\n            return subXY(addXY(cellToPixel([0, maxY], [0, 1]), [SIZES.knobArea * 0.5, 0]), ONE_ONE);\n        }\n        if (isColumnSelection(selection)) {\n            return subXY(addXY(cellToPixel([maxX, 0], [1, 0]), [0, SIZES.knobArea * 0.5]), ONE_ONE);\n        }\n        if (isCellSelection(selection)) {\n            return subXY(cellToPixel([maxX, maxY], ONE_ONE), ONE_ONE);\n        }\n        return null;\n    }, [selection, cellToPixel, version]);\n\n    // Pass pointer/dragging state into handlers via ref so they don't need to rebind during resizes/drags\n    const refState = {\n        selection,\n        knobArea,\n        editMode,\n        editData,\n        sourceData,\n        cellLayout,\n        visibleCells,\n        hitTarget,\n\n        knobPosition,\n        columnResize,\n        rowResize,\n        columnDrag,\n        rowDrag,\n\n        draggingKnob,\n        draggingSelection,\n        draggingRowSelection,\n        draggingColumnSelection,\n    };\n    const ref = useRef(refState);\n    ref.current = refState;\n\n    // Hit-testing for rendered objects\n    const getMousePosition = useCallback((e: PointerEvent<any> | MouseEvent<any>) => {\n        if (!e.target || !(e.target instanceof Element)) {\n            return null;\n        }\n\n        const rect = e.target.getBoundingClientRect();\n        const xy: XY = [e.clientX - rect.left, e.clientY - rect.top];\n\n        // Ignore clicks on scrollbar\n        if (xy[0] > e.target.clientWidth || xy[1] > e.target.clientHeight) {\n            return null;\n        }\n\n        return xy;\n    }, []);\n\n    const getScrollPosition = useCallback((e: PointerEvent<any> | MouseEvent<any>) => {\n        if (!e.target || !(e.target instanceof Element)) {\n            return [0, 0];\n        }\n\n        const { scrollLeft, scrollTop } = e.target as any;\n        const xy: XY = [scrollLeft, scrollTop];\n\n        return xy;\n    }, []);\n\n    const getMouseHit = useCallback(\n        (xy: XY) => {\n            const { current: hitmap } = hitmapRef;\n            if (!hitmap) return null;\n\n            for (const object of hitmap) {\n                const { rect } = object;\n                if (isPointInsideSelection(rect, xy)) {\n                    return object;\n                }\n            }\n\n            return null;\n        },\n        [hitmapRef]\n    );\n\n    const onPointerLeave = useCallback(() => {\n        window.document.body.style.cursor = 'auto';\n    }, []);\n\n    const onPointerDown = useCallback(\n        (e: PointerEvent<HTMLDivElement>) => {\n            const {\n                current: {\n                    selection,\n                    cellLayout: { columnToPixel, rowToPixel, pixelToCell, getIndentX, getIndentY },\n                    visibleCells: { columns, rows },\n                    knobPosition,\n                },\n            } = ref;\n\n            onFocusChange?.(true);\n\n            if (e.button !== 0) return;\n\n            (e.target as Element)?.setPointerCapture?.(e.pointerId);\n\n            const xy = getMousePosition(e);\n            if (!xy) return;\n\n            const [x, y] = xy;\n            const hitTarget = getMouseHit(xy);\n            if (hitTarget) {\n                setHitTarget(hitTarget);\n                // Update hitTarget in ref in case there is no re-render between pointerDown and pointerUp\n                ref.current.hitTarget = hitTarget;\n                return;\n            }\n\n            const normalized = normalizeSelection(selection);\n            const [[minX, minY], [maxX, maxY]] = normalized;\n\n            const selectedColumns = mapSelectionColumns(selection)((i) => i);\n            const selectedRows = mapSelectionRows(selection)((i) => i);\n\n            // Column header\n            if (!hideColumnHeaders && y < getIndentY()) {\n                // Grab selected columns in column selection\n                if (onColumnOrderChange) {\n                    // Trim off start/end so resize works there\n                    const start = columnToPixel(minX) + SIZES.resizeZone;\n                    const end = columnToPixel(maxX, 1) - SIZES.resizeZone;\n                    if (isInRange(x, start, end) || selectedColumnGroups) {\n                        for (const index of columns) {\n                            const start = columnToPixel(index, 0);\n                            const end = columnToPixel(index, 1);\n\n                            if (\n                                isColumnSelection(selection) &&\n                                isInRange(x, start, end) &&\n                                (isInRange(index, minX, maxX) || selectedColumnGroups?.has(columnGroupKeys(index))) &&\n                                canOrderColumn(index)\n                            ) {\n                                window.document.body.style.cursor = 'grabbing';\n\n                                // Find all indices that need to be moved, from selection or matching groups\n                                const indices = Array.from(\n                                    new Set([\n                                        ...selectedColumns,\n                                        ...(selectedColumnGroups\n                                            ? columns.filter((index) =>\n                                                  selectedColumnGroups.has(columnGroupKeys(index))\n                                              )\n                                            : []),\n                                    ]).values()\n                                );\n                                indices.sort((a, b) => a - b);\n\n                                // Make one continuous drag shadow around the cursor for a contiguous group\n                                let dragIndices = indices;\n                                if (selectedColumnGroups) {\n                                    const clickSelection: Rectangle = [\n                                        [index, -1],\n                                        [index, -1],\n                                    ];\n                                    const [[left], [right]] = expandSelectionToRowOrColumnGroups(\n                                        clickSelection,\n                                        columnGroupKeys,\n                                        selectedColumnGroups,\n                                        0\n                                    );\n\n                                    // Extend to whole selection if it's part of the same 'chunk'\n                                    const connected = !(minX > right || maxX < left);\n                                    const dragStart = connected ? Math.min(minX, left) : left;\n                                    const dragEnd = connected ? Math.max(maxX, right) : right;\n                                    dragIndices = seq(dragEnd - dragStart + 1, dragStart);\n                                }\n\n                                const size = columnToPixel(maxX, 1) - columnToPixel(minX);\n                                const [scroll] = getScrollPosition(e);\n\n                                setColumnDrag({\n                                    anchor: x,\n                                    scroll,\n                                    size,\n                                    indices,\n                                });\n                                onDragOffsetChange?.([0, 0]);\n                                onDragIndicesChange?.([dragIndices, null]);\n                                return;\n                            }\n                        }\n                    }\n                }\n\n                // Resize columns\n                if (onCellWidthChange) {\n                    for (const index of columns) {\n                        const edge = columnToPixel(index, 1);\n\n                        if (Math.abs(edge - x) < SIZES.resizeZone && canSizeColumn(index)) {\n                            window.document.body.style.cursor = 'col-resize';\n\n                            const asGroup = isColumnSelection(selection) && maxX === index;\n                            const indices = asGroup ? selectedColumns : [index];\n\n                            const size = asGroup\n                                ? columnToPixel(maxX, 1) - columnToPixel(minX)\n                                : columnToPixel(index, 1) - columnToPixel(index);\n                            const [scroll] = getScrollPosition(e);\n\n                            setColumnResize({\n                                anchor: x,\n                                scroll,\n                                size,\n                                indices,\n                            });\n                            return;\n                        }\n                    }\n                }\n            }\n\n            if (!hideRowHeaders && x < getIndentX()) {\n                // Grab selected rows in row selection\n                if (onRowOrderChange) {\n                    // Trim off start/end so resize works there\n                    const start = rowToPixel(minY) + SIZES.resizeZone;\n                    const end = rowToPixel(maxY, 1) - SIZES.resizeZone;\n\n                    if (isInRange(y, start, end) || selectedRowGroups) {\n                        for (const index of rows) {\n                            const start = rowToPixel(index, 0);\n                            const end = rowToPixel(index, 1);\n\n                            if (\n                                isRowSelection(selection) &&\n                                isInRange(y, start, end) &&\n                                (isInRange(index, minY, maxY) || selectedRowGroups?.has(rowGroupKeys(index))) &&\n                                canOrderRow(index)\n                            ) {\n                                window.document.body.style.cursor = 'grabbing';\n\n                                // Find all indices that need to be moved, from selection or matching groups\n                                const indices = Array.from(\n                                    new Set([\n                                        ...selectedRows,\n                                        ...(selectedRowGroups\n                                            ? rows\n                                                  .map((_, i) => i)\n                                                  .filter((index) => selectedRowGroups.has(rowGroupKeys(index)))\n                                            : []),\n                                    ]).values()\n                                );\n                                indices.sort((a, b) => a - b);\n\n                                // Make one continuous drag shadow around the cursor for a contiguous group\n                                let dragIndices = indices;\n                                if (selectedRowGroups) {\n                                    const clickSelection: Rectangle = [\n                                        [-1, index],\n                                        [-1, index],\n                                    ];\n                                    const [[, top], [, bottom]] = expandSelectionToRowOrColumnGroups(\n                                        clickSelection,\n                                        rowGroupKeys,\n                                        selectedRowGroups,\n                                        1\n                                    );\n\n                                    // Extend to whole selection if it's part of the same 'chunk'\n                                    const connected = !(minY > bottom || maxY < top);\n                                    const dragStart = connected ? Math.min(minY, top) : top;\n                                    const dragEnd = connected ? Math.max(maxY, bottom) : bottom;\n                                    dragIndices = seq(dragEnd - dragStart + 1, dragStart);\n                                }\n\n                                const size = rowToPixel(maxY, 1) - rowToPixel(minY);\n                                const [, scroll] = getScrollPosition(e);\n\n                                setRowDrag({\n                                    anchor: y,\n                                    scroll,\n                                    size,\n                                    indices,\n                                });\n                                onDragOffsetChange?.([0, 0]);\n                                onDragIndicesChange?.([null, dragIndices]);\n                                return;\n                            }\n                        }\n                    }\n                }\n\n                // Resize rows\n                if (onCellHeightChange) {\n                    for (const index of rows) {\n                        const edge = rowToPixel(index, 1);\n\n                        if (Math.abs(edge - y) < SIZES.resizeZone && canSizeRow(index)) {\n                            window.document.body.style.cursor = 'row-resize';\n\n                            const asGroup = isRowSelection(selection) && maxY === index;\n                            const indices = asGroup ? selectedRows : [index];\n\n                            const size = asGroup\n                                ? rowToPixel(maxY, 1) - rowToPixel(minY)\n                                : rowToPixel(index, 1) - rowToPixel(index);\n                            const [, scroll] = getScrollPosition(e);\n\n                            setRowResize({\n                                anchor: y,\n                                scroll,\n                                size,\n                                indices,\n                            });\n                            return;\n                        }\n                    }\n                }\n            }\n\n            // Knob drag mode\n            if (knobPosition) {\n                const [knobX, knobY] = knobPosition;\n                if (Math.abs(x - knobX) < SIZES.knobArea && Math.abs(y - knobY) < SIZES.knobArea) {\n                    setDraggingKnob(true);\n                    onKnobAreaChange?.(selection);\n                    return;\n                }\n            }\n\n            // Normal cell click\n            const head = pixelToCell(xy);\n            const anchor: XY = e.shiftKey ? [...selection[0]] : head;\n\n            if (editMode) {\n                if (!dontCommitEditOnSelectionChange) {\n                    onCommit?.();\n                }\n            }\n\n            let scrollTo = true;\n\n            if (!hideRowHeaders && x < getIndentX()) {\n                scrollTo = false;\n                setDraggingRowSelection(true);\n                anchor[0] = -1;\n                head[0] = -1;\n            }\n\n            if (!hideColumnHeaders && y < getIndentY()) {\n                scrollTo = false;\n                setDraggingColumnSelection(true);\n                anchor[1] = -1;\n                head[1] = -1;\n            }\n\n            setDraggingSelection(true);\n            onSelectionChange?.([anchor, head], scrollTo, true);\n        },\n        [\n            getMousePosition,\n            getScrollPosition,\n            getMouseHit,\n            onColumnOrderChange,\n            onRowOrderChange,\n            onCellWidthChange,\n            onCellHeightChange,\n            onKnobAreaChange,\n            onSelectionChange,\n            onCommit,\n            canSizeColumn,\n            canSizeRow,\n            canOrderColumn,\n            canOrderRow,\n            dontCommitEditOnSelectionChange,\n            columnGroupKeys,\n            rowGroupKeys,\n            selectedColumnGroups,\n            selectedRowGroups,\n        ]\n    );\n\n    const onPointerUp = useCallback(\n        (e: PointerEvent<HTMLDivElement>) => {\n            const {\n                current: {\n                    knobArea,\n                    selection,\n                    sourceData,\n                    editData,\n\n                    columnDrag,\n                    rowDrag,\n\n                    draggingKnob,\n                    hitTarget,\n\n                    cellLayout: { pixelToColumn, pixelToRow, getIndentX, getIndentY },\n                },\n            } = ref;\n\n            onFocusChange?.(true);\n\n            if (knobArea && draggingKnob) {\n                const changes = parseKnobOperation(knobArea, selection, sourceData, editData, cellReadOnly);\n\n                onChange?.(changes);\n                onSelectionChange?.(knobArea, true, true);\n                onKnobAreaChange?.(null);\n            }\n\n            const xy = getMousePosition(e);\n            if (xy && (columnDrag || rowDrag)) {\n                window.document.body.style.cursor = 'auto';\n                onDragIndicesChange?.([null, null]);\n                onDragOffsetChange?.(null);\n                onDropTargetChange?.(null);\n\n                const [x, y] = xy;\n                const [[minX, minY], [maxX, maxY]] = normalizeSelection(selection);\n\n                const cellX = pixelToColumn(Math.max(x, getIndentX()), 0.5);\n                const cellY = pixelToRow(Math.max(y, getIndentY()), 0.5);\n\n                if (columnDrag) {\n                    const { indices } = columnDrag;\n\n                    const insideSelection = cellX >= minX && cellX <= maxX + 1;\n                    const insideGroup = selectedColumnGroups?.has(columnGroupKeys(x));\n                    if (!insideSelection && !insideGroup) {\n                        const preceding = indices.filter((i) => i < cellX);\n                        const order = cellX - preceding.length;\n                        dontChangeSelectionOnOrderChange ||\n                            onSelectionChange?.([\n                                [order, minY],\n                                [order + indices.length - 1, maxY],\n                            ]);\n                        onColumnOrderChange?.(indices, order);\n                        onInvalidateColumn?.(Math.min(minX, order));\n                    }\n                }\n                if (rowDrag) {\n                    const { indices } = rowDrag;\n\n                    const insideSelection = cellY >= minY && cellY <= maxY + 1;\n                    const insideGroup = selectedRowGroups?.has(rowGroupKeys(y));\n                    if (!insideSelection && !insideGroup) {\n                        const preceding = indices.filter((i) => i < cellY);\n                        const order = cellY - preceding.length;\n                        dontChangeSelectionOnOrderChange ||\n                            onSelectionChange?.([\n                                [minX, order],\n                                [maxX, order + indices.length - 1],\n                            ]);\n                        onRowOrderChange?.(indices, order);\n                        onInvalidateRow?.(Math.min(minY, order));\n                    }\n                }\n            }\n\n            setDraggingSelection(false);\n            setDraggingRowSelection(false);\n            setDraggingColumnSelection(false);\n            setDraggingKnob(false);\n            setColumnResize(null);\n            setColumnDrag(null);\n            setRowResize(null);\n            setRowDrag(null);\n\n            if (!xy || !hitTarget) return;\n            setHitTarget(null);\n\n            // Check hit target rect to see if it is the same as pointerDown\n            // (object identity might have changed due to react re-render)\n            const previousRect = JSON.stringify(hitTarget.rect);\n            const currentRect = JSON.stringify(getMouseHit(xy)?.rect);\n            if (previousRect === currentRect) {\n                const { obj } = hitTarget;\n                obj.onClick?.(e);\n            }\n        },\n        [\n            getMousePosition,\n            getMouseHit,\n            onChange,\n            onSelectionChange,\n            onKnobAreaChange,\n            onDropTargetChange,\n            onColumnOrderChange,\n            onRowOrderChange,\n            dontChangeSelectionOnOrderChange,\n        ]\n    );\n\n    const onPointerMove = useCallback(\n        (e: PointerEvent<HTMLDivElement>) => {\n            const {\n                current: {\n                    selection,\n                    visibleCells,\n\n                    knobPosition,\n                    columnResize,\n                    columnDrag,\n                    rowResize,\n                    rowDrag,\n\n                    draggingKnob,\n                    draggingSelection,\n                    draggingColumnSelection,\n                    draggingRowSelection,\n\n                    cellLayout: {\n                        columnToPixel,\n                        rowToPixel,\n                        pixelToCell,\n                        pixelToColumn,\n                        pixelToRow,\n                        getIndentX,\n                        getIndentY,\n                    },\n                },\n            } = ref;\n\n            window.document.body.style.cursor = 'auto';\n\n            const xy = getMousePosition(e);\n            if (!xy) return;\n\n            const hitTarget = getMouseHit(xy);\n            if (hitTarget) {\n                window.document.body.style.cursor = 'pointer';\n            } else if (columnDrag || rowDrag) {\n                window.document.body.style.cursor = 'grabbing';\n            } else if (columnResize) {\n                window.document.body.style.cursor = 'col-resize';\n                e.preventDefault();\n            } else if (rowResize) {\n                window.document.body.style.cursor = 'row-resize';\n                e.preventDefault();\n            } else if (draggingRowSelection || draggingColumnSelection) {\n                e.preventDefault();\n            }\n\n            const { columns, rows } = visibleCells;\n            const [x, y] = xy;\n            const [[minX, minY], [maxX, maxY]] = normalizeSelection(selection);\n\n            const isDragging =\n                columnResize || columnDrag || rowResize || rowDrag || draggingRowSelection || draggingColumnSelection;\n\n            if (!isDragging) {\n                if (!hideColumnHeaders && y < getIndentY()) {\n                    if (onColumnOrderChange) {\n                        // Trim off start/end so resize works there\n                        const start = columnToPixel(minX) + SIZES.resizeZone;\n                        const end = columnToPixel(maxX, 1) - SIZES.resizeZone;\n                        if (isInRange(x, start, end) || selectedColumnGroups) {\n                            for (const index of columns) {\n                                const start = columnToPixel(index);\n                                const end = columnToPixel(index, 1);\n\n                                if (\n                                    !draggingColumnSelection &&\n                                    isColumnSelection(selection) &&\n                                    isInRange(x, start, end) &&\n                                    (isInRange(index, minX, maxX) ||\n                                        selectedColumnGroups?.has(columnGroupKeys(index))) &&\n                                    canOrderColumn(index)\n                                ) {\n                                    window.document.body.style.cursor = 'grab';\n                                    return;\n                                }\n                            }\n                        }\n                    }\n                    if (onCellWidthChange) {\n                        for (const index of columns) {\n                            const edge = columnToPixel(index, 1);\n                            if (Math.abs(edge - x) < SIZES.resizeZone && canSizeColumn(index)) {\n                                window.document.body.style.cursor = 'col-resize';\n                                return;\n                            }\n                        }\n                    }\n                }\n\n                if (!hideRowHeaders && x < getIndentX()) {\n                    if (onRowOrderChange) {\n                        // Trim off start/end so resize works there\n                        const start = rowToPixel(minY) + SIZES.resizeZone;\n                        const end = rowToPixel(maxY, 1) - SIZES.resizeZone;\n                        if (isInRange(y, start, end) || selectedRowGroups) {\n                            for (const index of rows) {\n                                const start = rowToPixel(index);\n                                const end = rowToPixel(index, 1);\n\n                                if (\n                                    !draggingRowSelection &&\n                                    isRowSelection(selection) &&\n                                    isInRange(y, start, end) &&\n                                    (isInRange(index, minY, maxY) || selectedRowGroups?.has(rowGroupKeys(index))) &&\n                                    canOrderRow(index)\n                                ) {\n                                    window.document.body.style.cursor = 'grab';\n                                    return;\n                                }\n                            }\n                        }\n                    }\n                    if (onCellHeightChange) {\n                        for (const index of rows) {\n                            const edge = rowToPixel(index, 1);\n                            if (Math.abs(edge - y) < SIZES.resizeZone && canSizeRow(index)) {\n                                window.document.body.style.cursor = 'row-resize';\n                                return;\n                            }\n                        }\n                    }\n                }\n\n                if (knobPosition) {\n                    const [knobX, knobY] = knobPosition;\n                    if (Math.abs(x - knobX) < SIZES.knobArea && Math.abs(y - knobY) < SIZES.knobArea) {\n                        window.document.body.style.cursor = 'crosshair';\n                        return;\n                    }\n                }\n            }\n\n            if (columnResize) {\n                if (onCellWidthChange) {\n                    const { size, anchor, scroll, indices } = columnResize;\n                    const [currentScroll] = getScrollPosition(e);\n                    const newWidth = Math.max(\n                        size + x - anchor + scroll - currentScroll,\n                        SIZES.minimumWidth * indices.length\n                    );\n                    onInvalidateColumn?.(indices[0] - 1);\n                    onCellWidthChange(\n                        indices,\n                        indices.map((_) => newWidth / indices.length)\n                    );\n                }\n                return;\n            }\n\n            if (rowResize) {\n                if (onCellHeightChange) {\n                    const { size, anchor, scroll, indices } = rowResize;\n                    const [, currentScroll] = getScrollPosition(e);\n                    const newHeight = Math.max(\n                        size + y - anchor + scroll - currentScroll,\n                        SIZES.minimumHeight * indices.length\n                    );\n                    onInvalidateRow?.(indices[0] - 1);\n                    onCellHeightChange(\n                        indices,\n                        indices.map((_) => newHeight / indices.length)\n                    );\n                }\n                return;\n            }\n\n            if (draggingSelection) {\n                const [anchor] = selection;\n                const head = pixelToCell(xy);\n\n                const [anchorX, anchorY] = anchor;\n                const [headX, headY] = head;\n\n                if (draggingRowSelection) {\n                    onSelectionChange?.(\n                        [\n                            [-1, anchorY],\n                            [-1, Math.max(0, headY)],\n                        ],\n                        false\n                    );\n                } else if (draggingColumnSelection) {\n                    onSelectionChange?.(\n                        [\n                            [anchorX, -1],\n                            [Math.max(0, headX), -1],\n                        ],\n                        false\n                    );\n                } else {\n                    onSelectionChange?.([maxXY(anchor, ORIGIN), maxXY(head, ORIGIN)], false);\n                }\n            }\n\n            if (draggingKnob) {\n                window.document.body.style.cursor = 'crosshair';\n\n                const [cellX, cellY] = pixelToCell(xy);\n                let [[minX, minY], [maxX, maxY]] = normalizeSelection(selection);\n\n                // check if vertical or horizontal\n                let xCellDiff = Math.min(cellX - minX, maxX - cellX, 0); // zero or less\n                let yCellDiff = Math.min(cellY - minY, maxY - cellY, 0); // zero or less\n\n                if (isMaybeRowSelection(selection) || xCellDiff > yCellDiff) {\n                    if (cellY < minY) {\n                        minY = cellY;\n                    } else if (cellY > maxY) {\n                        maxY = cellY;\n                    }\n                } else {\n                    if (cellX < minX) {\n                        minX = cellX;\n                    } else if (cellX > maxX) {\n                        maxX = cellX;\n                    }\n                }\n\n                onKnobAreaChange?.([\n                    [minX, minY],\n                    [maxX, maxY],\n                ]);\n            }\n\n            if (columnDrag || rowDrag) {\n                const [x, y] = xy;\n                if (columnDrag) {\n                    const cellX = pixelToColumn(Math.max(x, getIndentX()), 0.5);\n                    const insideSelection = cellX >= minX && cellX <= maxX + 1;\n                    const insideGroup = isBoundaryInsideGroup(cellX, columnGroupKeys);\n\n                    const { anchor, scroll } = columnDrag;\n                    const shift = x - anchor;\n                    const [currentScroll] = getScrollPosition(e);\n\n                    onDragOffsetChange?.([shift + currentScroll - scroll, 0]);\n                    onDropTargetChange?.(\n                        insideSelection || insideGroup\n                            ? null\n                            : [\n                                  [cellX, -1],\n                                  [cellX, -1],\n                              ]\n                    );\n                }\n                if (rowDrag) {\n                    const cellY = pixelToRow(Math.max(y, getIndentY()), 0.5);\n                    const insideSelection = cellY >= minY && cellY <= maxY + 1;\n                    const insideGroup = isBoundaryInsideGroup(cellY, rowGroupKeys);\n\n                    const { anchor, scroll } = rowDrag;\n                    const shift = y - anchor;\n                    const [, currentScroll] = getScrollPosition(e);\n\n                    onDragOffsetChange?.([0, shift + currentScroll - scroll]);\n                    onDropTargetChange?.(\n                        insideSelection || insideGroup\n                            ? null\n                            : [\n                                  [-1, cellY],\n                                  [-1, cellY],\n                              ]\n                    );\n                }\n            }\n        },\n        [\n            getMousePosition,\n            getScrollPosition,\n            getMouseHit,\n            onCellWidthChange,\n            onCellHeightChange,\n            onDragIndicesChange,\n            onDragOffsetChange,\n            onDropTargetChange,\n            onSelectionChange,\n            onKnobAreaChange,\n            onInvalidateRow,\n            onInvalidateColumn,\n            columnGroupKeys,\n            rowGroupKeys,\n        ]\n    );\n\n    const onDoubleClick = useCallback(\n        (e: MouseEvent) => {\n            const {\n                current: {\n                    selection,\n                    cellLayout: { pixelToCell, columnToPixel },\n                },\n            } = ref;\n\n            e.preventDefault();\n            if (e.shiftKey) return;\n\n            const xy = getMousePosition(e);\n            if (!xy) return;\n\n            // Double click column divider to autosize\n            const [x] = xy;\n            const { columns } = visibleCells;\n            if (onCellWidthChange) {\n                const autosized = [];\n\n                for (const index of columns) {\n                    const edge = columnToPixel(index, 1);\n\n                    if (Math.abs(edge - x) < SIZES.resizeZone && canSizeColumn(index)) {\n                        const [[minX], [maxX]] = normalizeSelection(selection);\n\n                        // Autosize entire selection if double-clicking a right edge\n                        const indices =\n                            isColumnSelection(selection) && index >= minX && index <= maxX\n                                ? mapSelectionColumns(selection)((i) => i)\n                                : [index];\n\n                        autosized.push(...indices);\n                    }\n                }\n\n                for (const column of autosized) {\n                    onInvalidateColumn?.(column - 1);\n                }\n                onCellWidthChange(\n                    autosized,\n                    autosized.map((column) => getAutoSizeWidth(column))\n                );\n                if (autosized.length) return;\n            }\n\n            const hitTarget = getMouseHit(xy);\n            if (hitTarget) {\n                window.document.body.style.cursor = 'pointer';\n                return;\n            }\n\n            const editCell = pixelToCell(xy);\n            if (editMode) onCommit?.();\n            onEdit?.(editCell);\n        },\n        [\n            getMousePosition,\n            getMouseHit,\n            onCommit,\n            onEdit,\n            onInvalidateColumn,\n            onCellWidthChange,\n            getAutoSizeWidth,\n            visibleCells,\n            canSizeColumn,\n        ]\n    );\n\n    const onContextMenu = useCallback(\n        (e: MouseEvent) => {\n            const {\n                current: {\n                    cellLayout: { pixelToCell, getIndentX, getIndentY },\n                },\n            } = ref;\n\n            const xy = getMousePosition(e);\n            if (!xy) return;\n\n            const [x, y] = xy;\n            if (x <= getIndentX() || y <= getIndentY()) {\n                return;\n            }\n\n            // If click is not inside of selection, select the right clicked cell\n            const cell = pixelToCell(xy);\n            if (!isPointInsideSelection(selection, cell)) {\n                onSelectionChange?.([cell, cell]);\n            }\n\n            onPointerMove(e as any);\n\n            const [cellX, cellY] = cell;\n            const event: SheetMouseEvent = {\n                ...e,\n                cellX,\n                cellY,\n            };\n            onRightClick?.(event);\n        },\n        [getMousePosition, onSelectionChange, onPointerMove, onRightClick]\n    );\n\n    const mouseHandlers = {\n        onPointerLeave,\n        onPointerDown,\n        onPointerMove,\n        onPointerUp,\n        onDoubleClick,\n        onContextMenu,\n    };\n\n    return { knobPosition, mouseHandlers };\n};\n\nconst parseKnobOperation = (\n    knobArea: Rectangle,\n    selection: Rectangle,\n    sourceData: CellPropertyFunction<string | number | null>,\n    editData: CellPropertyFunction<string>,\n    cellReadOnly: CellPropertyFunction<boolean | null>\n): Change[] => {\n    const [[kx1, ky1], [kx2, ky2]] = normalizeSelection(knobArea);\n    const [[sx1, sy1], [sx2, sy2]] = normalizeSelection(selection);\n\n    let fx1 = kx1;\n    let fy1 = ky1;\n    let fx2 = kx2;\n    let fy2 = ky2;\n\n    const changes: Change[] = [];\n\n    // TODO: this should be made less cryptic, using logical selection ops/fns\n\n    if (fx2 - fx1 === sx2 - sx1) {\n        // vertical\n        if (fy1 === sy1) {\n            fy1 = sy2 + 1;\n        } else {\n            fy2 = sy1 - 1;\n        }\n        if (fx1 === -1 && fx2 === -1) {\n            const [maxX] = findApproxMaxEditDataIndex(editData);\n            fx1 = 0;\n            fx2 = maxX;\n        }\n        let srcY = sy1;\n        for (let y = fy1; y <= fy2; y++) {\n            for (let x = fx1; x <= fx2; x++) {\n                const value = sourceData(x, srcY);\n                if (!cellReadOnly(x, y)) {\n                    changes.push({ x: x, y: y, value: value, source: { x: x, y: srcY } });\n                }\n            }\n            srcY = srcY + 1;\n            if (srcY > sy2) {\n                srcY = sy1;\n            }\n        }\n    } else {\n        // horizontal\n        if (fx1 === sx1) {\n            fx1 = sx2 + 1;\n        } else {\n            fx2 = sx1 - 1;\n        }\n        if (fy1 === -1 && fy2 === -1) {\n            const [, maxY] = findApproxMaxEditDataIndex(editData);\n            fy1 = 0;\n            fy2 = maxY;\n        }\n        let srcX = sx1;\n        for (let x = fx1; x <= fx2; x++) {\n            for (let y = fy1; y <= fy2; y++) {\n                const value = sourceData(srcX, y);\n                if (!cellReadOnly(x, y)) {\n                    changes.push({ x: x, y: y, value: value, source: { x: srcX, y: y } });\n                }\n            }\n            srcX = srcX + 1;\n            if (srcX > sx2) {\n                srcX = sx1;\n            }\n        }\n    }\n\n    return changes;\n};\n","import { RefObject, KeyboardEvent, useLayoutEffect } from 'react';\n\nimport { ARROW_KEYS, MAX_SEARCHABLE_INDEX, ORIGIN, NEG_NEG } from './constants';\n\nimport { findInDisplayData } from './props';\n\nimport { CellContentType, CellPropertyFunction, CellPropertyStyledFunction, Change, Rectangle, XY } from './types';\n\nimport {\n    normalizeSelection,\n    isRowSelection,\n    isColumnSelection,\n    isEmptySelection,\n    getDirectionStep,\n    maxXY,\n    addXY,\n} from './coordinate';\n\nexport const useKeyboard = (\n    arrowKeyCommitMode: boolean,\n    overlayRef: RefObject<HTMLDivElement>,\n    cellReadOnly: CellPropertyFunction<boolean | null>,\n    displayData: CellPropertyStyledFunction<CellContentType>,\n    editCell: XY,\n    editMode: boolean,\n    focused: boolean,\n    rawSelection: Rectangle,\n    selection: Rectangle,\n\n    onEdit?: (cell: XY, arrowKeyCommitMode?: boolean) => void,\n    onCommit?: () => void,\n    onCancel?: () => void,\n    onSelectionChange?: (selection: Rectangle, scrollTo?: boolean, toHead?: boolean) => void,\n    onFocusChange?: (focus: boolean) => void,\n    onClipboardCopy?: (cut: boolean) => void,\n    onChange?: (changes: Change[]) => void\n) => {\n    const onInputKeyDown = (e: KeyboardEvent) => {\n        if (e.key === 'Escape') {\n            onCancel?.();\n            return;\n        }\n\n        const direction =\n            e.key === 'Enter' ? 'down' : e.key === 'Tab' ? 'right' : arrowKeyCommitMode ? ARROW_KEYS[e.key] : null;\n\n        if (direction) {\n            e.preventDefault();\n            const step = getDirectionStep(direction);\n            const head = maxXY(addXY(editCell, step), ORIGIN);\n            onCommit?.();\n            onSelectionChange?.([head, head]);\n        }\n    };\n\n    const onGridKeyDown = (e: KeyboardEvent) => {\n        if (editMode && arrowKeyCommitMode && e.key in ARROW_KEYS) {\n            onCommit?.();\n            return;\n        }\n\n        if ((e.metaKey || e.ctrlKey) && String.fromCharCode(e.which).toLowerCase() === 'v') {\n            return;\n        }\n\n        // copy\n        if ((e.metaKey || e.ctrlKey) && String.fromCharCode(e.which).toLowerCase() === 'c') {\n            onClipboardCopy?.(false);\n            return;\n        }\n        // cut\n        if ((e.metaKey || e.ctrlKey) && String.fromCharCode(e.which).toLowerCase() === 'x') {\n            onClipboardCopy?.(true);\n            return;\n        }\n\n        if (e.key === 'Backspace' || e.key === 'Delete') {\n            let [[x1, y1], [x2, y2]] = normalizeSelection(selection);\n            if (isRowSelection(selection)) {\n                x1 = 0;\n                x2 = MAX_SEARCHABLE_INDEX;\n            }\n            if (isColumnSelection(selection)) {\n                y1 = 0;\n                y2 = MAX_SEARCHABLE_INDEX;\n            }\n\n            const changes: Change[] = [];\n            for (let y = y1; y <= y2; y++) {\n                for (let x = x1; x <= x2; x++) {\n                    if (!cellReadOnly(x, y)) {\n                        changes.push({ x: x, y: y, value: null });\n                    }\n                }\n            }\n\n            onChange?.(changes);\n            return;\n        }\n\n        // nothing selected\n        if (isEmptySelection(selection)) {\n            return;\n        }\n\n        if (\n            (e.keyCode >= 48 && e.keyCode <= 57) ||\n            (e.keyCode >= 96 && e.keyCode <= 105) ||\n            (e.keyCode >= 65 && e.keyCode <= 90) ||\n            e.key === 'Enter' ||\n            e.key === '-' ||\n            e.key === '.' ||\n            e.key === ','\n        ) {\n            const [cell] = selection;\n            const [cellX, cellY] = cell;\n            if (cellReadOnly(cellX, cellY)) {\n                return;\n            }\n\n            onEdit?.(cell, e.key !== 'Enter');\n            return;\n        }\n\n        e.preventDefault();\n\n        if (e.key in ARROW_KEYS) {\n            let [anchor, head] = rawSelection;\n\n            const direction = ARROW_KEYS[e.key];\n            const step = getDirectionStep(direction);\n            const shift = e.shiftKey;\n\n            if (e.metaKey || e.ctrlKey) {\n                head = findInDisplayData(displayData, head, direction);\n            } else {\n                // Allow stepping into row/column headers with shift\n                const limit: XY = shift\n                    ? isRowSelection(selection)\n                        ? [-1, 0]\n                        : isColumnSelection(selection)\n                        ? [0, -1]\n                        : NEG_NEG\n                    : ORIGIN;\n                head = maxXY(addXY(head, step), limit);\n            }\n\n            if (!shift) {\n                anchor = head;\n            }\n\n            onSelectionChange?.([anchor, head], true, true);\n            return;\n        }\n    };\n\n    const onGridFocus = () => {\n        onFocusChange?.(true);\n    };\n\n    const onGridBlur = () => {\n        onFocusChange?.(false);\n    };\n\n    // Focus canvas for keyboard\n    useLayoutEffect(() => {\n        const { current: overlay } = overlayRef;\n        if (!overlay) {\n            return;\n        }\n        if (editMode || !focused) {\n            return;\n        }\n        if (document.activeElement === overlay) {\n            return;\n        }\n\n        const activeTagName = (document as any).activeElement.tagName.toLowerCase();\n        if (\n            !(\n                (activeTagName === 'div' && (document as any).activeElement.contentEditable === 'true') ||\n                activeTagName === 'input' ||\n                activeTagName === 'textarea' ||\n                activeTagName === 'select'\n            )\n        ) {\n            overlay.focus({ preventScroll: true });\n        }\n    }, [editMode, focused]);\n\n    return { onInputKeyDown, onGridFocus, onGridBlur, onGridKeyDown };\n};\n","import { UIEvent, useCallback } from 'react';\nimport { XY, CellLayout } from './types';\nimport { isSameXY, maxXY, mulXY } from './coordinate';\nimport { ONE_ONE } from './constants';\n\nexport const useScroll = (\n    offset: XY,\n    maxScroll: XY,\n    cellLayout: CellLayout,\n    onOffsetChange?: (offset: XY) => void,\n    onMaxScrollChange?: (maxScroll: XY) => void\n) => {\n    return useCallback(\n        (e: UIEvent) => {\n            if (!e.target || !(e.target instanceof Element)) {\n                return;\n            }\n            const { absoluteToCell, cellToAbsolute } = cellLayout;\n\n            // Zero scroll position is considered in the center of the top/left cell\n            const [nudgeX, nudgeY] = cellToAbsolute([0, 0], [0.5, 0.5]);\n\n            const xy: XY = [e.target.scrollLeft + nudgeX, e.target.scrollTop + nudgeY];\n\n            const cell = absoluteToCell(xy);\n            if (!isSameXY(cell, offset)) {\n                onOffsetChange?.(cell);\n            }\n\n            const [x, y] = xy;\n            const [maxScrollX, maxScrollY] = maxScroll;\n            const growX = maxScrollX < x + 1 ? 1.5 : 1;\n            const growY = maxScrollY < y + 1 ? 1.5 : 1;\n            if (growX > 1 || growY > 1) {\n                onMaxScrollChange?.(mulXY(maxScroll, [growX, growY]));\n            }\n        },\n        [cellLayout, onOffsetChange, onMaxScrollChange]\n    );\n};\n\n// If view extends past end of table\n// Limit view to table contents\nexport const clipDataOffset = (view: XY, offset: XY, freeze: XY, maxCells: XY, cellLayout: CellLayout): XY => {\n    let [newX, newY] = offset;\n    const [maxColumns, maxRows] = maxCells;\n\n    const { absoluteToColumn, columnToAbsolute, absoluteToRow, rowToAbsolute } = cellLayout;\n\n    const {\n        edge: [rightEdge, bottomEdge],\n        viewport: [scrollW, scrollH],\n    } = getViewExtent(view, [newX, newY], freeze, cellLayout);\n\n    // Move extra space on the right/bottom to equivalent on the left/top\n    if (rightEdge > maxColumns) {\n        const remainder = columnToAbsolute(maxColumns) - columnToAbsolute(newX);\n        newX = absoluteToColumn(columnToAbsolute(newX) - scrollW + remainder) + 1;\n    }\n    if (bottomEdge > maxRows) {\n        const remainder = rowToAbsolute(maxRows) - rowToAbsolute(newY);\n        newY = absoluteToRow(rowToAbsolute(newY) - scrollH + remainder) + 1;\n    }\n\n    return [newX, newY];\n};\n\n// Get bottom-right corner cell + non-frozen viewport size\nexport const getViewExtent = (\n    view: XY,\n    offset: XY,\n    freeze: XY,\n    cellLayout: CellLayout\n): {\n    edge: XY;\n    viewport: XY;\n} => {\n    const {\n        cellToAbsolute,\n        absoluteToColumn,\n        columnToAbsolute,\n        absoluteToRow,\n        rowToAbsolute,\n        getIndentX,\n        getIndentY,\n    } = cellLayout;\n\n    const [x, y] = offset;\n    const [w, h] = view;\n    const [frozenX, frozenY] = cellToAbsolute(freeze);\n\n    const scrollW = w - frozenX - getIndentX();\n    const scrollH = h - frozenY - getIndentY();\n\n    const leftEdge = x + freeze[0];\n    const topEdge = y + freeze[1];\n    const rightEdge = absoluteToColumn(columnToAbsolute(leftEdge) + scrollW);\n    const bottomEdge = absoluteToRow(rowToAbsolute(topEdge) + scrollH);\n\n    return {\n        edge: [rightEdge, bottomEdge],\n        viewport: [scrollW, scrollH],\n    };\n};\n\nexport const scrollToCell = (\n    element: HTMLDivElement,\n    cell: XY,\n    view: XY,\n    freeze: XY,\n    offset: XY,\n    maxScroll: XY,\n    cellLayout: CellLayout,\n    callback: (offset: XY, maxScroll: XY) => void\n) => {\n    const [x, y] = cell;\n    const [w, h] = view;\n    const [offsetX, offsetY] = offset;\n\n    const { cellToAbsolute, cellToPixel, columnToPixel, rowToPixel } = cellLayout;\n\n    const [frozenX, frozenY] = cellToAbsolute(freeze);\n    const [left, top] = cellToPixel(cell);\n    const [right, bottom] = cellToPixel(cell, ONE_ONE);\n\n    let [newX, newY] = offset;\n\n    // If moving left/up, scroll to head\n    if (left <= frozenX) {\n        newX = x - freeze[0];\n    }\n    if (top <= frozenY) {\n        newY = y - freeze[1];\n    }\n\n    // If moving right/down, scroll cell by cell until right/bottom of cell is visible\n    if (right > w) {\n        let edge = right - w + columnToPixel(newX);\n        while (columnToPixel(++newX) < edge) {}\n    }\n    if (bottom > h) {\n        let edge = bottom - h + rowToPixel(newY);\n        while (rowToPixel(++newY) < edge) {}\n    }\n\n    // Don't scroll on infinite axis\n    const newOffset: XY = [newX >= 0 ? newX : offsetX, newY >= 0 ? newY : offsetY];\n\n    if (!isSameXY(newOffset, offset)) {\n        const scroll = cellToAbsolute(newOffset);\n        const [nudgeX, nudgeY] = cellToAbsolute([0, 0], [0.5, 0.5]);\n\n        callback(newOffset, maxXY(maxScroll, scroll));\n        setTimeout(() => {\n            const [scrollX, scrollY] = scroll;\n            element.scrollLeft = scrollX - nudgeX;\n            element.scrollTop = scrollY - nudgeY;\n        });\n    }\n};\n","// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import React, { useState } from 'react';\nimport Sheet from 'sheet-happens';\nimport 'sheet-happens/dist/index.css';\n\nconst initialDataBig = [];\nfor (let row = 0; row < 1000; row++) {\n    const r = [];\n    for (let col = 0; col < 100; col++) {\n        r.push(`Row: ${row}, Col: ${col}`);\n    }\n    initialDataBig.push(r);\n}\n\nconst initialDataBasic = [\n    ['First', 'Second', 'Third', 'Fourth', 'Fifth', 'Sixth'],\n    [1, 2, 3, 4, 5, 6],\n    [1, 2, 3, 4, 5, 6],\n    [1, 2, 3, 4, 5, 6],\n    [1, 2, 3, 4, 5, 6],\n    [1, 2, 3, 4, 5, 6],\n    [1, 2, 3, 4, 5, 6],\n    [1, 2, 3, 4, 5, 6],\n    [1, 2, 3, 4, 5, 6],\n];\n\nconst initialDataFormatting = [];\nfor (let row = 0; row < 1000; row++) {\n    const r = [];\n    for (let col = 0; col < 100; col++) {\n        r.push(Math.random() * 1000000);\n    }\n    initialDataFormatting.push(r);\n}\n\nconst triangleDown = new Image();\ntriangleDown.src =\n    'data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgd2lkdGg9IjEwMCIgaGVpZ2h0PSIxMDAiDQoJIHZpZXdCb3g9IjAgMCAxMDAgMTAwIiBvdmVyZmxvdz0idmlzaWJsZSIgPg0KPHBvbHlnb24gcG9pbnRzPSIwLDAgMTAwLDAgNTAsMTAwIiBzdHlsZT0iZmlsbDojOTk5OTk5OyIvPg0KPC9zdmc+DQo=';\ntriangleDown.width = 10;\ntriangleDown.height = 10;\n\nexport const DEFAULT_CELL_WIDTH = 100;\nexport const DEFAULT_CELL_HEIGHT = 22;\n\nexport function useWidthHeightControl(\n    initialWidths = [],\n    initialHeights = [],\n    getColumnOrder = (i: number) => i,\n    getRowOrder = (i: number) => i\n) {\n    const [cellWidth, setCellWidth] = useState(initialWidths);\n    const [cellHeight, setCellHeight] = useState(initialHeights);\n\n    const onCellWidthChange = (indices, newWidths) => {\n        setCellWidth((cellWidth) => {\n            const cw = [...cellWidth];\n            for (const [i, order] of indices.entries()) {\n                const idx = getColumnOrder(order);\n                if (idx > cw.length) {\n                    for (let i = cw.length; i <= idx; i++) {\n                        cw.push(DEFAULT_CELL_WIDTH);\n                    }\n                }\n                cw[idx] = newWidths[i];\n            }\n            return cw;\n        });\n    };\n\n    const onCellHeightChange = (indices, newHeights) => {\n        setCellHeight((cellHeight) => {\n            const ch = [...cellHeight];\n            for (const [i, order] of indices.entries()) {\n                const idx = getRowOrder(order);\n                if (idx > ch.length) {\n                    for (let i = ch.length; i <= idx; i++) {\n                        ch.push(DEFAULT_CELL_HEIGHT);\n                    }\n                }\n                ch[idx] = newHeights[i];\n            }\n            return ch;\n        });\n    };\n\n    const cw = (x: number) => cellWidth[getColumnOrder(x)] ?? DEFAULT_CELL_WIDTH;\n    const ch = (y: number) => cellHeight[getRowOrder(y)] ?? DEFAULT_CELL_HEIGHT;\n\n    return { onCellWidthChange, onCellHeightChange, cellWidth: cw, cellHeight: ch };\n}\n\nexport function useOrderControl(initialColumns = [], initialRows = []) {\n    const [columnOrder, setColumnOrder] = useState(initialColumns);\n    const [rowOrder, setRowOrder] = useState(initialRows);\n\n    const getColumnOrder = (x: number) => columnOrder[x] ?? x;\n    const getRowOrder = (y: number) => rowOrder[y] ?? y;\n\n    const onColumnOrderChange = (indices: number[], order: number) => {\n        const co = [...columnOrder];\n\n        // Extend column order to cover operation\n        const n = Math.max(order + indices.length, order + indices.reduce((a, b) => Math.max(a, b), 0));\n        while (co.length < n) co.push(co.length);\n\n        // Remove old columns one by one (indices may be disjoint but are always increasing)\n        for (let i = 0; i < indices.length; ++i) co.splice(indices[i] - i, 1);\n\n        // Splice in new indices mapped to old order\n        co.splice(order, 0, ...indices.map((i) => columnOrder[i] ?? i));\n\n        setColumnOrder(co);\n    };\n\n    const onRowOrderChange = (indices: number[], order: number) => {\n        const ro = [...rowOrder];\n\n        // Extend row order to cover operation\n        const n = Math.max(order + indices.length, order + indices.reduce((a, b) => Math.max(a, b), 0));\n\n        while (ro.length < n) ro.push(ro.length);\n\n        // Remove old rows one by one (indices may be disjoint but are always increasing)\n        for (let i = 0; i < indices.length; ++i) ro.splice(indices[i] - i, 1);\n\n        // Splice in new indices mapped to old order\n        ro.splice(order, 0, ...indices.map((i) => rowOrder[i] ?? i));\n\n        setRowOrder(ro);\n    };\n\n    return { getColumnOrder, getRowOrder, onColumnOrderChange, onRowOrderChange };\n}\n\nexport function SheetBoxHeader() {\n    const [data, setData] = useState(initialDataBig);\n\n    const { onColumnOrderChange, onRowOrderChange, getColumnOrder, getRowOrder } = useOrderControl();\n    const { onCellWidthChange, onCellHeightChange, cellWidth, cellHeight } = useWidthHeightControl(\n        [],\n        [],\n        getColumnOrder,\n        getRowOrder\n    );\n\n    const onSelectionChanged = (x1, y1, x2, y2) => {};\n    const onRightClick = () => {};\n    const columnHeaders = ['A', 'B', 'C'];\n    const cellStyle = (x, y) => {\n        return {};\n    };\n\n    const editData = (x, y) => {\n        return data?.[getRowOrder(y)]?.[getColumnOrder(x)];\n    };\n    const displayData = (x, y) => {\n        return data?.[getRowOrder(y)]?.[getColumnOrder(x)];\n    };\n    const sourceData = (x, y) => {\n        return data?.[getRowOrder(y)]?.[getColumnOrder(x)];\n    };\n    const editKeys = (x, y) => {\n        return `${x},${y}`;\n    };\n\n    const onChange = (changes) => {\n        const newData = [...data];\n        for (const change of changes) {\n            const cx = getColumnOrder(change.x);\n            const cy = getRowOrder(change.y);\n            if (!newData[cy]) {\n                newData[cy] = [];\n            }\n            newData[cy][cx] = change.value;\n        }\n        setData(newData);\n    };\n\n    const isReadOnly = (x, y) => {\n        return false;\n    };\n\n    return (\n        <div className=\"sheet-box\">\n            <Sheet\n                onSelectionChanged={onSelectionChanged}\n                onRightClick={onRightClick}\n                columnHeaders={columnHeaders}\n                cellStyle={cellStyle}\n                editData={editData}\n                displayData={displayData}\n                sourceData={sourceData}\n                cellWidth={cellWidth}\n                cellHeight={cellHeight}\n                onChange={onChange}\n                readOnly={isReadOnly}\n                onCellWidthChange={onCellWidthChange}\n                onCellHeightChange={onCellHeightChange}\n                onColumnOrderChange={onColumnOrderChange}\n                onRowOrderChange={onRowOrderChange}\n                editKeys={editKeys}\n                autoFocus\n                cacheLayout\n            />\n        </div>\n    );\n}\n\nexport function SheetBoxBasic() {\n    const [data, setData] = useState(JSON.parse(JSON.stringify(initialDataBasic)));\n    const { onColumnOrderChange, onRowOrderChange, getColumnOrder, getRowOrder } = useOrderControl();\n    const { onCellWidthChange, onCellHeightChange, cellWidth, cellHeight } = useWidthHeightControl(\n        [],\n        [],\n        getColumnOrder,\n        getRowOrder\n    );\n\n    const onSelectionChanged = (x1, y1, x2, y2) => {};\n    const onRightClick = () => {};\n    const columnHeaders = ['A', 'B', 'C'];\n    const cellStyle = (x, y) => {\n        return {};\n    };\n\n    const editData = (x, y) => {\n        return data?.[getRowOrder(y)]?.[getColumnOrder(x)];\n    };\n    const displayData = (x, y) => {\n        return data?.[getRowOrder(y)]?.[getColumnOrder(x)];\n    };\n    const sourceData = (x, y) => {\n        return data?.[getRowOrder(y)]?.[getColumnOrder(x)];\n    };\n\n    const onChange = (changes) => {\n        const newData = [...data];\n        for (const change of changes) {\n            const cx = getColumnOrder(change.x);\n            const cy = getRowOrder(change.y);\n            if (!newData[cy]) {\n                newData[cy] = [];\n            }\n            newData[cy][cx] = change.value;\n        }\n        setData(newData);\n    };\n\n    const isReadOnly = (x, y) => {\n        return false;\n    };\n\n    return (\n        <div className=\"sheet-box\">\n            <Sheet\n                onSelectionChanged={onSelectionChanged}\n                onRightClick={onRightClick}\n                columnHeaders={columnHeaders}\n                cellStyle={cellStyle}\n                editData={editData}\n                displayData={displayData}\n                sourceData={sourceData}\n                cellWidth={cellWidth}\n                cellHeight={cellHeight}\n                onChange={onChange}\n                readOnly={isReadOnly}\n                onCellWidthChange={onCellWidthChange}\n                onCellHeightChange={onCellHeightChange}\n                onColumnOrderChange={onColumnOrderChange}\n                onRowOrderChange={onRowOrderChange}\n                cacheLayout\n            />\n        </div>\n    );\n}\n\nconst faCheck = new Image();\nfaCheck.src =\n    'data:image/svg+xml;base64,PHN2ZyBhcmlhLWhpZGRlbj0idHJ1ZSIgZm9jdXNhYmxlPSJmYWxzZSIgZGF0YS1wcmVmaXg9ImZhcyIgZGF0YS1pY29uPSJjaGVjay1jaXJjbGUiIGNsYXNzPSJzdmctaW5saW5lLS1mYSBmYS1jaGVjay1jaXJjbGUgZmEtdy0xNiIgcm9sZT0iaW1nIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1MTIgNTEyIj48cGF0aCBmaWxsPSIjMGFkNjZiIiBkPSJNNTA0IDI1NmMwIDEzNi45NjctMTExLjAzMyAyNDgtMjQ4IDI0OFM4IDM5Mi45NjcgOCAyNTYgMTE5LjAzMyA4IDI1NiA4czI0OCAxMTEuMDMzIDI0OCAyNDh6TTIyNy4zMTQgMzg3LjMxNGwxODQtMTg0YzYuMjQ4LTYuMjQ4IDYuMjQ4LTE2LjM3OSAwLTIyLjYyN2wtMjIuNjI3LTIyLjYyN2MtNi4yNDgtNi4yNDktMTYuMzc5LTYuMjQ5LTIyLjYyOCAwTDIxNiAzMDguMTE4bC03MC4wNTktNzAuMDU5Yy02LjI0OC02LjI0OC0xNi4zNzktNi4yNDgtMjIuNjI4IDBsLTIyLjYyNyAyMi42MjdjLTYuMjQ4IDYuMjQ4LTYuMjQ4IDE2LjM3OSAwIDIyLjYyN2wxMDQgMTA0YzYuMjQ5IDYuMjQ5IDE2LjM3OSA2LjI0OSAyMi42MjguMDAxeiI+PC9wYXRoPjwvc3ZnPg==';\nfaCheck.width = 16;\nfaCheck.height = 16;\n\nexport function SheetBoxStyle() {\n    const [data, setData] = useState(JSON.parse(JSON.stringify(initialDataBasic)));\n    const { onCellWidthChange, onCellHeightChange, cellWidth, cellHeight } = useWidthHeightControl();\n\n    const onSelectionChanged = (x1, y1, x2, y2) => {};\n    const onRightClick = () => {};\n    const columnHeaders = (index) => {\n        if (index === 0) {\n            return {\n                items: [\n                    {\n                        content: 'A',\n                        x: 0,\n                        y: 0,\n                        horizontalAlign: 'center',\n                    },\n                    {\n                        content: triangleDown,\n                        x: 0,\n                        y: -6,\n                        width: 12,\n                        height: 12,\n                        horizontalAlign: 'right',\n                        onClick: () => {\n                            console.log('click');\n                        },\n                    },\n                ],\n            };\n        } else {\n            return null;\n        }\n    };\n    const colors = ['#f00', '#0f0', '#00f', '#000'];\n    const alignment = ['left', 'right', 'center'];\n    const weight = ['normal', 'bold', 'lighter'];\n    const marginRight = [0, 0, 0, 0, 20];\n    const cellStyle = (x, y) => {\n        if (x === 0 || y === 0) {\n            return {\n                fillColor: '#6DA2FB22',\n                marginRight: 10,\n            };\n        }\n        return {\n            color: colors[y % 4],\n            textAlign: alignment[x % 3],\n            marginRight: marginRight[x % 5],\n            weight: weight[y % 3],\n        };\n    };\n    const editData = (x, y) => {\n        return data?.[y]?.[x];\n    };\n    const incrementCell = (x, y) => {\n        const newData = [...data];\n        if (newData[y] && newData[y][x] !== undefined) {\n            newData[y][x] += 1;\n        }\n        setData(newData);\n    };\n    const displayData = (x, y) => {\n        if (x === 0 && y > 0 && y < 9) {\n            return {\n                items: [\n                    {\n                        content: faCheck,\n                        x: 0,\n                        y: -8,\n                        width: 16,\n                        height: 16,\n                        horizontalAlign: 'right',\n                        onClick: () => {\n                            incrementCell(x, y);\n                        },\n                    },\n                    {\n                        content: data?.[y]?.[x],\n                        x: 0,\n                        y: 0,\n                        horizontalAlign: 'left',\n                    },\n                ],\n            };\n        }\n        return data?.[y]?.[x];\n    };\n    const sourceData = (x, y) => {\n        return data?.[y]?.[x];\n    };\n    const onChange = (changes) => {\n        const newData = [...data];\n        for (const change of changes) {\n            if (!newData[change.y]) {\n                newData[change.y] = [];\n            }\n            newData[change.y][change.x] = change.value;\n        }\n        setData(newData);\n    };\n\n    const isReadOnly = (x, y) => {\n        return false;\n    };\n\n    return (\n        <div className=\"sheet-box\">\n            <Sheet\n                onSelectionChanged={onSelectionChanged}\n                onRightClick={onRightClick}\n                columnHeaders={columnHeaders}\n                cellStyle={cellStyle}\n                editData={editData}\n                displayData={displayData}\n                sourceData={sourceData}\n                cellWidth={cellWidth}\n                cellHeight={cellHeight}\n                onChange={onChange}\n                readOnly={isReadOnly}\n                onCellWidthChange={onCellWidthChange}\n                onCellHeightChange={onCellHeightChange}\n                sheetStyle={{\n                    freezeColumns: 1,\n                    freezeRows: 1,\n                }}\n                cacheLayout\n            />\n        </div>\n    );\n}\n\nexport function SheetBoxFormatting() {\n    const [data, setData] = useState(initialDataFormatting);\n    const { onCellWidthChange, onCellHeightChange, cellWidth, cellHeight } = useWidthHeightControl();\n\n    const cellStyle = (x, y) => {\n        return {};\n    };\n    const editData = (x, y) => {\n        return data?.[y]?.[x];\n    };\n    const displayData = (x, y) => {\n        return data?.[y]?.[x]?.toFixed?.(2);\n    };\n    const sourceData = (x, y) => {\n        return data?.[y]?.[x];\n    };\n\n    const onChange = (changes) => {\n        const newData = [...data];\n        for (const change of changes) {\n            if (!newData[change.y]) {\n                newData[change.y] = [];\n            }\n            newData[change.y][change.x] = Number(change.value);\n        }\n        setData(newData);\n    };\n\n    const isReadOnly = (x, y) => {\n        return false;\n    };\n\n    return (\n        <div className=\"sheet-box\">\n            <Sheet\n                cellStyle={cellStyle}\n                editData={editData}\n                displayData={displayData}\n                sourceData={sourceData}\n                cellWidth={cellWidth}\n                cellHeight={cellHeight}\n                onChange={onChange}\n                readOnly={isReadOnly}\n                onCellWidthChange={onCellWidthChange}\n                onCellHeightChange={onCellHeightChange}\n                cacheLayout\n            />\n        </div>\n    );\n}\n\nexport function SheetBoxRender() {\n    const [data, setData] = useState(JSON.parse(JSON.stringify(initialDataBasic)));\n    const { onCellWidthChange, onCellHeightChange, cellWidth, cellHeight } = useWidthHeightControl();\n\n    const onSelectionChanged = (x1, y1, x2, y2) => {};\n    const onRightClick = () => {};\n    const columnHeaders = ['A', 'B', 'C'];\n    const cellStyle = (x, y) => {\n        return {};\n    };\n\n    const editData = (x, y) => {\n        return data?.[y]?.[x];\n    };\n    const displayData = (x, y) => {\n        return data?.[y]?.[x];\n    };\n    const sourceData = (x, y) => {\n        return data?.[y]?.[x];\n    };\n\n    const onChange = (changes) => {\n        const newData = [...data];\n        for (const { x, y, value } of changes) {\n            if (!newData[y]) {\n                newData[y] = [];\n            }\n            newData[y][x] = value;\n        }\n        setData(newData);\n    };\n\n    const isReadOnly = (x, y) => {\n        return false;\n    };\n\n    const render = ({ visibleCells, cellLayout, selection, editMode }) => {\n        if (editMode) return;\n\n        const cell = [1, 2];\n        const [anchor] = selection;\n        const noteOpen = anchor[0] === cell[0] && anchor[1] === cell[1];\n\n        const isCellVisible = visibleCells.columns.includes(cell[0]) && visibleCells.rows.includes(cell[1]);\n        if (!isCellVisible) return null;\n\n        const [, top] = cellLayout.cellToPixel(cell, [0, 0]);\n        const [right] = cellLayout.cellToPixel(cell, [1, 1]);\n\n        const marker = (\n            <div\n                style={{\n                    position: 'absolute',\n                    left: right,\n                    top: top,\n                    marginLeft: '-12px',\n                    borderTop: '12px solid blue',\n                    borderLeft: '12px solid transparent',\n                    pointerEvents: 'none',\n                }}\n            />\n        );\n\n        const note = noteOpen ? (\n            <div\n                style={{\n                    position: 'absolute',\n                    left: right,\n                    top,\n                    padding: 10,\n                    background: '#fff',\n                    border: '1px solid #ccc',\n                }}\n            >\n                Hello world\n            </div>\n        ) : null;\n\n        return (\n            <div onPointerDown={(e: any) => e.stopPropagation()}>\n                {note}\n                {marker}\n            </div>\n        );\n    };\n\n    return (\n        <div className=\"sheet-box\">\n            <Sheet\n                selection={[\n                    [1, 2],\n                    [1, 2],\n                ]}\n                onSelectionChanged={onSelectionChanged}\n                onRightClick={onRightClick}\n                columnHeaders={columnHeaders}\n                cellStyle={cellStyle}\n                editData={editData}\n                displayData={displayData}\n                sourceData={sourceData}\n                cellWidth={cellWidth}\n                cellHeight={cellHeight}\n                onChange={onChange}\n                readOnly={isReadOnly}\n                onCellWidthChange={onCellWidthChange}\n                onCellHeightChange={onCellHeightChange}\n                renderInside={render}\n                cacheLayout\n            />\n        </div>\n    );\n}\n\nexport function SheetBoxGrouped() {\n    const [data, setData] = useState(initialDataBig);\n\n    const { onColumnOrderChange, onRowOrderChange, getColumnOrder, getRowOrder } = useOrderControl();\n    const { onCellWidthChange, onCellHeightChange, cellWidth, cellHeight } = useWidthHeightControl(\n        [],\n        [],\n        getColumnOrder,\n        getRowOrder\n    );\n\n    const groupKeys = [1, 1, 1, 2, 2, 2, 3, 3, 4, 4, 5, 6, 6, 7, 8, 8];\n    const orderedGroupKeys = groupKeys.map((_, i) => groupKeys[getRowOrder(i)]);\n\n    const alternatingGroups = orderedGroupKeys\n        .map((key, i) => key !== orderedGroupKeys[i - 1])\n        .reduce((list, start) => {\n            const last = list.at(-1) ?? 1;\n            const bit = start ? 1 - last : last;\n            list.push(bit);\n            return list;\n        }, []);\n\n    const onSelectionChanged = (x1, y1, x2, y2) => {};\n    const onRightClick = () => {};\n    const columnHeaders = ['A', 'B', 'C'];\n    const cellStyle = (x, y) => {\n        return {\n            fillColor: ['#ffffff', '#e0e0e0'][alternatingGroups[y]],\n        };\n    };\n\n    const rowGroupKeys = (y) => {\n        return orderedGroupKeys[y];\n    };\n\n    const editData = (x, y) => {\n        return data?.[getRowOrder(y)]?.[getColumnOrder(x)];\n    };\n    const displayData = (x, y) => {\n        return data?.[getRowOrder(y)]?.[getColumnOrder(x)];\n    };\n    const sourceData = (x, y) => {\n        return data?.[getRowOrder(y)]?.[getColumnOrder(x)];\n    };\n    const editKeys = (x, y) => {\n        return `${x},${y}`;\n    };\n\n    const onChange = (changes) => {\n        const newData = [...data];\n        for (const change of changes) {\n            const cx = getColumnOrder(change.x);\n            const cy = getRowOrder(change.y);\n            if (!newData[cy]) {\n                newData[cy] = [];\n            }\n            newData[cy][cx] = change.value;\n        }\n        setData(newData);\n    };\n\n    const isReadOnly = (x, y) => {\n        return false;\n    };\n\n    return (\n        <div className=\"sheet-box\">\n            <Sheet\n                onSelectionChanged={onSelectionChanged}\n                onRightClick={onRightClick}\n                columnHeaders={columnHeaders}\n                cellStyle={cellStyle}\n                editData={editData}\n                displayData={displayData}\n                sourceData={sourceData}\n                cellWidth={cellWidth}\n                cellHeight={cellHeight}\n                onChange={onChange}\n                readOnly={isReadOnly}\n                onCellWidthChange={onCellWidthChange}\n                onCellHeightChange={onCellHeightChange}\n                onColumnOrderChange={onColumnOrderChange}\n                onRowOrderChange={onRowOrderChange}\n                rowGroupKeys={rowGroupKeys}\n                editKeys={editKeys}\n                cacheLayout\n            />\n        </div>\n    );\n}\n\nexport function SheetBoxVeryBigData() {\n    const [loadingStatus, setLoadingStatus] = useState('initial');\n    const [data, setData] = useState([]);\n    const { onCellWidthChange, onCellHeightChange, cellWidth, cellHeight } = useWidthHeightControl();\n\n    const loadClick = (e) => {\n        e.preventDefault();\n        setLoadingStatus('loading');\n        fetch('./out.json')\n            .then((response) => {\n                return response.json();\n            })\n            .then((dataset) => {\n                setData(dataset);\n                setLoadingStatus('done');\n            });\n    };\n\n    const cellStyle = (x, y) => {\n        if (y === 0) {\n            return {\n                weight: 'bold',\n                fontSize: 14,\n            };\n        }\n        if (x === 4) {\n            return {\n                textAlign: 'right',\n            };\n        } else if (x === 1) {\n            return {\n                weight: 'bold',\n                color: '#3b85ff',\n            };\n        } else if (x === 2) {\n            return {\n                color: '#fc3bff',\n            };\n        }\n        return {};\n    };\n    const editData = (x, y) => {\n        return data?.[y]?.[x];\n    };\n    const displayData = (x, y) => {\n        if (x === 4 && y > 0) {\n            if (data && data[y] && data[y][x]) {\n                return Number(data[y][x]).toFixed(2);\n            } else {\n                return '';\n            }\n        }\n        return data?.[y]?.[x];\n    };\n    const sourceData = (x, y) => {\n        return data?.[y]?.[x];\n    };\n\n    const onChange = (changes) => {\n        const newData = [...data];\n        for (const change of changes) {\n            if (!newData[change.y]) {\n                newData[change.y] = [];\n            }\n            newData[change.y][change.x] = change.value;\n        }\n        setData(newData);\n    };\n\n    const isReadOnly = (x, y) => {\n        return false;\n    };\n\n    const headerStyle = (index) => {\n        const r = ((index * 2421) % 255).toString(16).padStart(2, '0');\n        const g = ((index * 3215) % 255).toString(16).padStart(2, '0');\n        const b = ((index * 1243) % 255).toString(16).padStart(2, '0');\n        const color = `#${r}${g}${b}55`;\n        return {\n            backgroundColor: color,\n        };\n    };\n\n    const columnHeaders = (index) => {\n        return '' + index;\n    };\n\n    return (\n        <>\n            {loadingStatus === 'initial' ? (\n                // eslint-disable-next-line jsx-a11y/anchor-is-valid\n                <a href=\"#\" onClick={loadClick}>\n                    Load global database of power plants\n                </a>\n            ) : loadingStatus === 'loading' ? (\n                'Loading...'\n            ) : null}\n            <div className=\"sheet-box\">\n                <Sheet\n                    cellStyle={cellStyle}\n                    editData={editData}\n                    displayData={displayData}\n                    sourceData={sourceData}\n                    cellWidth={cellWidth}\n                    cellHeight={cellHeight}\n                    onChange={onChange}\n                    readOnly={isReadOnly}\n                    onCellWidthChange={onCellWidthChange}\n                    onCellHeightChange={onCellHeightChange}\n                    columnHeaderStyle={headerStyle}\n                    columnHeaders={columnHeaders}\n                    sheetStyle={{\n                        freezeColumns: 0,\n                        freezeRows: 1,\n                    }}\n                    cacheLayout\n                />\n            </div>\n        </>\n    );\n}\n\nconst customInputOptions = ['First', 'Second', 'Third', 'Fourth', 'Fifth'];\nconst customInputOptions2 = ['Sixth', 'Seventh', 'Eighth', 'Ninth', 'Tenth'];\nconst customInputData = [\n    customInputOptions,\n    customInputOptions2,\n    customInputOptions,\n    customInputOptions2,\n    customInputOptions,\n    customInputOptions2,\n    customInputOptions,\n];\n\nexport function SheetBoxCustomInput() {\n    const [data, setData] = useState(JSON.parse(JSON.stringify(customInputData)));\n    const { onCellWidthChange, onCellHeightChange, cellWidth, cellHeight } = useWidthHeightControl();\n\n    const onSelectionChanged = (x1, y1, x2, y2) => {};\n    const onRightClick = () => {};\n    const columnHeaders = ['A', 'B', 'C'];\n    const cellStyle = (x, y) => {\n        return {};\n    };\n    const editData = (x, y) => {\n        return data?.[y]?.[x];\n    };\n    const displayData = (x, y) => {\n        return data?.[y]?.[x];\n    };\n    const sourceData = (x, y) => {\n        return data?.[y]?.[x];\n    };\n\n    const onChange = (changes) => {\n        const newData = [...data];\n        for (const change of changes) {\n            if (!newData[change.y]) {\n                newData[change.y] = [];\n            }\n            newData[change.y][change.x] = change.value;\n        }\n        setData(newData);\n    };\n\n    const isReadOnly = (x, y) => {\n        return false;\n    };\n\n    return (\n        <div className=\"sheet-box\">\n            <Sheet\n                onSelectionChanged={onSelectionChanged}\n                onRightClick={onRightClick}\n                columnHeaders={columnHeaders}\n                cellStyle={cellStyle}\n                editData={editData}\n                displayData={displayData}\n                sourceData={sourceData}\n                cellWidth={cellWidth}\n                cellHeight={cellHeight}\n                onChange={onChange}\n                readOnly={isReadOnly}\n                onCellWidthChange={onCellWidthChange}\n                onCellHeightChange={onCellHeightChange}\n                inputComponent={CustomInput}\n                cacheLayout\n            />\n        </div>\n    );\n}\n\nfunction CustomInput(x, y, inputProps, commitEditingCell) {\n    const clickHandler = (value) => {\n        commitEditingCell(value);\n    };\n\n    return (\n        <div style={{ ...inputProps.style, backgroundColor: '#fff' }}>\n            <div style={{ border: '1px solid #ddd', boxShadow: '3px 5px 5px #ddd' }}>\n                {(y % 2 ? customInputOptions2 : customInputOptions).map((opt) => {\n                    return (\n                        <CustomOption\n                            key={opt}\n                            opt={opt}\n                            value={inputProps.value}\n                            clickHandler={() => clickHandler(opt)}\n                        />\n                    );\n                })}\n            </div>\n        </div>\n    );\n}\n\nfunction CustomOption({ opt, value, clickHandler }) {\n    const [hover, setHover] = useState(false);\n\n    return (\n        <div\n            onMouseEnter={() => {\n                setHover(true);\n            }}\n            onMouseLeave={() => {\n                setHover(false);\n            }}\n            style={{\n                backgroundColor: value === opt || hover ? '#f6f6f6' : '#fff',\n                padding: '5px 10px',\n                cursor: 'pointer',\n            }}\n            value={opt}\n            onClick={() => clickHandler(opt)}\n        >\n            {opt}\n        </div>\n    );\n}\n\nexport function SheetBoxSourceDisplayData() {\n    const [data] = useState([\n        [1, 2, 3],\n        [10, 20, 30],\n    ]);\n\n    const displayData = (x, y) => {\n        return data?.[y]?.[x]?.toFixed?.(2);\n    };\n\n    return (\n        <div className=\"sheet-box\">\n            <Sheet\n                sourceData={data} // array of arrays of data\n                displayData={displayData}\n            />\n        </div>\n    );\n}\n","import { ClipboardPayload, CellPropertyFunction, Change, Rectangle } from './types';\nimport { useCallback, useLayoutEffect, useMemo, useState } from 'react';\nimport { findApproxMaxEditDataIndex } from './props';\nimport {\n    normalizeSelection,\n    isMaybeRowSelection,\n    isMaybeColumnSelection,\n    isEmptySelection,\n    addXY,\n    forSelectionRows,\n    forSelectionColumns,\n} from './coordinate';\n\n// Type missing from TS <=4.3\ninterface ClipboardItem {\n    readonly types: string[];\n    readonly presentationStyle: 'unspecified' | 'inline' | 'attachment';\n    getType(): Promise<Blob>;\n}\n\ndeclare var ClipboardItem: {\n    prototype: ClipboardItem;\n    new (itemData: any): ClipboardItem;\n};\n\nexport type ClipboardTable<T = any> = {\n    rows: string[][];\n    payload?: ClipboardPayload<T>;\n};\n\nconst EMPTY_TABLE: ClipboardTable = { rows: [] };\n\n// Access clipboard as HTML table + JSON payload.\n// Provide peek access to clipboard if permission granted.\n// Ask permission on first copy.\nexport const useClipboardTable = () => {\n    const [peek, setPeek] = useState<ClipboardTable | null>();\n\n    useLayoutEffect(() => {\n        const softRefresh = async () => {\n            try {\n                const status = await navigator.permissions.query({ name: 'clipboard-read' as any });\n                if (status.state !== 'granted') return;\n\n                hardRefresh();\n            } catch (e) {}\n        };\n\n        const hardRefresh = async () => {\n            try {\n                const items = await (navigator.clipboard as any).read();\n                const [item] = items;\n                if (item) {\n                    const peek = await parseClipboardTable(item);\n                    setPeek(peek);\n                } else {\n                    setPeek(EMPTY_TABLE);\n                }\n            } catch (e) {}\n        };\n\n        const delayedRefresh = () => setTimeout(hardRefresh);\n\n        window.document.addEventListener('cut', delayedRefresh);\n        window.document.addEventListener('copy', delayedRefresh);\n        window.document.addEventListener('focus', softRefresh);\n\n        softRefresh();\n\n        return () => {\n            window.document.removeEventListener('cut', delayedRefresh);\n            window.document.removeEventListener('copy', delayedRefresh);\n            window.document.removeEventListener('focus', softRefresh);\n        };\n    }, []);\n\n    const canPaste = useCallback(\n        // Peek may not be available, allow paste attempt.\n        () => !!(peek == null || peek.rows?.length),\n        [peek]\n    );\n\n    return {\n        peek,\n        canPaste,\n        copyTable: copyClipboardTable,\n        pasteTable: pasteClipboardTable,\n    };\n};\n\n// Sheet clipboard with payload-handler injected\nexport const useClipboardAPI = <T = any>(\n    selection: Rectangle,\n    editData: CellPropertyFunction<string>,\n    cellReadOnly: CellPropertyFunction<boolean>,\n    addListener: boolean,\n\n    onSelectionChange?: (selection: Rectangle) => void,\n    onChange?: (changes: Change[]) => void,\n    onCopy?: (selection: Rectangle, rows: string[][], cut: boolean) => ClipboardPayload<T> | null | undefined,\n    onPaste?: (\n        selection: Rectangle,\n        rows: string[][],\n        payload?: ClipboardPayload<T>\n    ) => boolean | null | undefined | Promise<boolean | null | undefined>\n) => {\n    const { canPaste, copyTable, pasteTable } = useClipboardTable();\n\n    const pasteIntoSelection = useCallback(\n        async (selection: Rectangle, table: ClipboardTable) => {\n            const { rows, payload } = table;\n            const [min] = normalizeSelection(selection);\n            const [minX, minY] = min;\n\n            const left = Math.max(0, minX);\n            const top = Math.max(0, minY);\n\n            const width = rows.reduce((a, b) => Math.max(a, b.length), 0);\n            const height = rows.length;\n\n            const newSelection: Rectangle = [min, addXY(min, [width - 1, height - 1])];\n\n            const shouldPaste = await onPaste?.(newSelection, rows, payload);\n            if (shouldPaste !== false) {\n                const changes = rows\n                    .flatMap((row, j) =>\n                        row.map((value, i) => {\n                            const x = left + i;\n                            const y = top + j;\n                            return !cellReadOnly?.(x, y) ? { x, y, value } : null;\n                        })\n                    )\n                    .filter((change) => !!change) as Change[];\n\n                onChange?.(changes);\n                onSelectionChange?.(newSelection);\n            }\n        },\n        [onChange, onSelectionChange, cellReadOnly]\n    );\n\n    // Imperative API\n    const copySelection = useCallback(\n        async (selection: Rectangle, cut: boolean = false) => {\n            const rows = formatSelectionAsRows(selection, editData);\n            const payload = onCopy?.(selection, rows, cut);\n\n            copyTable(rows, payload);\n\n            if (payload?.cut ?? cut) {\n                const changes: Change[] = [];\n                forSelectionRows(selection)((y: number) => {\n                    forSelectionColumns(selection)((x: number) => {\n                        if (!cellReadOnly?.(x, y)) {\n                            const change = { x, y, value: '' };\n                            changes.push(change);\n                        }\n                    });\n                });\n                onChange?.(changes);\n            }\n        },\n        [onCopy, onChange, cellReadOnly]\n    );\n\n    const pasteSelection = useCallback(\n        async (selection: Rectangle) => {\n            const table = await pasteTable();\n            if (table) pasteIntoSelection(selection, table);\n        },\n        [pasteIntoSelection]\n    );\n\n    // Event handlers\n    const onClipboardCopy = (cut: boolean) => {\n        if (isEmptySelection(selection)) return;\n        return copySelection(selection, cut);\n    };\n\n    const onClipboardPaste = async (e: any) => {\n        e.preventDefault();\n\n        const clipboardData = e.clipboardData || (window as any).clipboardData;\n        const table = await parseClipboardTable(clipboardData);\n        if (table) pasteIntoSelection(selection, table);\n    };\n\n    useLayoutEffect(() => {\n        if (!addListener) return;\n\n        // Use onpaste event when we can because it has more browser support\n        window.document.addEventListener('paste', onClipboardPaste);\n        return () => {\n            window.document.removeEventListener('paste', onClipboardPaste);\n        };\n    });\n\n    const clipboardApi = useMemo(\n        () => ({\n            copySelection,\n            pasteSelection,\n            canPasteSelection: canPaste,\n        }),\n        [copySelection, pasteSelection, canPaste]\n    );\n\n    return { clipboardApi, onClipboardCopy, onClipboardPaste };\n};\n\nconst copyClipboardTable = async (rows: string[][], payload?: ClipboardPayload<any> | null) => {\n    const text = formatRowsAsTSV(rows);\n    const html = formatRowsAsHTML(rows, payload ?? undefined);\n\n    await (navigator.clipboard as any).write([\n        new ClipboardItem({\n            'text/html': new Blob([html], { type: 'text/html' }),\n            'text/plain': new Blob([text], { type: 'text/plain' }),\n        }),\n    ]);\n\n    const event = new Event('copy');\n    document.dispatchEvent(event);\n};\n\nconst pasteClipboardTable = async () => {\n    const items = await (navigator.clipboard as any).read();\n    const [item] = items;\n    if (!item) return;\n\n    return parseClipboardTable(item);\n};\n\nconst parseClipboardTable = async (item: ClipboardItem | DataTransfer): Promise<ClipboardTable | null> => {\n    // Work with both clipboard API (ClipboardItem) and onpaste event (DataTransfer)\n    const has = (type: string) => {\n        return item.types.includes(type);\n    };\n\n    const get = (type: string) => {\n        if ('getData' in item) return item.getData(type);\n        else if ('getType' in item) return (item as any).getType(type).then((blob: Blob) => blob.text());\n        return '';\n    };\n\n    let rows, payload;\n    if (has('text/html')) {\n        const pastedHtml = await get('text/html');\n        ({ rows, payload } = parsePastedHtml(pastedHtml));\n    } else if (has('text/plain')) {\n        const text = await get('text/plain');\n        rows = parsePastedText(text);\n    }\n    if (!rows) return { rows: [] };\n\n    return { rows, payload };\n};\n\nconst formatRowsAsTSV = (rows: string[][]) => rows.map((row) => row.join('\\t')).join('\\n');\n\nconst formatRowsAsHTML = (rows: string[][], payload?: ClipboardPayload<any>) => {\n    const trs = rows\n        .map((row) => {\n            const tds = row.map(formatTextAsHTML).map((cell) => `<td>${cell}</td>`);\n            return tds.join('');\n        })\n        .map((row) => `<tr>${row}</tr>`)\n        .join('\\n');\n\n    const table = `<table>${trs}</table>`;\n\n    if (payload) {\n        const extra = `<SheetHappens payload=\"${formatTextAsHTML(JSON.stringify(payload))}\"></SheetHappens>`;\n        return extra + table;\n    }\n\n    return table;\n};\n\nconst formatTextAsHTML = (s: string) => s.replace(/[&\"'<>]/g, (i) => `&#${i.charCodeAt(0)};`);\n\nconst formatSelectionAsRows = (selection: Rectangle, editData: CellPropertyFunction<string>) => {\n    if (isEmptySelection(selection)) return [];\n\n    let [[minX, minY], [maxX, maxY]] = normalizeSelection(selection);\n    if (isMaybeRowSelection(selection)) {\n        const [cellX] = findApproxMaxEditDataIndex(editData);\n        minX = 0;\n        maxX = cellX;\n    }\n    if (isMaybeColumnSelection(selection)) {\n        const [, cellY] = findApproxMaxEditDataIndex(editData);\n        minY = 0;\n        maxY = cellY;\n    }\n\n    const rows: string[][] = [];\n\n    for (let y = minY; y <= maxY; y++) {\n        const row: string[] = [];\n\n        for (let x = minX; x <= maxX; x++) {\n            const value = editData(x, y);\n            if (value !== null && value !== undefined) {\n                row.push(value != null ? value : '');\n            }\n        }\n\n        rows.push(row);\n    }\n\n    return rows;\n};\n\nconst findTag = (element: any, tagName: string): any => {\n    for (const child of element.children) {\n        if (child.nodeName === tagName) {\n            return child;\n        }\n        const maybeTag = findTag(child, tagName);\n        if (maybeTag) {\n            return maybeTag;\n        }\n    }\n};\n\nconst parsePastedHtml = (\n    html: string\n): {\n    rows: string[][];\n    payload: any;\n} => {\n    const div = document.createElement('div');\n    div.innerHTML = html.trim();\n\n    const rows = [];\n    let payload: any = undefined;\n\n    const sheetNode = findTag(div, 'SHEETHAPPENS');\n    if (sheetNode) {\n        const json = sheetNode.getAttribute('payload');\n        try {\n            payload = JSON.parse(json);\n        } catch (e) {}\n    }\n\n    const tableNode = findTag(div, 'TABLE');\n    if (tableNode) {\n        for (const tableChild of tableNode.children) {\n            if (tableChild.nodeName === 'TBODY') {\n                for (const tr of tableChild.children) {\n                    if (tr.nodeName === 'TR') {\n                        const row = [];\n                        for (const td of tr.children) {\n                            if (td.nodeName === 'TD') {\n                                let str: string = '';\n                                if (td.children.length !== 0 && td.children[0].nodeName === 'P') {\n                                    const p = td.children[0];\n                                    if (p.children.length !== 0 && p.children[0].nodeName === 'FONT') {\n                                        str = p.children[0].textContent.trim();\n                                    } else {\n                                        str = p.textContent.trim();\n                                    }\n                                } else {\n                                    str = td.textContent.trim();\n                                }\n                                str = str.replaceAll('\\n', '');\n                                str = str.replaceAll(/\\s\\s+/g, ' ');\n\n                                row.push(str);\n                            }\n                        }\n                        rows.push(row);\n                    }\n                }\n            }\n        }\n    }\n\n    return {\n        rows,\n        payload,\n    };\n};\n\nconst parsePastedText = (text: string): string[][] => {\n    return text.split(/\\r?\\n/).map((line) => line.split('\\t'));\n};\n","import { XY, CellLayout, VisibleLayout, LayoutCache } from './types';\nimport { seq } from './util';\nimport { ORIGIN } from './constants';\n\nconst INITIAL_SIZE = 256;\n\n// Local cell layout (virtualized with frozen columns/rows)\n//\n// - converts cell indices to (x, y) canvas pixels for any cell, including off-screen\n// - maps (x, y) canvas pixels back to cell index for any visible cell\n// - can also generate absolute, unscrolled offsets relative to (0,0) to drive scrolling\n// - generates list of visible cols/rows in view\n//\n// Note that adjacent column indices are not necessarily adjacent, i.e. end of [i] != start of [i + 1].\nexport const makeCellLayout = (\n    freeze: XY,\n    indent: XY,\n    offset: XY,\n\n    columns: LayoutCache,\n    rows: LayoutCache\n): CellLayout => {\n    const [freezeX, freezeY] = freeze;\n    const [indentX, indentY] = indent;\n    const [offsetX, offsetY] = offset;\n\n    const getIndentX = () => indentX;\n    const getIndentY = () => indentY;\n\n    // Origin for cell, frozen or relative\n    const getBaseOriginFor = (index: number, freeze: number, offset: number) => {\n        return index < freeze ? 0 : offset + freeze;\n    };\n\n    // Get visible pixel x of cell\n    const columnToPixel = (column: number, anchor: number = 0): number => {\n        const base = getBaseOriginFor(column, freezeX, offsetX);\n        const relative = columns.getStart(column) - columns.getStart(base);\n        const adjust = column < freezeX ? 0 : columns.getStart(freezeX) - columns.getStart(0);\n        const size = column < 0 ? indentX : columns.getSize(column);\n\n        return column < 0 ? 0 : indentX + relative + adjust + anchor * size;\n    };\n\n    // Get visible pixel y of cell\n    const rowToPixel = (row: number, anchor: number = 0): number => {\n        const base = getBaseOriginFor(row, freezeY, offsetY);\n        const relative = rows.getStart(row) - rows.getStart(base);\n        const adjust = row < freezeY ? 0 : rows.getStart(freezeY) - rows.getStart(0);\n        const size = row < 0 ? indentY : rows.getSize(row);\n\n        return row < 0 ? 0 : indentY + relative + adjust + anchor * size;\n    };\n\n    // Get visible pixel position of cell, offset with anchor [0..1, 0..1]\n    const cellToPixel = (cell: XY, anchor: XY = ORIGIN): XY => {\n        const [cellX, cellY] = cell;\n        const [anchorX, anchorY] = anchor;\n        return [columnToPixel(cellX, anchorX), rowToPixel(cellY, anchorY)];\n    };\n\n    // Get absolute / unscrolled pixel x of cell\n    const columnToAbsolute = (column: number, anchorX: number = 0): number => {\n        const relative = columns.getStart(column);\n        const size = column < 0 ? 0 : columns.getSize(column);\n\n        return relative + anchorX * size;\n    };\n\n    // Get absolute / unscrolled pixel y of cell\n    const rowToAbsolute = (row: number, anchorY: number = 0): number => {\n        const relative = rows.getStart(row);\n        const size = row < 0 ? 0 : rows.getSize(row);\n\n        return relative + anchorY * size;\n    };\n\n    // Get absolute / unscrolled pixel position of cell, offset with anchor [0..1, 0..1]\n    const cellToAbsolute = (cell: XY, anchor: XY = ORIGIN): XY => {\n        const [cellX, cellY] = cell;\n        const [anchorX, anchorY] = anchor;\n        return [columnToAbsolute(cellX, anchorX), rowToAbsolute(cellY, anchorY)];\n    };\n\n    // Lookup pixel X or Y in cell layout\n    const pixelToIndex = (\n        pixel: number,\n        anchor: number,\n        indent: number,\n        freeze: number,\n        offset: number,\n        layout: LayoutCache\n    ) => {\n        const relative = pixel - indent;\n        if (relative < 0) return -1;\n\n        const { getStart, lookupIndex } = layout;\n        const frozen = getStart(freeze);\n        if (relative < frozen) {\n            return lookupIndex(relative, anchor);\n        } else {\n            const base = getStart(offset + freeze);\n            const adjust = getStart(freeze) - getStart(0);\n            return lookupIndex(base + relative - adjust, anchor);\n        }\n    };\n\n    // Lookup pixel X or Y in cell layout (helpers)\n    const pixelToColumn = (pixelX: number, anchorX: number = 0) =>\n        pixelToIndex(pixelX, anchorX, indentX, freezeX, offsetX, columns);\n    const pixelToRow = (pixelY: number, anchorY: number = 0) =>\n        pixelToIndex(pixelY, anchorY, indentY, freezeY, offsetY, rows);\n\n    // Lookup pixel XY in cell layout\n    const pixelToCell = (pixel: XY, anchor: XY = ORIGIN): XY => {\n        const [pixelX, pixelY] = pixel;\n        const [anchorX, anchorY] = anchor;\n        return [pixelToColumn(pixelX, anchorX), pixelToRow(pixelY, anchorY)];\n    };\n\n    // Lookup absolute / unscrolled pixel X or Y in cell layout\n    const absoluteToIndex = (pixel: number, anchor: number, layout: LayoutCache) => {\n        if (pixel < 0) return -1;\n\n        const { lookupIndex } = layout;\n        return lookupIndex(pixel, anchor);\n    };\n\n    // Lookup absolute / unscrolled X or Y in cell layout (helpers)\n    const absoluteToColumn = (pixelX: number, anchorX: number = 0) => absoluteToIndex(pixelX, anchorX, columns);\n    const absoluteToRow = (pixelY: number, anchorY: number = 0) => absoluteToIndex(pixelY, anchorY, rows);\n\n    // Lookup absolute / unscrolled XY in cell layout\n    const absoluteToCell = (pixel: XY, anchor: XY = ORIGIN): XY => {\n        const [pixelX, pixelY] = pixel;\n        const [anchorX, anchorY] = anchor;\n        return [absoluteToColumn(pixelX, anchorX), absoluteToRow(pixelY, anchorY)];\n    };\n\n    // Get visible range of columns or rows\n    const getVisibleIndices = (view: number, indent: number, freeze: number, offset: number, layout: LayoutCache) => {\n        const indices = [...seq(freeze)];\n\n        const { getStart, getEnd } = layout;\n\n        const frozen = getEnd(freeze - 1);\n        const notFrozen = getStart(offset + freeze);\n\n        const relative = view - indent - frozen;\n        for (let i = offset + freeze; getStart(i) - notFrozen <= relative; ++i) {\n            indices.push(i);\n        }\n\n        return indices;\n    };\n\n    // Get visible range for an XY viewport\n    const getVisibleCells = (view: XY): VisibleLayout => {\n        const [viewX, viewY] = view;\n        return {\n            columns: getVisibleIndices(viewX, indentX, freezeX, offsetX, columns),\n            rows: getVisibleIndices(viewY, indentY, freezeY, offsetY, rows),\n        };\n    };\n\n    const getVersion = () => columns.getVersion() + rows.getVersion();\n\n    return {\n        columnToPixel,\n        rowToPixel,\n        cellToPixel,\n\n        columnToAbsolute,\n        rowToAbsolute,\n        cellToAbsolute,\n\n        pixelToColumn,\n        pixelToRow,\n        pixelToCell,\n\n        absoluteToColumn,\n        absoluteToRow,\n        absoluteToCell,\n\n        getVisibleCells,\n        getIndentX,\n        getIndentY,\n\n        getVersion,\n    };\n};\n\n// Offset cache in 1 dimension.\n//\n// Allows O(1) queries of distance between any two points, once warmed up.\n// Can do reverse lookup back to index with binary search, once warmed up.\n//\n// - caches sizer(i), each is only called once\n// - offset[0] = 0\n// - adds up offset[i] = sizer(0) + sizer(1) + ... + sizer(i - 1)\n// - cache can be truncated during resizing ops at split\n// - to replace sizer function, cache must be destroyed\nexport const makeLayoutCache = (sizer: (index: number) => number): LayoutCache => {\n    const offsets = makeIntMap(INITIAL_SIZE);\n    const sizes = makeIntMap(INITIAL_SIZE);\n\n    let version = 0;\n    offsets.set(0, 0);\n\n    // Cache size lookup directly\n    const getSize = (i: number): number => {\n        if (i < 0) return 0;\n        if (sizes.has(i)) return sizes.get(i)!;\n\n        const size = sizer(i) || 0;\n        sizes.set(i, size);\n        return size;\n    };\n\n    // Cache offset sum recursively\n    const getOffset = (i: number): number => {\n        if (i < 0) return 0;\n        if (offsets.has(i)) return offsets.get(i)!;\n\n        let j = offsets.tail() || 0;\n\n        // Use a while loop to avoid stack overflow\n        while (j < i) {\n            const size = getSize(j);\n            const offset = (offsets.get(j) || 0) + size;\n            offsets.set(++j, offset);\n        }\n\n        return offsets.get(i)!;\n    };\n\n    // Boundary points\n    const getStart = (i: number) => getOffset(i);\n    const getEnd = (i: number) => getOffset(i + 1);\n\n    // Reverse lookup from offset to index\n    const lookupIndex = (x: number, anchor: number = 0) => {\n        // Get end of offsets array\n        let last = offsets.tail() || 0;\n\n        // Extend cache if value exceeds current end\n        while (getOffset(last) < x && getSize(last)) last += 64;\n\n        // Do binary search for exact position\n        let start = 0;\n        let end = last;\n        while (start < end) {\n            let mid = start + Math.floor((end - start) / 2) + 1;\n            let value = getOffset(mid) - (anchor ? anchor * getSize(mid - 1) : 0);\n            if (value <= x) start = mid;\n            else end = mid - 1;\n        }\n\n        return start;\n    };\n\n    const clearAfter = (index: number) => {\n        index = Math.max(0, index);\n        offsets.truncate(index);\n        sizes.truncate(index);\n        version++;\n    };\n\n    const setSizer = (s: (index: number) => number) => {\n        sizer = s;\n    };\n    const getVersion = () => version;\n\n    return { getSize, getStart, getEnd, getVersion, lookupIndex, setSizer, clearAfter };\n};\n\n// Fast map<integer, integer> that is mostly filled in from start to end.\n// Elements are only removed by truncating all indices > n.\nconst makeIntMap = (initialSize: number = 128) => {\n    let used: Uint8Array;\n    let values: Uint32Array;\n    let last = 0;\n\n    const GROW = 1.2; // 20% growth at a time\n\n    const allocate = (size: number) => {\n        let newUsed = new Uint8Array(size);\n        let newValues = new Uint32Array(size);\n        if (used) copy(used, newUsed);\n        if (values) copy(values, newValues);\n        used = newUsed;\n        values = newValues;\n    };\n    allocate(initialSize);\n\n    const copy = (from: Uint8Array | Uint32Array, to: Uint8Array | Uint32Array) => {\n        let n = Math.min(from.length, to.length);\n        for (let i = 0; i < n; ++i) {\n            to[i] = from[i];\n        }\n    };\n\n    const ensure = (size: number) => {\n        const l = values.length;\n        const grow = Math.round(l * GROW);\n        if (l < size) allocate(Math.max(grow, size));\n    };\n\n    const truncate = (size: number) => {\n        const l = values.length;\n\n        // Do nothing if smaller\n        if (l < size) return;\n\n        // If more than 20% bigger, shrink to exact size\n        const shrink = Math.round(size * GROW);\n        if (l > shrink) allocate(size);\n        // Else zero out tail\n        else for (let i = size; i < l; ++i) used[i] = 0;\n\n        // Track last filled element\n        last = Math.min(last, size);\n        while (last > 0 && !used[last]) last--;\n    };\n\n    const getTail = () => (used[last] ? last : null);\n\n    const setValue = (i: number, value: number) => {\n        ensure(i + 1);\n        values[i] = value;\n        used[i] = 1;\n        last = Math.max(last, i);\n    };\n\n    const getValue = (i: number) => (used[i] ? values[i] : null);\n    const hasValue = (i: number) => !!used[i];\n\n    return { truncate, set: setValue, get: getValue, has: hasValue, tail: getTail };\n};\n","import { InternalSheetStyle, SheetStyle, Style } from './types';\nimport { COLORS, SIZES } from './constants';\n\nexport const resolveSheetStyle = (sheetStyle?: SheetStyle): InternalSheetStyle => {\n    return {\n        freezeColumns: sheetStyle?.freezeColumns || 0,\n        freezeRows: sheetStyle?.freezeRows || 0,\n        hideColumnHeaders: sheetStyle?.hideColumnHeaders || false,\n        hideRowHeaders: sheetStyle?.hideRowHeaders || false,\n        hideGridlines: sheetStyle?.hideGridlines || false,\n        hideScrollBars: sheetStyle?.hideScrollBars || false,\n        columnHeaderHeight: sheetStyle?.hideColumnHeaders ? 1 : SIZES.headerHeight,\n        rowHeaderWidth: sheetStyle?.hideRowHeaders ? 1 : SIZES.headerWidth,\n        shadowBlur: sheetStyle?.shadowBlur ?? SIZES.shadowBlur,\n        shadowOpacity: sheetStyle?.shadowOpacity ?? SIZES.shadowOpacity,\n        shadowColor: sheetStyle?.shadowColor ?? COLORS.shadowColor,\n    };\n};\n\nexport const applyAlignment = (\n    start: number,\n    cellSize: number,\n    style: Required<Style>,\n    imageWidth: number,\n    alignment: 'left' | 'center' | 'right' = style.textAlign\n): number => {\n    if (alignment === 'left') {\n        return start + style.marginLeft;\n    } else if (alignment === 'center') {\n        return start + cellSize * 0.5 - imageWidth / 2;\n    } else if (alignment === 'right') {\n        return start + (cellSize - style.marginRight - imageWidth);\n    }\n    return start;\n};\n","import {\n    CellLayout,\n    CellPropertyFunction,\n    CellPropertyStyledFunction,\n    RowOrColumnPropertyFunction,\n    RowOrColumnPropertyStyledFunction,\n    InternalSheetStyle,\n    Rectangle,\n    Selection,\n    Clickable,\n    Style,\n    CellContentType,\n    VisibleLayout,\n    XY,\n} from './types';\nimport { applyAlignment } from './style';\nimport { normalizeSelection, isEmptySelection, isColumnSelection, isRowSelection } from './coordinate';\nimport { isInRange, isInRangeLeft, isInRangeCenter } from './util';\nimport {\n    COLORS,\n    SIZES,\n    DEFAULT_CELL_STYLE,\n    DEFAULT_COLUMN_HEADER_STYLE,\n    HEADER_SELECTED_STYLE,\n    HEADER_GROUP_SELECTED_STYLE,\n    HEADER_ACTIVE_STYLE,\n    NO_STYLE,\n    ONE_ONE,\n} from './constants';\n\nexport const renderSheet = (\n    context: CanvasRenderingContext2D,\n    cellLayout: CellLayout,\n    visibleCells: VisibleLayout,\n\n    sheetStyle: InternalSheetStyle,\n    cellStyle: CellPropertyFunction<Style>,\n\n    selection: Rectangle,\n    secondarySelections: Selection[],\n    isFocused: boolean,\n\n    knobPosition: XY | null,\n    knobArea: Rectangle | null,\n    dragIndices: [number[] | null, number[] | null],\n    dragOffset: XY | null,\n    dropTarget: Rectangle | null,\n\n    columnHeaders: RowOrColumnPropertyStyledFunction<CellContentType>,\n    columnHeaderStyle: RowOrColumnPropertyFunction<Style>,\n    displayData: CellPropertyStyledFunction<CellContentType>,\n\n    columnGroupKeys: RowOrColumnPropertyFunction<string | number | null>,\n    rowGroupKeys: RowOrColumnPropertyFunction<string | number | null>,\n    selectedColumnGroups: Set<string | number | null> | null,\n    selectedRowGroups: Set<string | number | null> | null,\n\n    dataOffset: XY\n): Clickable[] => {\n    const { canvas } = context;\n    const { width, height } = canvas;\n    const {\n        hideGridlines,\n        hideRowHeaders,\n        hideColumnHeaders,\n        rowHeaderWidth,\n        columnHeaderHeight,\n        freezeColumns,\n        freezeRows,\n        shadowBlur,\n        shadowColor,\n        shadowOpacity,\n    } = sheetStyle;\n    const { columns, rows } = visibleCells;\n    const { columnToPixel, rowToPixel, columnToAbsolute, rowToAbsolute } = cellLayout;\n\n    const clickables: Clickable[] = [];\n\n    const freeze: XY = [freezeColumns, freezeRows];\n    const indent: XY = [rowHeaderWidth, columnHeaderHeight];\n\n    resizeCanvas(canvas);\n    context.clearRect(0, 0, width, height);\n    context.fillStyle = 'white';\n    context.fillRect(0, 0, width, height);\n    context.shadowColor = '#00000080';\n\n    // Cell fill\n    for (const y of rows) {\n        for (const x of columns) {\n            const left = columnToPixel(x);\n            const right = columnToPixel(x, 1);\n            const top = rowToPixel(y);\n            const bottom = rowToPixel(y, 1);\n\n            const { fillColor } = cellStyle(x, y);\n            if (fillColor) {\n                context.fillStyle = fillColor;\n                context.fillRect(left, top, right - left, bottom - top);\n            }\n        }\n    }\n\n    const selectionActive = !isEmptySelection(selection);\n    const rowSelectionActive = isRowSelection(selection);\n    const columnSelectionActive = isColumnSelection(selection);\n\n    // Get selection range\n    const [selected, hideKnob] = resolveFrozenSelection(selection, cellLayout, freeze, indent, dataOffset);\n\n    // Selection fill\n    if (selectionActive) {\n        const [[left, top], [right, bottom]] = selected;\n        context.fillStyle = COLORS.selectionBackground;\n        context.fillRect(left, top, right - left, bottom - top);\n    }\n\n    if (!hideRowHeaders) {\n        // Row header background\n        context.fillStyle = COLORS.headerBackground;\n        context.fillRect(0, 0, rowHeaderWidth, context.canvas.height);\n\n        // Row header selection shadow\n        if (selectionActive && !columnSelectionActive) {\n            const [[, top], [, bottom]] = selected;\n            context.fillStyle = COLORS.headerActive;\n            context.fillRect(0, top, rowHeaderWidth, bottom - top);\n        }\n    }\n\n    if (!hideColumnHeaders) {\n        // Column header background\n        context.fillStyle = COLORS.headerBackground;\n        context.fillRect(0, 0, context.canvas.width, columnHeaderHeight);\n\n        // Column header selection shadow\n        if (selectionActive && !rowSelectionActive) {\n            const [[left], [right]] = selected;\n            context.fillStyle = COLORS.headerActive;\n            context.fillRect(left, 0, right - left, columnHeaderHeight);\n        }\n    }\n\n    // Grid\n    context.strokeStyle = COLORS.gridLine;\n    context.lineWidth = 1;\n\n    const gridRight = hideGridlines ? rowHeaderWidth : context.canvas.width;\n    const gridBottom = hideGridlines ? columnHeaderHeight : context.canvas.height;\n\n    const drawGridLineX = (x: number, height: number) => {\n        context.beginPath();\n        context.moveTo(x - 0.5, 0);\n        context.lineTo(x - 0.5, height);\n        context.stroke();\n    };\n\n    const drawGridLineY = (y: number, width: number) => {\n        context.beginPath();\n        context.moveTo(0, y - 0.5);\n        context.lineTo(width, y - 0.5);\n        context.stroke();\n    };\n\n    drawGridLineX(rowHeaderWidth, context.canvas.height);\n    drawGridLineY(columnHeaderHeight, context.canvas.width);\n\n    for (const column of columns) {\n        const right = columnToPixel(column, 1);\n        drawGridLineX(right, gridBottom);\n    }\n\n    for (const row of rows) {\n        const bottom = rowToPixel(row, 1);\n        drawGridLineY(bottom, gridRight);\n    }\n\n    const [[minX, minY], [maxX, maxY]] = normalizeSelection(selection);\n\n    // Row header text\n    if (!hideRowHeaders) {\n        context.textBaseline = 'middle';\n        context.textAlign = 'center';\n        context.font = DEFAULT_CELL_STYLE.fontSize + 'px ' + DEFAULT_CELL_STYLE.fontFamily;\n        context.fillStyle = COLORS.headerText;\n\n        for (const row of rows) {\n            const content = `${row + 1}`;\n\n            // Row selection mode\n            // (this is separate from the header selection shadow because we only want to highlight visible headers)\n            const isActive = isInRange(row, minY, maxY);\n\n            const groupKey = rowGroupKeys(row);\n            const isInRowGroup = groupKey != null && selectedRowGroups?.has(groupKey);\n\n            const isSelfSelected = rowSelectionActive && isActive;\n            const isGroupSelected = rowSelectionActive && isInRowGroup;\n\n            const style = isSelfSelected\n                ? HEADER_SELECTED_STYLE\n                : isGroupSelected\n                ? HEADER_GROUP_SELECTED_STYLE\n                : isActive\n                ? HEADER_ACTIVE_STYLE\n                : NO_STYLE;\n\n            const resolvedStyle = { ...DEFAULT_COLUMN_HEADER_STYLE, ...style };\n\n            const top = rowToPixel(row);\n            const bottom = rowToPixel(row, 1);\n\n            clickables.push(...renderCell(context, content, resolvedStyle, 0, top, rowHeaderWidth, bottom - top));\n        }\n    }\n\n    // Column header text\n    if (!hideColumnHeaders) {\n        context.textBaseline = 'middle';\n        context.textAlign = 'center';\n\n        for (const column of columns) {\n            // Column selection mode\n            // (this is separate from the header selection shadow because we only want to highlight visible headers)\n            const isActive = isInRange(column, minX, maxX);\n\n            const groupKey = columnGroupKeys(column);\n            const isInColumnGroup = groupKey != null && selectedColumnGroups?.has(groupKey);\n\n            const isSelected = columnSelectionActive && !rowSelectionActive && (isActive || isInColumnGroup);\n            const selectedStyle = isSelected ? HEADER_SELECTED_STYLE : NO_STYLE;\n            const activeStyle = isActive ? HEADER_ACTIVE_STYLE : NO_STYLE;\n            const style = {\n                ...DEFAULT_COLUMN_HEADER_STYLE,\n                ...columnHeaderStyle(column),\n                ...activeStyle,\n                ...selectedStyle,\n            };\n\n            const left = columnToPixel(column);\n            const right = columnToPixel(column, 1);\n\n            const content = columnHeaders(column, style) ?? excelHeaderString(column + 1);\n\n            clickables.push(...renderCell(context, content, style, left, 0, right - left, columnHeaderHeight));\n        }\n    }\n\n    // Selection outline\n    if (selectionActive) {\n        context.strokeStyle = COLORS.selectionBorder;\n        context.lineWidth = 2;\n        context.globalAlpha = isFocused ? 1 : 0.5;\n\n        const [[left, top], [right, bottom]] = selected;\n        context.strokeRect(left, top, right - left - 1, bottom - top - 1);\n\n        context.globalAlpha = 1;\n    }\n\n    for (const secondarySelection of secondarySelections) {\n        const selection = secondarySelection.span;\n        if (isEmptySelection(selection)) continue;\n\n        const [selected] = resolveFrozenSelection(selection, cellLayout, freeze, indent, dataOffset);\n        const [[left, top], [right, bottom]] = selected;\n\n        context.strokeStyle = secondarySelection.color;\n        context.lineWidth = 1;\n        context.beginPath();\n        context.strokeRect(left - 1, top - 1, right - left + 1, bottom - top + 1);\n    }\n\n    // Knob drag outline\n    if (knobArea) {\n        let [[minX, minY], [maxX, maxY]] = normalizeSelection(knobArea);\n        const left = columnToPixel(minX);\n        const top = rowToPixel(minY);\n        const right = columnToPixel(maxX, 1);\n        const bottom = rowToPixel(maxY, 1);\n\n        context.strokeStyle = COLORS.knobAreaBorder;\n        context.setLineDash([3, 3]);\n        context.lineWidth = 1;\n\n        context.strokeRect(left - 1, top - 1, right - left + 1, bottom - top + 1);\n        context.setLineDash([]);\n    }\n\n    // Selection knob\n    if (knobPosition && !hideKnob) {\n        const [knobX, knobY] = knobPosition;\n        context.fillStyle = COLORS.selectionBorder;\n        context.fillRect(knobX - SIZES.knobArea * 0.5, knobY - SIZES.knobArea * 0.5, SIZES.knobArea, SIZES.knobArea);\n    }\n\n    // Drag ghost (pixels)\n    if (dragOffset) {\n        const [shiftX, shiftY] = dragOffset;\n        const [dragColumns, dragRows] = dragIndices;\n\n        context.fillStyle = COLORS.dragGhost;\n\n        if (dragColumns) {\n            for (const column of dragColumns) {\n                const left = columnToPixel(column);\n                const right = columnToPixel(column, 1);\n                context.fillRect(left + shiftX, 0, right - left, height);\n            }\n        }\n        if (dragRows) {\n            for (const row of dragRows) {\n                const top = rowToPixel(row);\n                const bottom = rowToPixel(row, 1);\n                context.fillRect(0, top + shiftY, width, bottom - top);\n            }\n        }\n    }\n\n    // Drop target\n    if (dropTarget) {\n        let [[left, top], [right, bottom]] = resolveSelection(dropTarget, cellLayout);\n\n        context.strokeStyle = COLORS.dropTarget;\n        context.lineWidth = 4;\n\n        if (isColumnSelection(dropTarget)) {\n            right = left;\n        }\n        if (isRowSelection(dropTarget)) {\n            bottom = top;\n        }\n        context.strokeRect(left - 1, top - 1, right - left, bottom - top);\n    }\n\n    // Draw frozen row/col shadow\n    const [scrollX, scrollY] = dataOffset;\n    const hasRowShadow = freezeRows > 0 && scrollY > 0;\n    const hasColumnShadow = freezeColumns > 0 && scrollX > 0;\n    if (hasRowShadow || hasColumnShadow) {\n        if (hasRowShadow) {\n            const h = columnHeaderHeight + rowToAbsolute(freezeRows);\n            const gradient = context.createLinearGradient(0, h, 0, h + shadowBlur);\n            halfShadowGradient(gradient, shadowColor, shadowOpacity);\n            context.fillStyle = gradient;\n            context.fillRect(0, h, width, shadowBlur);\n        }\n        if (hasColumnShadow) {\n            const w = rowHeaderWidth + columnToAbsolute(freezeColumns);\n            const gradient = context.createLinearGradient(w, 0, w + shadowBlur, 0);\n            halfShadowGradient(gradient, shadowColor, shadowOpacity);\n            context.fillStyle = gradient;\n            context.fillRect(w, 0, shadowBlur, height);\n        }\n    }\n\n    // Cell contents\n    context.textBaseline = 'middle';\n\n    for (const y of rows) {\n        for (const x of columns) {\n            const left = columnToPixel(x);\n            const right = columnToPixel(x, 1);\n            const top = rowToPixel(y);\n            const bottom = rowToPixel(y, 1);\n\n            const style = {\n                ...DEFAULT_CELL_STYLE,\n                ...cellStyle(x, y),\n            };\n            const cellContent = displayData(x, y, style);\n            if (cellContent !== null && cellContent !== undefined) {\n                clickables.push(...renderCell(context, cellContent, style, left, top, right - left, bottom - top));\n            }\n        }\n    }\n\n    return clickables;\n};\n\nexport const renderCell = (\n    context: CanvasRenderingContext2D,\n    cellContent: CellContentType,\n    style: Required<Style>,\n    xCoord: number,\n    yCoord: number,\n    cellWidth: number,\n    cellHeight: number\n): Clickable[] => {\n    const clickables: Clickable[] = [];\n\n    if (cellContent === null) {\n        return clickables;\n    }\n\n    context.fillStyle = style.color;\n    context.font = style.weight + ' ' + style.fontSize + 'px ' + style.fontFamily;\n    context.textAlign = style.textAlign;\n\n    const yy = Math.floor(yCoord + cellHeight * 0.5);\n\n    context.save();\n    context.beginPath();\n    context.rect(xCoord, yCoord, cellWidth, cellHeight);\n    context.clip();\n\n    if (style.backgroundColor !== '') {\n        context.fillStyle = style.backgroundColor;\n        context.fillRect(xCoord, yCoord, cellWidth, cellHeight);\n        context.fillStyle = style.color;\n    }\n\n    if (typeof cellContent === 'string' || typeof cellContent === 'number') {\n        const xx = applyAlignment(xCoord, cellWidth, style, 0);\n        const text = '' + cellContent;\n        context.fillText(text, xx, yy);\n    } else if (typeof cellContent === 'object') {\n        for (const obj of cellContent.items) {\n            let x = 0;\n            let y = 0;\n            let w = 0;\n            let h = 0;\n\n            if (obj.content instanceof HTMLImageElement) {\n                w = obj.width || cellWidth;\n                h = obj.height || cellHeight;\n\n                const finalX = applyAlignment(xCoord, cellWidth, style, w, obj.horizontalAlign);\n                x = finalX + obj.x;\n                y = yy + obj.y;\n\n                context.drawImage(obj.content, x, y, w, h);\n            } else if (typeof obj.content === 'string' || typeof obj.content === 'number') {\n                if (obj.horizontalAlign) {\n                    context.textAlign = obj.horizontalAlign;\n                }\n                const finalX = applyAlignment(xCoord, cellWidth, style, 0, obj.horizontalAlign);\n                const text = '' + obj.content;\n\n                const left = finalX + obj.x;\n                const top = yy + obj.y;\n                context.fillText(text, left, top);\n\n                const measure = context.measureText(text);\n                x = left - measure.actualBoundingBoxLeft;\n                y = top - measure.actualBoundingBoxAscent;\n                w = left + measure.actualBoundingBoxRight - x;\n                h = top + measure.actualBoundingBoxDescent - y;\n            }\n            if (obj.onClick) {\n                clickables.push({\n                    rect: [\n                        [x, y],\n                        [x + w, y + h],\n                    ],\n                    obj,\n                });\n            }\n        }\n    }\n    context.restore();\n\n    return clickables;\n};\n\n// Resolve selection into a consistent rectangle, without dealing with frozen rows/columns\nconst resolveSelection = (selection: Rectangle, cellLayout: CellLayout) => {\n    const { cellToPixel } = cellLayout;\n\n    const rowSelectionActive = isRowSelection(selection);\n    const columnSelectionActive = isColumnSelection(selection);\n\n    // Get selection range\n    const [min, max] = normalizeSelection(selection);\n\n    // Direct projection to visible grid\n    let [left, top] = cellToPixel(min);\n    let [right, bottom] = cellToPixel(max, ONE_ONE);\n\n    // Extend full row/column selection infinitely right/down\n    if (rowSelectionActive) {\n        right = 1e5;\n    }\n    if (columnSelectionActive) {\n        bottom = 1e5;\n    }\n\n    return [\n        [left, top],\n        [right, bottom],\n    ];\n};\n\n// Resolve selection into a consistent rectangle, handling edge cases around frozen rows/columns.\nconst resolveFrozenSelection = (\n    selection: Rectangle,\n    cellLayout: CellLayout,\n\n    freeze: XY,\n    indent: XY,\n    offset: XY\n) => {\n    const { cellToPixel, columnToAbsolute, rowToAbsolute } = cellLayout;\n\n    const rowSelectionActive = isRowSelection(selection);\n    const columnSelectionActive = isColumnSelection(selection);\n\n    const [freezeX, freezeY] = freeze;\n    const [indentX, indentY] = indent;\n    const [offsetX, offsetY] = offset;\n\n    // Get selection range\n    const [min, max] = normalizeSelection(selection);\n    const [minX, minY] = min;\n    const [maxX, maxY] = max;\n\n    // Direct projection to visible grid\n    let [left, top] = cellToPixel(min);\n    let [right, bottom] = cellToPixel(max, ONE_ONE);\n\n    // Get frozen edge\n    const frozenX = columnToAbsolute(freezeX);\n    const frozenY = rowToAbsolute(freezeY);\n\n    let hideKnob = false;\n\n    // If the selection crosses the frozen edge, it needs to always cover the entire frozen area.\n    if (isInRangeCenter(freezeX, minX, maxX + 1)) {\n        const edge = indentX + frozenX;\n        if (right <= edge) {\n            right = edge;\n            hideKnob = true;\n        }\n    }\n    if (isInRangeCenter(freezeY, minY, maxY + 1)) {\n        const edge = indentY + frozenY;\n        if (bottom <= edge) {\n            bottom = edge;\n            hideKnob = true;\n        }\n    }\n\n    // If the selection starts/ends under the frozen area, treat as off-screen\n    if (isInRangeLeft(minX, freezeX, offsetX + freezeX)) {\n        left = -1e5;\n\n        const lastInvisibleX = offsetX + freezeX - 1;\n        if (maxX <= lastInvisibleX) {\n            if (maxX === lastInvisibleX) right = indentX;\n            else right = -1e5;\n            hideKnob = true;\n        }\n    }\n    if (isInRangeLeft(minY, freezeY, offsetY + freezeY)) {\n        top = -1e5;\n\n        const lastInvisibleY = offsetY + freezeY - 1;\n        if (maxY <= lastInvisibleY) {\n            if (maxY === lastInvisibleY) bottom = indentY;\n            else bottom = -1e5;\n            hideKnob = true;\n        }\n    }\n\n    if (rowSelectionActive && offsetX > 0) {\n        hideKnob = true;\n    }\n    if (columnSelectionActive && offsetY > 0) {\n        hideKnob = true;\n    }\n\n    // Extend full row/column selection infinitely right/down\n    if (rowSelectionActive) {\n        right = 1e5;\n    }\n    if (columnSelectionActive) {\n        bottom = 1e5;\n    }\n\n    return [\n        [\n            [left, top],\n            [right, bottom],\n        ],\n        hideKnob,\n    ] as [Rectangle, boolean];\n};\n\nconst resizeCanvas = (canvas: HTMLCanvasElement) => {\n    const { width, height } = canvas.getBoundingClientRect();\n    let { devicePixelRatio: ratio = 1 } = window;\n    if (ratio < 1) {\n        ratio = 1;\n    }\n    const newCanvasWidth = Math.round(width * ratio);\n    const newCanvasHeight = Math.round(height * ratio);\n\n    if (canvas.width !== newCanvasWidth || canvas.height !== newCanvasHeight) {\n        const context = canvas.getContext('2d');\n        if (context) {\n            canvas.width = newCanvasWidth;\n            canvas.height = newCanvasHeight;\n            context.scale(ratio, ratio);\n        }\n        return true;\n    }\n\n    return false;\n};\n\nconst excelHeaderString = (num: number) => {\n    let s = '';\n    let t = 0;\n    while (num > 0) {\n        t = (num - 1) % 26;\n        s = String.fromCharCode(65 + t) + s;\n        num = ((num - t) / 26) | 0;\n    }\n    return s || '';\n};\n\nconst halfShadowGradient = (gradient: CanvasGradient, rgb: string, opacity: number) => {\n    const hex = (x: number) => ('0' + Math.round(x).toString(16)).slice(-2);\n    // Half-sine ease\n    const ease = (x: number) => 1.0 - Math.sin((x * Math.PI) / 2);\n    // Gamma adjustment assuming blend on white\n    const adjust = (x: number) => 1.0 - Math.pow(1.0 - x, 2.2);\n    for (let i = 0; i <= 16; ++i) {\n        const f = i / 16;\n        gradient.addColorStop(f, rgb + hex(adjust(opacity * ease(f) * 0.5) * 255));\n    }\n};\n","import styles from './styles.module.css';\nimport React, {\n    forwardRef,\n    useRef,\n    useImperativeHandle,\n    useLayoutEffect,\n    useState,\n    useMemo,\n    KeyboardEventHandler,\n    ReactElement,\n} from 'react';\nimport useResizeObserver from 'use-resize-observer';\n\nimport {\n    XY,\n    Rectangle,\n    CellLayout,\n    CellProperty,\n    CellPropertyStyled,\n    CellContentType,\n    ClipboardPayload,\n    RowOrColumnPropertyStyled,\n    RowOrColumnProperty,\n    Selection,\n    Clickable,\n    Change,\n    SheetPointerEvent,\n    InternalSheetStyle,\n    InputStyle,\n    SheetStyle,\n    Style,\n    VisibleLayout,\n} from './types';\n\nimport {\n    DEFAULT_CELL_STYLE,\n    INITIAL_MAX_SCROLL,\n    NO_CELL,\n    NO_CLICKABLES,\n    NO_SELECTION,\n    NO_SELECTIONS,\n    ORIGIN,\n    ONE_ONE,\n} from './constants';\nimport {\n    normalizeSelection,\n    validateSelection,\n    isSameSelection,\n    mapSelectionColumns,\n    mapSelectionRows,\n    addXY,\n} from './coordinate';\nimport { useMouse } from './mouse';\nimport { useKeyboard } from './keyboard';\nimport { useScroll, scrollToCell, clipDataOffset } from './scroll';\nimport { useAutoSizeColumn } from './autosize';\nimport { useClipboardAPI } from './clipboard';\nimport { makeLayoutCache, makeCellLayout } from './layout';\nimport { createCellProp, createCellStyledProp, createRowOrColumnProp, createRowOrColumnStyledProp } from './props';\nimport { renderSheet } from './render';\nimport { resolveSheetStyle } from './style';\n\nexport type SheetInputProps = {\n    value: string;\n    autoFocus: boolean;\n    onKeyDown: KeyboardEventHandler<HTMLElement>;\n    onChange: (value: string) => void;\n    style: InputStyle;\n};\n\nexport type SheetRenderProps = {\n    visibleCells: VisibleLayout;\n    cellLayout: CellLayout;\n    selection: Rectangle;\n    editMode: boolean;\n};\n\nexport type SheetProps = {\n    cellWidth?: RowOrColumnProperty<number>;\n    cellHeight?: RowOrColumnProperty<number>;\n    columnHeaders?: RowOrColumnPropertyStyled<CellContentType>;\n    columnHeaderStyle?: RowOrColumnProperty<Style>;\n    cellStyle?: CellProperty<Style>;\n    readOnly?: CellProperty<boolean>;\n    canSizeColumn?: RowOrColumnProperty<boolean>;\n    canSizeRow?: RowOrColumnProperty<boolean>;\n    canOrderColumn?: RowOrColumnProperty<boolean>;\n    canOrderRow?: RowOrColumnProperty<boolean>;\n    columnGroupKeys?: RowOrColumnProperty<string | number | null>;\n    rowGroupKeys?: RowOrColumnProperty<string | number | null>;\n    sourceData?: CellProperty<string | number | null>;\n    displayData?: CellPropertyStyled<CellContentType>;\n    editData?: CellProperty<string>;\n    editKeys?: CellProperty<string>;\n    sheetStyle?: SheetStyle;\n    selection?: Rectangle;\n    secondarySelections?: Selection[];\n\n    maxRows?: number;\n    maxColumns?: number;\n    cacheLayout?: boolean | number;\n    dontCommitEditOnSelectionChange?: boolean;\n    dontChangeSelectionOnOrderChange?: boolean;\n\n    autoFocus?: boolean;\n    inputComponent?: (\n        x: number,\n        y: number,\n        props: SheetInputProps,\n        commitEditingCell?: (value?: string | number | null) => void\n    ) => ReactElement | undefined;\n\n    renderInside?: (props: SheetRenderProps) => React.ReactNode;\n    renderOutside?: (props: SheetRenderProps) => React.ReactNode;\n\n    onSelectionChanged?: (minX: number, minY: number, maxX: number, maxY: number) => void;\n    onRightClick?: (e: SheetPointerEvent) => void;\n    onChange?: (changes: Array<Change>) => void;\n    onColumnOrderChange?: (indices: number[], order: number) => void;\n    onRowOrderChange?: (indices: number[], order: number) => void;\n    onCellWidthChange?: (indices: number[], values: number[]) => void;\n    onCellHeightChange?: (indices: number[], values: number[]) => void;\n    onScrollChange?: (visibleRows: number[], visibleColumns: number[]) => void;\n\n    onCopy?: (selection: Rectangle, cells: string[][]) => ClipboardPayload<any> | null | undefined;\n    onPaste?: (\n        selection: Rectangle,\n        cells: string[][],\n        payload: ClipboardPayload<any>\n    ) => boolean | null | undefined | Promise<boolean | null | undefined>;\n};\n\nexport type SheetRef = CellLayout & {\n    startEditingCell: (editCell: XY, arrowKeyCommitMode?: boolean) => void;\n    copySelection: (selection: Rectangle, cut?: boolean) => Promise<void>;\n    pasteSelection: (selection: Rectangle) => Promise<void>;\n    canPasteSelection: () => boolean;\n};\n\nconst Sheet = forwardRef<SheetRef, SheetProps>((props, ref) => {\n    const canvasRef = useRef<HTMLCanvasElement>(null);\n    const overlayRef = useRef<HTMLDivElement>(null);\n\n    const [maxScroll, setMaxScroll] = useState<XY>(INITIAL_MAX_SCROLL);\n    const [dataOffset, setDataOffset] = useState<XY>(ORIGIN);\n\n    const selectionProp = props.selection ?? NO_SELECTION;\n\n    const [rawSelection, setRawSelection] = useState<Rectangle>(selectionProp);\n    const [knobArea, setKnobArea] = useState<Rectangle | null>(null);\n    const [dragOffset, setDragOffset] = useState<XY | null>(null);\n    const [dragIndices, setDragIndices] = useState<[number[] | null, number[] | null]>([null, null]);\n    const [dropTarget, setDropTarget] = useState<Rectangle | null>(null);\n    const [editCell, setEditCell] = useState<XY>(NO_CELL);\n\n    const [focused, setFocused] = useState(!!props.autoFocus);\n\n    const [lastSelectionProp, setLastSelectionProp] = useState<Rectangle>(selectionProp);\n    if (lastSelectionProp !== selectionProp) {\n        setLastSelectionProp(selectionProp);\n        setRawSelection(selectionProp);\n    }\n\n    const [editValue, setEditValue] = useState<string | number>('');\n    const [arrowKeyCommitMode, setArrowKeyCommitMode] = useState(false);\n\n    const { width: canvasWidth = 3000, height: canvasHeight = 3000 } = useResizeObserver({ ref: overlayRef });\n\n    const cellWidth = useMemo(() => createRowOrColumnProp(props.cellWidth, 100), [props.cellWidth]);\n    const cellHeight = useMemo(() => createRowOrColumnProp(props.cellHeight, 22), [props.cellHeight]);\n    const columnHeaders = useMemo(() => createRowOrColumnStyledProp(props.columnHeaders, null), [props.columnHeaders]);\n    const columnHeaderStyle = useMemo(() => createRowOrColumnProp(props.columnHeaderStyle, {}), [\n        props.columnHeaderStyle,\n    ]);\n\n    const canSizeColumn = useMemo(() => createRowOrColumnProp(props.canSizeColumn, true), [props.canSizeColumn]);\n    const canSizeRow = useMemo(() => createRowOrColumnProp(props.canSizeRow, true), [props.canSizeRow]);\n    const canOrderColumn = useMemo(() => createRowOrColumnProp(props.canOrderColumn, true), [props.canOrderColumn]);\n    const canOrderRow = useMemo(() => createRowOrColumnProp(props.canOrderRow, true), [props.canOrderRow]);\n\n    const rowGroupKeys = useMemo(() => createRowOrColumnProp(props.rowGroupKeys, null), [props.rowGroupKeys]);\n    const columnGroupKeys = useMemo(() => createRowOrColumnProp(props.columnGroupKeys, null), [props.columnGroupKeys]);\n\n    const cellReadOnly = useMemo(() => createCellProp(props.readOnly, false), [props.readOnly]);\n\n    const sourceData = useMemo(() => createCellProp(props.sourceData, null), [props.sourceData]);\n    const displayData = useMemo(() => createCellStyledProp(props.displayData, ''), [props.displayData]);\n    const editData = useMemo(() => createCellProp(props.editData, ''), [props.editData]);\n    const editKeys = useMemo(() => createCellProp(props.editKeys, ''), [props.editKeys]);\n    const cellStyle = useMemo(() => createCellProp(props.cellStyle, DEFAULT_CELL_STYLE), [props.cellStyle]);\n\n    const sheetStyle: InternalSheetStyle = useMemo(() => resolveSheetStyle(props.sheetStyle), [props.sheetStyle]);\n    const secondarySelections = props.secondarySelections ?? NO_SELECTIONS;\n\n    const selection = useMemo(() => validateSelection(rawSelection), [rawSelection]);\n\n    const selectedColumnGroups = useMemo(\n        () =>\n            props.columnGroupKeys\n                ? new Set(mapSelectionColumns(selection)((x: number) => columnGroupKeys(x)).filter((x) => x != null))\n                : null,\n        [props.columnGroupKeys, columnGroupKeys, selection]\n    );\n    const selectedRowGroups = useMemo(\n        () =>\n            props.rowGroupKeys\n                ? new Set(mapSelectionRows(selection)((y: number) => rowGroupKeys(y)).filter((x) => x != null))\n                : null,\n        [props.rowGroupKeys, rowGroupKeys, selection]\n    );\n\n    const [maxScrollX, maxScrollY] = maxScroll;\n\n    const [editCellX, editCellY] = editCell;\n    const editMode = editCellX !== -1 && editCellY !== -1;\n\n    // Global layout for unscrolled/unfrozen grid\n    // Cached either per width/height pair, or permanently with invalidation on resize/reorder.\n    const shouldCacheLayout = (props.cacheLayout ?? false) !== false;\n    const layoutVersion = typeof props.cacheLayout === 'number' ? props.cacheLayout : 0;\n    const columnLayout = useMemo(() => makeLayoutCache(cellWidth), [shouldCacheLayout ? layoutVersion : cellWidth]);\n    const rowLayout = useMemo(() => makeLayoutCache(cellHeight), [shouldCacheLayout ? layoutVersion : cellHeight]);\n    useMemo(() => {\n        if (!shouldCacheLayout) return;\n\n        columnLayout.setSizer(cellWidth);\n        rowLayout.setSizer(cellHeight);\n\n        // Depend on layoutVersion to allow for controlled external invalidation\n        // eslint-disable-next-line\n    }, [shouldCacheLayout, layoutVersion, cellWidth, cellHeight]);\n\n    // Virtual layout for indented/scrolled/frozen grid\n    const { freezeColumns, freezeRows, rowHeaderWidth, columnHeaderHeight } = sheetStyle;\n    const cellLayout = useMemo(\n        () =>\n            makeCellLayout(\n                [freezeColumns, freezeRows],\n                [rowHeaderWidth, columnHeaderHeight],\n                dataOffset,\n                columnLayout,\n                rowLayout\n            ),\n        [freezeColumns, freezeRows, rowHeaderWidth, columnHeaderHeight, dataOffset, columnLayout, rowLayout]\n    );\n\n    // Build range of visible cells\n    const { getVisibleCells, cellToPixel, getVersion } = cellLayout;\n    const visibleCells = useMemo(\n        () => getVisibleCells([canvasWidth, canvasHeight]),\n        // Need to invalidate view if cached layout version changed\n        // eslint-disable-next-line\n        [getVisibleCells, canvasWidth, canvasHeight, getVersion()]\n    );\n\n    // Notify of viewport change\n    useLayoutEffect(() => {\n        if (props.onScrollChange) {\n            props.onScrollChange([...visibleCells.rows], [...visibleCells.columns]);\n        }\n    }, [visibleCells, props.onScrollChange]);\n\n    const scrollToSelection = (selection: Rectangle, toHead = false) => {\n        const { current: overlay } = overlayRef;\n        if (!overlay) return;\n\n        const [anchor, head] = selection;\n        const view: XY = [canvasWidth, canvasHeight];\n        const freeze: XY = [freezeColumns, freezeRows];\n\n        scrollToCell(\n            overlay,\n            toHead ? head : anchor,\n            view,\n            freeze,\n            dataOffset,\n            maxScroll,\n            cellLayout,\n            (dataOffset: XY, maxScroll: XY) => {\n                setDataOffset(dataOffset);\n                setMaxScroll(maxScroll);\n            }\n        );\n    };\n\n    // Set selection with scrolling\n    const changeSelection = (newSelection: Rectangle, scrollTo = true, toHead = false) => {\n        if (!isSameSelection(selection, newSelection)) {\n            setRawSelection(newSelection);\n        }\n\n        const { current: overlay } = overlayRef;\n        if (!overlay) return;\n\n        if (scrollTo) {\n            scrollToSelection(newSelection, toHead);\n        }\n\n        if (props.onSelectionChanged) {\n            const [[minX, minY], [maxX, maxY]] = normalizeSelection(validateSelection(newSelection));\n            props.onSelectionChanged(minX, minY, maxX, maxY);\n        }\n    };\n\n    const cancelEditingCell = () => {\n        setEditCell(NO_CELL);\n        setFocused(true);\n    };\n\n    const commitEditingCell = (value?: string) => {\n        if (props.onChange) {\n            const [cellX, cellY] = editCell;\n            props.onChange([{ x: cellX, y: cellY, value: value !== undefined ? value : editValue }]);\n        }\n        setEditCell(NO_CELL);\n        setFocused(true);\n    };\n\n    const startEditingCell = (editCell: XY, arrowKeyCommitMode = false) => {\n        const [cellX, cellY] = editCell;\n        if (cellReadOnly(cellX, cellY)) {\n            return;\n        }\n\n        const editDataValue = editData(cellX, cellY);\n        let val = '';\n        if (editDataValue !== null && editDataValue !== undefined) {\n            val = editDataValue;\n        }\n        setEditCell(editCell);\n        setEditValue(val);\n        setArrowKeyCommitMode(arrowKeyCommitMode);\n        setLastEditKey(editKeys(...editCell));\n    };\n\n    // If max row or column count changes, keep sheet in view\n    const { maxColumns = Infinity, maxRows = Infinity } = props;\n    useLayoutEffect(() => {\n        const view: XY = [canvasWidth, canvasHeight];\n        const freeze: XY = [freezeColumns, freezeRows];\n\n        setDataOffset(clipDataOffset(view, dataOffset, freeze, [maxColumns, maxRows], cellLayout));\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [maxRows, maxColumns]);\n\n    // Output from rendered layout is used to drive events on user content\n    const hitmapRef = useRef<Clickable[]>(NO_CLICKABLES);\n\n    // Detect focus on canvas\n    const isFocused = focused || editMode;\n\n    const { clipboardApi, onClipboardCopy } = useClipboardAPI(\n        selection,\n        editData,\n        cellReadOnly,\n        isFocused,\n        changeSelection,\n        props.onChange,\n        props.onCopy,\n        props.onPaste\n    );\n\n    const onScroll = useScroll(dataOffset, maxScroll, cellLayout, setDataOffset, setMaxScroll);\n\n    const getAutoSizeWidth = useAutoSizeColumn(\n        visibleCells.rows,\n        displayData,\n        cellStyle,\n        columnHeaders,\n        columnHeaderStyle,\n        canvasWidth\n    );\n\n    const { mouseHandlers, knobPosition } = useMouse(\n        hitmapRef,\n        selection,\n        knobArea,\n        editMode,\n        editData,\n        sourceData,\n        cellReadOnly,\n\n        canSizeColumn,\n        canSizeRow,\n        canOrderColumn,\n        canOrderRow,\n\n        cellLayout,\n        visibleCells,\n        sheetStyle,\n\n        columnGroupKeys,\n        rowGroupKeys,\n        selectedColumnGroups,\n        selectedRowGroups,\n\n        getAutoSizeWidth,\n\n        startEditingCell,\n        commitEditingCell,\n        setKnobArea,\n        setDragIndices,\n        setDragOffset,\n        setDropTarget,\n        changeSelection,\n        setFocused,\n\n        props.cacheLayout ? columnLayout.clearAfter : undefined,\n        props.cacheLayout ? rowLayout.clearAfter : undefined,\n\n        props.onChange,\n        props.onColumnOrderChange,\n        props.onRowOrderChange,\n        props.onCellWidthChange,\n        props.onCellHeightChange,\n        props.onRightClick,\n        props.dontCommitEditOnSelectionChange,\n        props.dontChangeSelectionOnOrderChange\n    );\n\n    const { onInputKeyDown, onGridKeyDown, onGridFocus, onGridBlur } = useKeyboard(\n        arrowKeyCommitMode,\n        overlayRef,\n        cellReadOnly,\n        displayData,\n        editCell,\n        editMode,\n        focused,\n        rawSelection,\n        selection,\n\n        startEditingCell,\n        commitEditingCell,\n        cancelEditingCell,\n        changeSelection,\n        setFocused,\n        onClipboardCopy,\n\n        props.onChange\n    );\n\n    useLayoutEffect(() => {\n        const { current: canvas } = canvasRef;\n        if (!canvas) {\n            return;\n        }\n\n        const context = canvas.getContext('2d');\n        if (!context) {\n            return;\n        }\n\n        const animationFrameId = window.requestAnimationFrame(() => {\n            hitmapRef.current = renderSheet(\n                context,\n\n                cellLayout,\n                visibleCells,\n                sheetStyle,\n                cellStyle,\n                selection,\n                secondarySelections,\n                isFocused,\n\n                knobPosition,\n                knobArea,\n                dragIndices,\n                dragOffset,\n                dropTarget,\n\n                columnHeaders,\n                columnHeaderStyle,\n                displayData,\n\n                columnGroupKeys,\n                rowGroupKeys,\n                selectedColumnGroups,\n                selectedRowGroups,\n\n                dataOffset\n            );\n        });\n\n        return () => {\n            window.cancelAnimationFrame(animationFrameId);\n        };\n    }, [\n        cellLayout,\n        visibleCells,\n        sheetStyle,\n        cellStyle,\n        selection,\n        secondarySelections,\n        isFocused,\n\n        knobPosition,\n        knobArea,\n        dragOffset,\n        dropTarget,\n\n        columnHeaders,\n        columnHeaderStyle,\n        displayData,\n\n        columnGroupKeys,\n        rowGroupKeys,\n        selectedColumnGroups,\n        selectedRowGroups,\n\n        dataOffset,\n    ]);\n\n    const [lastEditKey, setLastEditKey] = useState('');\n\n    let editTextPosition = ORIGIN;\n    let editTextWidth = 0;\n    let editTextHeight = 0;\n    let editTextTextAlign: 'right' | 'left' | 'center' = 'right';\n    if (editMode) {\n        const style = cellStyle(...editCell);\n        editTextPosition = cellToPixel(editCell);\n        editTextPosition = addXY(editTextPosition, ONE_ONE);\n        editTextWidth = cellWidth(editCellX) - 3;\n        editTextHeight = cellHeight(editCellY) - 3;\n        editTextTextAlign = style.textAlign || DEFAULT_CELL_STYLE.textAlign || 'left';\n        const editKey = editKeys(...editCell);\n        if (editKey !== lastEditKey) {\n            setLastEditKey('');\n            setEditCell(NO_CELL);\n        }\n    }\n\n    const [textX, textY] = editTextPosition;\n    const inputProps = {\n        value: editValue,\n        autoFocus: true,\n        onKeyDown: onInputKeyDown,\n        style: {\n            position: 'absolute',\n            left: textX,\n            top: textY,\n            padding: '0px 4px',\n            width: editTextWidth,\n            height: editTextHeight,\n            outline: 'none',\n            border: 'none',\n            textAlign: editTextTextAlign,\n            color: 'black',\n            fontSize: DEFAULT_CELL_STYLE.fontSize,\n            fontFamily: 'sans-serif',\n        } as InputStyle,\n    };\n\n    const input = props.inputComponent?.(\n        editCellX,\n        editCellY,\n        { ...inputProps, onChange: setEditValue } as SheetInputProps,\n        commitEditingCell\n    );\n\n    let overlayDivClassName = styles.sheetscroll;\n    const overlayDivStyles: React.CSSProperties = {\n        position: 'absolute',\n        width: '100%',\n        height: '100%',\n        top: 0,\n        left: 0,\n        overflow: 'scroll',\n        outline: 0,\n        borderBottom: '1px solid #ddd',\n    };\n    const canvasStyles: React.CSSProperties = {\n        width: canvasWidth,\n        height: canvasHeight,\n        outline: '1px solid #ddd', // find another better solution ?\n    };\n\n    if (sheetStyle.hideScrollBars) {\n        delete canvasStyles['outline'];\n        delete overlayDivStyles['borderBottom'];\n        overlayDivClassName = '';\n    }\n\n    const renderedInside = useMemo(() => props.renderInside?.({ visibleCells, cellLayout, selection, editMode }), [\n        props.renderInside,\n        visibleCells,\n        cellLayout,\n        selection,\n        editMode,\n    ]);\n\n    const renderedOutside = useMemo(() => props.renderOutside?.({ visibleCells, cellLayout, selection, editMode }), [\n        props.renderOutside,\n        visibleCells,\n        cellLayout,\n        selection,\n        editMode,\n    ]);\n\n    // External component API\n    useImperativeHandle(\n        ref,\n        () => ({\n            ...cellLayout,\n            ...clipboardApi,\n            startEditingCell,\n        }),\n        [cellLayout, clipboardApi, startEditingCell]\n    );\n\n    return (\n        <div style={{ position: 'relative', height: '100%', overflow: 'hidden' }}>\n            <canvas style={canvasStyles} ref={canvasRef} />\n            <div\n                ref={overlayRef}\n                {...mouseHandlers}\n                onKeyDown={onGridKeyDown}\n                onFocus={onGridFocus}\n                onBlur={onGridBlur}\n                tabIndex={0}\n                onScroll={onScroll}\n                className={overlayDivClassName}\n                style={overlayDivStyles}\n            >\n                <div\n                    style={{\n                        position: 'absolute',\n                        left: 0,\n                        top: 0,\n                        width: 1,\n                        height: maxScrollY + 2000,\n                        backgroundColor: 'rgba(0,0,0,0.0)',\n                    }}\n                ></div>\n                <div\n                    style={{\n                        position: 'absolute',\n                        left: 0,\n                        top: 0,\n                        width: maxScrollX + 5000,\n                        height: 1,\n                        backgroundColor: 'rgba(0,0,0,0.0)',\n                    }}\n                ></div>\n                {renderedInside ? (\n                    <div\n                        style={{\n                            position: 'sticky',\n                            left: 0,\n                            top: 0,\n                        }}\n                    >\n                        {renderedInside}\n                    </div>\n                ) : null}\n            </div>\n            {renderedOutside ? (\n                <div\n                    style={{\n                        position: 'absolute',\n                        left: 0,\n                        top: 0,\n                        width: '100%',\n                        height: '100%',\n                        pointerEvents: 'none',\n                    }}\n                >\n                    {renderedOutside}\n                </div>\n            ) : null}\n            {editMode &&\n                (input !== undefined ? (\n                    input\n                ) : (\n                    <input\n                        {...inputProps}\n                        type=\"text\"\n                        onFocus={(e) => e.target.select()}\n                        onChange={(e) => setEditValue(e.target.value)}\n                    />\n                ))}\n        </div>\n    );\n});\n\nexport default Sheet;\n","import { useCallback, useMemo } from 'react';\nimport { DEFAULT_COLUMN_HEADER_STYLE, DEFAULT_CELL_STYLE, SIZES } from './constants';\nimport {\n    RowOrColumnPropertyFunction,\n    RowOrColumnPropertyStyledFunction,\n    CellPropertyFunction,\n    CellPropertyStyledFunction,\n    CellContentType,\n    Style,\n} from './types';\n\nexport const useAutoSizeColumn = (\n    rows: number[],\n    displayData: CellPropertyStyledFunction<CellContentType>,\n    cellStyle: CellPropertyFunction<Style>,\n    columnHeaders: RowOrColumnPropertyStyledFunction<CellContentType>,\n    columnHeaderStyle: RowOrColumnPropertyFunction<Style>,\n    canvasWidth: number\n) => {\n    const context = useMemo(() => document.createElement('canvas').getContext('2d'), []);\n\n    const getAutoSizeWidth = useCallback(\n        (x: number) => {\n            if (!context) return 0;\n\n            const getWidth = (cellContent: Exclude<CellContentType, null>, style: Required<Style>) => {\n                context.font = style.weight + ' ' + style.fontSize + 'px ' + style.fontFamily;\n\n                const inlineMargin = style.marginLeft + style.marginRight;\n                if (typeof cellContent === 'string' || typeof cellContent === 'number') {\n                    const { width } = context.measureText(cellContent.toString());\n                    return width + inlineMargin;\n                } else if (typeof cellContent === 'object') {\n                    let maxWidth = 0;\n                    let extraWidth = 0;\n\n                    for (const obj of cellContent.items) {\n                        let width = 0;\n                        if (typeof obj.content === 'string' || typeof obj.content === 'number') {\n                            const { width: w } = context.measureText(obj.content.toString());\n                            width = obj.x + w + inlineMargin;\n                        } else if (obj.width) {\n                            width = obj.width;\n                        }\n\n                        if (obj.horizontalAlign === 'right') {\n                            extraWidth += style.textAlign === 'right' ? width * 2 : width;\n                        } else {\n                            maxWidth = Math.max(maxWidth, width);\n                        }\n                    }\n\n                    return maxWidth + extraWidth;\n                }\n                return 0;\n            };\n\n            let maxWidth = SIZES.minimumWidth;\n\n            const headerStyle = { ...DEFAULT_COLUMN_HEADER_STYLE, ...columnHeaderStyle(x) };\n            const headerContent = columnHeaders(x, headerStyle);\n            if (headerContent) {\n                maxWidth = Math.max(maxWidth, getWidth(headerContent, headerStyle));\n            }\n\n            for (const y of rows) {\n                const style = { ...DEFAULT_CELL_STYLE, ...cellStyle(x, y) };\n                const cellContent = displayData(x, y, style);\n                if (cellContent != null) {\n                    maxWidth = Math.max(maxWidth, getWidth(cellContent, style));\n                }\n            }\n\n            return Math.ceil(Math.min(canvasWidth, maxWidth));\n        },\n        [context, displayData, cellStyle, columnHeaders, columnHeaderStyle]\n    );\n\n    return getAutoSizeWidth;\n};\n","import React from 'react';\nimport { useRef, useState } from 'react';\nimport { SheetBoxHeader } from './SheetBox';\nimport GitIcon from '../assets/git.svg';\n\nfunction Header() {\n    const textAreaRef = useRef(null);\n    const [copySuccess, setCopySuccess] = useState('');\n\n    const copyToClipboard = (e) => {\n        textAreaRef.current.select();\n        document.execCommand('copy');\n        e.target.focus();\n        setCopySuccess('Copied!');\n        setTimeout(() => {\n            setCopySuccess('');\n        }, 1000);\n    };\n\n    return (\n        <div className=\"container blue-bg\" id=\"home\">\n            <div className=\"content flex-row header\">\n                <div className=\"box text-box\">\n                    <div>\n                        <h1>Beautiful and fast spreadsheet component for React</h1>\n                        <p className=\"lightblue-p\">\n                            Sheet Happens is easy to implement and extend.\n                            <br></br>\n                            And it's super fast.\n                        </p>\n                    </div>\n                    <div className=\"lib-box\">\n                        <div className=\"install-box\" onClick={copyToClipboard}>\n                            <input readOnly ref={textAreaRef} value=\"npm install --save sheet-happens\" />\n                            {copySuccess !== '' && <div className=\"copy-success\">{copySuccess}</div>}\n                        </div>\n                        <a\n                            href=\"https://github.com/farseerdev/sheet-happens\"\n                            rel=\"noopener noreferrer\"\n                            className=\"git-box\"\n                            target=\"_blank\"\n                        >\n                            <img src={GitIcon} alt=\"Git\" />\n                            view on github\n                        </a>\n                    </div>\n                </div>\n                <div className=\"box\">\n                    <SheetBoxHeader />\n                </div>\n            </div>\n        </div>\n    );\n}\n\nexport default Header;\n","import React from 'react';\n\nfunction TitleSeparator({ title, id }) {\n    return (\n        <div className=\"title-separator\" id={id ? id : ''}>\n            <p>{title ? title : 'No title'}</p>\n            <div className=\"separator\"></div>\n        </div>\n    );\n}\n\nexport default TitleSeparator;\n","import React from 'react';\n\nfunction Wrap({ children }) {\n    return (\n        <div className=\"container\">\n            <div className=\"content flex-row\">{children}</div>\n        </div>\n    );\n}\n\nexport default Wrap;\n","import React from 'react';\nimport SyntaxHighlighter from 'react-syntax-highlighter';\nimport { xcode } from 'react-syntax-highlighter/dist/esm/styles/hljs';\nxcode.hljs.padding = '10px 20px';\nxcode.hljs.background = '#f8f9fa';\nxcode.hljs.width = '100%';\nxcode.hljs.maxWidth = '100%';\nxcode.hljs.overflow = 'auto';\nxcode.hljs.borderRadius = '3px';\nxcode.hljs.fontSize = '14px';\n\nexport function SourceDisplayDataCode() {\n    let xcode2 = { ...xcode };\n    xcode2.hljs.height = '100%';\n    return (\n        <SyntaxHighlighter language=\"javascript\" style={xcode2}>\n            {`const [data, setData] = useState([[1,2,3], [10,20,30]]);\n    \nconst displayData = (x, y) => {\n    return data?.[y]?.[x]?.toFixed?.(2);\n};\n\nreturn (\n    <div className=\"sheet-box\">\n        <Sheet\n            sourceData={data} // array of arrays of data \n            displayData={displayData} // function example\n        />\n    </div>\n);`}\n        </SyntaxHighlighter>\n    );\n}\n\nexport function InitSheetCode() {\n    return (\n        <SyntaxHighlighter language=\"javascript\" style={xcode}>\n            {`import React, { Component } from 'react'\nimport Sheet from 'sheet-happens'\nimport 'sheet-happens/dist/index.css'\n\nclass Example extends Component {\n  render() {\n    return <Sheet />\n  }\n}`}\n        </SyntaxHighlighter>\n    );\n}\n\nexport function InitSheetWithDataCode() {\n    return (\n        <SyntaxHighlighter language=\"javascript\" style={xcode}>\n            {`const [data, setData] = useState([[1,2,3], [10,20,30]]);\n    \nconst displayData = (x, y) => {\n    return data?.[y]?.[x]?.toFixed?.(2);\n};\n\nreturn (\n    <div className=\"sheet-box\">\n        <Sheet\n            sourceData={data}\n            displayData={displayData}\n        />\n    </div>\n);`}\n        </SyntaxHighlighter>\n    );\n}\n\nexport function EditDataCode() {\n    return (\n        <SyntaxHighlighter language=\"javascript\" style={xcode}>\n            {`...\n\nconst editData = (x, y) => {\n    return data?.[y]?.[x];\n};\n\nconst onChange = (changes) => {\n    const newData = [...data];\n    for (const change of changes) {\n        if (!newData[change.y]) {\n            newData[change.y] = [];\n        }\n        newData[change.y][change.x] = change.value;\n    }\n    setData(newData);\n};\n\nconst isReadOnly = (x, y) => {\n    return false;\n};\n\nreturn (\n    <div className=\"sheet-box\">\n        <Sheet\n            ...\n            sourceData={sourceData}\n            onChange={onChange}\n            readOnly={isReadOnly}\n        />\n    </div>\n);`}\n        </SyntaxHighlighter>\n    );\n}\n\nexport function CellStyleSizeCode() {\n    return (\n        <SyntaxHighlighter language=\"javascript\" style={xcode}>\n            {`...\n\nconst cellStyle = (x, y) => {\n    return { textAlign: 'right' };\n};\n\nconst [cellWidth, setCellWidth] = useState([]);\n\nconst onCellWidthChange = (indices, newWidths) => {\n    setCellWidth((cellWidth) => {\n        const cw = [...cellWidth];\n        for (const [i, order] of indices.entries()) {\n            const idx = getColumnOrder(order);\n            if (idx > cw.length) {\n                for (let i = cw.length; i <= idx; i++) {\n                    cw.push(DEFAULT_CELL_WIDTH);\n                }\n            }\n            cw[idx] = newWidths[i];\n        }\n        return cw;\n    });\n};\n\nreturn (\n    <div className=\"sheet-box\">\n        <Sheet\n            ...\n            cellStyle={cellStyle}\n            cellWidth={cellWidth}\n            onCellWidthChange={onCellWidthChange}\n        />\n    </div>\n);`}\n        </SyntaxHighlighter>\n    );\n}\n","import React from 'react';\n\nfunction Footer() {\n    return (\n        <div className=\"footer\">\n            <p className=\"copy\">\n                made by <a href=\"https://www.farseer.io\">farseer</a>\n            </p>\n        </div>\n    );\n}\n\nexport default Footer;\n","import React from 'react';\nimport './index.css';\n\nimport Menu from './components/Menu';\nimport Header from './components/Header';\nimport TitleSeparator from './components/TitleSeparator';\nimport Wrap from './components/Wrap';\nimport {\n    InitSheetCode,\n    InitSheetWithDataCode,\n    SourceDisplayDataCode,\n    EditDataCode,\n    CellStyleSizeCode,\n} from './components/Code';\nimport {\n    SheetBoxStyle,\n    SheetBoxBasic,\n    SheetBoxRender,\n    SheetBoxGrouped,\n    SheetBoxFormatting,\n    SheetBoxVeryBigData,\n    SheetBoxCustomInput,\n    SheetBoxSourceDisplayData,\n} from './components/SheetBox';\nimport Footer from './components/Footer';\n\nconst App = () => {\n    return (\n        <>\n            <Menu />\n            <Header />\n\n            <TitleSeparator title=\"Get started\" id=\"usage\" />\n            <Wrap>\n                <div className=\"box full-width colored-pre\" style={{ overflowX: 'auto' }}>\n                    <p>Import the component and its style, and render it</p>\n                    <InitSheetCode />\n\n                    <div className=\"spacer\" />\n\n                    <p>Display some data</p>\n                    <InitSheetWithDataCode />\n                </div>\n            </Wrap>\n\n            <TitleSeparator title=\"Learn more about features\" id=\"features\" />\n            <Wrap>\n                <div className=\"box\">\n                    <SheetBoxBasic />\n                </div>\n                <div className=\"box\">\n                    <h3>Basic spreadsheet</h3>\n                    <p>\n                        It has all the features you'd expect from the spreadsheet: keyboard navigation, copy cells by\n                        dragging the small square, copy/paste from and to Excel and Google Sheets, resize and reorder\n                        columns and rows.\n                    </p>\n                </div>\n            </Wrap>\n            <Wrap>\n                <div className=\"box\">\n                    <SheetBoxStyle />\n                </div>\n                <div className=\"box\">\n                    <h3>Styling</h3>\n                    <p>\n                        You can change the cell color, alignment, font weight, margins and more. It's also possible to\n                        freeze first rows or columns, and add clickable images.\n                    </p>\n                </div>\n            </Wrap>\n            <Wrap>\n                <div className=\"box\">\n                    <SheetBoxFormatting />\n                </div>\n                <div className=\"box\">\n                    <h3>Formatting</h3>\n                    <p>\n                        Sheet Happens uses different datasets for display and edit so you can apply different formatting\n                        when displaying the cell and editing the cell.\n                    </p>\n                </div>\n            </Wrap>\n            <Wrap>\n                <div className=\"box\">\n                    <SheetBoxRender />\n                </div>\n                <div className=\"box\">\n                    <h3>Overlays</h3>\n                    <p>You can attach HTML overlays to the sheet, for additional controls, notes, etc.</p>\n                </div>\n            </Wrap>\n            <Wrap>\n                <div className=\"box\">\n                    <SheetBoxGrouped />\n                </div>\n                <div className=\"box\">\n                    <h3>Grouped rows and columns</h3>\n                    <p>You can make rows act as a group for drag-and-drop operation.</p>\n                </div>\n            </Wrap>\n\n            <div className=\"spacer\" />\n\n            <TitleSeparator title=\"Big dataset example\" id=\"big dataset example\" />\n            <Wrap>\n                <div className=\"box full-width\">\n                    <p>\n                        Our Sheet is designed and built with big datasets in mind. No matter the size of your data, it\n                        will be handled blazingly fast and super responsive because component is canvas-based and it\n                        draws only the small chunk of data user sees at the moment.\n                    </p>\n                    <br />\n                    <SheetBoxVeryBigData />\n                </div>\n            </Wrap>\n\n            <div className=\"spacer\" />\n\n            <TitleSeparator title=\"Custom input fields\" id=\"custom input example\" />\n            <Wrap>\n                <div className=\"box\">\n                    <SheetBoxCustomInput />\n                </div>\n                <div className=\"box\">\n                    <h3>Custom input component</h3>\n                    <p>\n                        If basic text input isn't enough, you can send your own React component to be displayed instead.\n                    </p>\n                </div>\n            </Wrap>\n\n            <div className=\"spacer\" />\n\n            <TitleSeparator title=\"Documentation\" id=\"documentation\" />\n            <Wrap>\n                <div className=\"box full-width\">\n                    {/* sourceData displayData */}\n                    <h3>Displaying data</h3>\n                    <p>\n                        If you have some data you want to display, you send it via <Emphased text=\"sourceData\" /> and{' '}\n                        <Emphased text=\"displayData\" /> props.\n                    </p>\n                    <p>\n                        The first one receives unformatted data which is used for data manipulation, and the second one\n                        formatted which is used for displaying in cells.\n                    </p>\n                    <br />\n                    <p>\n                        Each of this can be either array of arrays of values (where each array is representing data for\n                        one row) or function (which returns value based on x and y coordinates that are sent as\n                        arguments to your function).\n                    </p>\n                </div>\n            </Wrap>\n\n            <Wrap>\n                <div className=\"box colored-pre unmargin-pre\" style={{ maxWidth: '100%', overflow: 'auto' }}>\n                    <SourceDisplayDataCode />\n                </div>\n                <div className=\"box\">\n                    <SheetBoxSourceDisplayData />\n                </div>\n            </Wrap>\n\n            <div className=\"spacer\" />\n\n            <Wrap>\n                <div className=\"box\">\n                    {/*editData onChange readOnly */}\n                    <h3>Editing data</h3>\n                    <p>\n                        Same as the previous two, prop <Emphased text=\"editData\" /> can recieve either array of arrays\n                        of values or function for data which will be displayed in edit mode. Edit mode is activated by\n                        double click on the cell.\n                    </p>\n                    <br />\n                    <p>\n                        Once edit is done, function sent in <Emphased text=\"onChange\" /> prop will be called with array\n                        of changes as an argument. Each element of this array has value, x and y coordinates. Use this\n                        information to change values in your data array.\n                    </p>\n                    <br />\n                    <p>\n                        Sheet also accepts <Emphased text=\"readOnly\" /> prop which you can use if some cells should not\n                        be editable. Same as the most of sheet's props, you can send function, array of arrays, or a\n                        single value which then is applied to the whole table.\n                    </p>\n                </div>\n\n                <div className=\"box unmargin-pre\">\n                    <EditDataCode />\n                </div>\n            </Wrap>\n\n            <div className=\"spacer\" />\n\n            <Wrap>\n                <div className=\"box full-width\">\n                    {/* columnHeaders */}\n                    <h3>Column headers</h3>\n                    <p>\n                        By default, sheet has excel-like headers (A, B, C, ...) but you can send yours via{' '}\n                        <Emphased text=\"columnHeaders\" /> prop as an array or function.\n                    </p>\n                </div>\n            </Wrap>\n\n            <div className=\"spacer\" />\n\n            <Wrap>\n                <div className=\"box\">\n                    {/* cellStyle cellWidth cellHeight onCellWidthChange onCellHeightChange */}\n                    <h3>Cell style and width/height</h3>\n                    <p>\n                        Use prop <Emphased text=\"cellStyle\" /> and <Emphased text=\"columnHeaderStyle\" /> for customizing\n                        cells visually.\n                    </p>\n                    <br />\n                    <p>\n                        You can also use <Emphased text=\"cellWidth\" /> and <Emphased text=\"cellHeight\" /> props to\n                        customize cell size. If you send single value {`cellWidth={200}`}, it will be applied to all\n                        cells. If you send array of values {`cellWidth={[200, 80, 80]}`}, they will be applied in\n                        respect to the index number.\n                    </p>\n                    <br />\n                    <p>\n                        There are also <Emphased text=\"onCellWidthChange\" /> and <Emphased text=\"onCellHeightChange\" />{' '}\n                        props for functions which are called when user drags cell for resize. You can use these for\n                        updating your cellWidth/cellHeight arrays.\n                    </p>\n                </div>\n                <div className=\"box unmargin-pre\">\n                    <CellStyleSizeCode />\n                </div>\n            </Wrap>\n\n            <div className=\"spacer\" />\n\n            <Wrap>\n                <div className=\"box full-width\">\n                    {/* onSelectionChanged */}\n                    <h3>Selection</h3>\n                    <p>\n                        You can send a function to the <Emphased text=\"onSelectionChanged\" /> prop. It will be called on\n                        selection change with x1, y1, x2 and y2 arguments.\n                    </p>\n                </div>\n            </Wrap>\n\n            <div className=\"spacer\" />\n\n            <Wrap>\n                <div className=\"box full-width\">\n                    {/* onRightClick */}\n                    <h3>Right click handler</h3>\n                    <p>\n                        If you send a function to <Emphased text=\"onRightClick\" /> prop, it will be called on right\n                        click with whole mouse event (extended with cellX and cellY values) as an argument.\n                    </p>\n                </div>\n            </Wrap>\n\n            <div className=\"spacer\" />\n\n            <Wrap>\n                <div className=\"box full-width\">\n                    {/* freezeColumns freezeRows */}\n                    <h3>Sticky columns/rows</h3>\n                    <p>\n                        Send a number to <Emphased text=\"freezeColumns\" /> and/or <Emphased text=\"freezeRows\" /> to make\n                        first n of columns/rows sticky.\n                    </p>\n                </div>\n            </Wrap>\n\n            <div className=\"spacer\" />\n\n            <Wrap>\n                <div className=\"box full-width\">\n                    {/* inputComponent */}\n                    <h3>Custom input</h3>\n                    <p>\n                        By default edit mode turns the cell into a text edit component. But you can send your custom\n                        input component via <Emphased text=\"inputComponent\" /> props. It will be called with{' '}\n                        <Emphased text=\"x\" />, <Emphased text=\"y\" />, <Emphased text=\"inputProps\" /> and{' '}\n                        <Emphased text=\"commitEditingCell\" /> arguments.\n                    </p>\n                </div>\n            </Wrap>\n\n            <div className=\"spacer\" />\n\n            <Footer />\n        </>\n    );\n};\n\nfunction Emphased({ text }) {\n    return <span className=\"emphased\">{text}</span>;\n}\n\nexport default App;\n","import './index.css';\n\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(<App />, document.getElementById('root'));\n"],"sourceRoot":""}