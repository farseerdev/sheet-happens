{"version":3,"sources":["assets/logo.svg","assets/git.svg","components/Menu.js","components/SheetBox.js","../../src/constants.ts","../../src/util.ts","../../src/coordinate.ts","../../src/group.ts","../../src/props.ts","../../src/mouse.ts","../../src/scroll.ts","../../src/style.ts","../../src/clipboard.ts","../../src/layout.ts","../../src/render.ts","../../src/sheet.tsx","../../src/autosize.ts","components/Header.js","components/TitleSeparator.js","components/Wrap.js","components/Code.js","components/Footer.js","App.js","index.js"],"names":["module","exports","Menu","scrollTo","elId","element","document","getElementById","headerOffset","offsetPosition","window","pageYOffset","getBoundingClientRect","top","behavior","className","src","Logo","alt","onClick","INITIAL_MAX_SCROLL","ORIGIN","ONE_ONE","NO_CELL","NO_SELECTION","NO_SELECTIONS","NO_CLICKABLES","NO_STYLE","MAX_XY","COLORS","SIZES","DEFAULT_CELL_STYLE","textAlign","fontSize","marginRight","marginLeft","color","fontFamily","weight","fillColor","backgroundColor","DEFAULT_COLUMN_HEADER_STYLE","HEADER_ACTIVE_STYLE","HEADER_SELECTED_STYLE","HEADER_GROUP_SELECTED_STYLE","ARROW_KEYS","ArrowRight","ArrowLeft","ArrowUp","ArrowDown","clamp","x","Math","seq","n","s","d","Array","length","isInRange","min","isInRangeLeft","isInRangeCenter","addXY","a","b","subXY","maxXY","minXY","getDirectionStep","direction","isSameXY","forRange","i","callback","forToMap","out","forLoop","map","mapSelectionColumns","selection","normalizeSelection","left","right","forSelectionColumns","mapSelectionRows","bottom","forSelectionRows","isMaybeRowSelection","isMaybeColumnSelection","isRowSelection","isColumnSelection","isEmptySelection","isPointInsideSelection","point","y","anchor","head","scanGroup","limit","index","key","keys","matchKeys","expandSelectionToRowOrColumnGroups","first","second","start","end","startIndex","groupKeys","endIndex","expanded","normalized","to","ax","ay","swapX","swapY","orientSelection","isBoundaryInsideGroup","before","after","createRowOrColumnProp","rowOrColIndex","rowColProp","createCellProp","cellProp","findApproxMaxEditDataIndex","editData","howManyEmpty","growthIncrement","growthIncrementFactor","allEmpty","yy","data","xx","findInDisplayData","p","step","cell","max","Infinity","displayData","firstFilled","cellX","cellY","parseKnobOperation","knobArea","kx1","ky1","kx2","ky2","sx1","sy1","sx2","sy2","fx1","fy1","fx2","fy2","changes","srcY","value","sourceData","cellReadOnly","source","srcX","getViewExtent","cellToAbsolute","cellLayout","absoluteToColumn","columnToAbsolute","absoluteToRow","rowToAbsolute","getIndentX","getIndentY","offset","w","view","h","freeze","frozenX","frozenY","scrollW","scrollH","leftEdge","topEdge","edge","viewport","resolveCellStyle","optionalStyle","applyAlignment","alignment","style","cellSize","imageWidth","formatSelectionAsTSV","minX","minY","maxX","maxY","rows","row","formatTSV","parsePastedHtml","div","html","tableNode","findTable","child","maybeTable","tableChild","tr","td","str","isReadOnly","parsePastedText","text","cols","X","Y","makeLayoutCache","sizer","offsets","makeIntMap","sizes","version","getSize","size","getOffset","j","getStart","getEnd","getVersion","lookupIndex","last","mid","setSizer","clearAfter","initialSize","allocate","newUsed","Uint8Array","newValues","Uint32Array","copy","used","values","from","truncate","l","set","grow","ensure","get","has","tail","renderCell","clickables","cellContent","finalStyle","context","yCoord","cellHeight","xCoord","cellWidth","obj","finalX","measure","rect","resolveSelection","cellToPixel","rowSelectionActive","columnSelectionActive","resolveFrozenSelection","freezeX","freezeY","indentX","indent","indentY","offsetX","offsetY","hideKnob","lastInvisibleX","lastInvisibleY","resizeCanvas","canvas","width","height","devicePixelRatio","ratio","newCanvasWidth","newCanvasHeight","excelHeaderString","num","t","String","halfShadowGradient","gradient","hex","adjust","f","rgb","opacity","forwardRef","canvasRef","useRef","overlayRef","useState","maxScroll","setMaxScroll","dataOffset","setDataOffset","selectionProp","props","setSelection","setKnobArea","dragOffset","setDragOffset","dragIndices","setDragIndices","dropTarget","setDropTarget","editCell","setEditCell","lastSelectionProp","setLastSelectionProp","editValue","setEditValue","arrowKeyCommitMode","setArrowKeyCommitMode","useResizeObserver","ref","canvasWidth","canvasHeight","useMemo","columnHeaders","columnHeaderStyle","canSizeColumn","canSizeRow","canOrderColumn","canOrderRow","rowGroupKeys","columnGroupKeys","editKeys","cellStyle","sheetStyle","freezeColumns","freezeRows","hideColumnHeaders","hideRowHeaders","hideGridlines","hideScrollBars","columnHeaderHeight","rowHeaderWidth","shadowBlur","shadowOpacity","shadowColor","resolveSheetStyle","secondarySelections","selectedColumnGroups","Set","selectedRowGroups","maxScrollX","maxScrollY","editCellX","editCellY","editMode","shouldCacheLayout","layoutVersion","columnLayout","rowLayout","getBaseOriginFor","columnToPixel","column","base","relative","columns","rowToPixel","anchorX","anchorY","pixelToIndex","pixel","layout","pixelToColumn","pixelX","pixelToRow","pixelY","absoluteToIndex","getVisibleIndices","indices","frozen","notFrozen","pixelToCell","absoluteToCell","getVisibleCells","viewX","viewY","makeCellLayout","visibleCells","useLayoutEffect","scrollToSelection","toHead","overlay","current","newX","newY","newOffset","scroll","nudgeX","nudgeY","setTimeout","scrollX","scrollY","scrollToCell","changeSelection","newSelection","a1","a2","b1","b2","isSameSelection","validateSelection","commitEditingCell","startEditingCell","editDataValue","val","setLastEditKey","maxColumns","maxRows","maxCells","rightEdge","bottomEdge","remainder","clipDataOffset","hitmapRef","textAreaRef","textArea","v","activeTagName","preventScroll","useClipboardCopy","useEffect","onPaste","e","clipboardData","types","pastedHtml","parsed","onChange","onSelectionChange","useClipboardPaste","onScroll","useCallback","xy","onOffsetChange","growX","growY","onMaxScrollChange","useScroll","getAutoSizeWidth","getWidth","inlineMargin","maxWidth","extraWidth","headerContent","headerStyle","useAutoSizeColumn","hitTarget","setHitTarget","columnResize","setColumnResize","rowResize","setRowResize","columnDrag","setColumnDrag","rowDrag","setRowDrag","draggingKnob","setDraggingKnob","draggingSelection","setDraggingSelection","draggingRowSelection","setDraggingRowSelection","draggingColumnSelection","setDraggingColumnSelection","knobPosition","isCellSelection","refState","getMousePosition","getScrollPosition","target","scrollLeft","scrollTop","getMouseHit","hitmap","object","onPointerLeave","onPointerDown","selectedColumns","selectedRows","connected","dragStart","dragEnd","onDragOffsetChange","onDragIndicesChange","asGroup","knobX","knobY","onKnobAreaChange","onCommit","onPointerUp","onDropTargetChange","insideSelection","insideGroup","preceding","order","dontChangeSelectionOnOrderChange","onColumnOrderChange","onInvalidateColumn","onRowOrderChange","onInvalidateRow","JSON","onPointerMove","currentScroll","newWidth","onCellWidthChange","newHeight","onCellHeightChange","headX","headY","xCellDiff","yCellDiff","shift","onDoubleClick","autosized","onEdit","onContextMenu","event","onRightClick","mouseHandlers","useMouse","animationFrameId","selectionActive","selected","gridRight","gridBottom","drawGridLineX","drawGridLineY","content","isActive","groupKey","isInRowGroup","isInColumnGroup","selectedStyle","activeStyle","secondarySelection","shiftX","shiftY","dragColumns","dragRows","hasRowShadow","hasColumnShadow","renderSheet","lastEditKey","editTextPosition","editTextWidth","editTextHeight","editTextTextAlign","textX","textY","inputProps","autoFocus","onKeyDown","position","padding","outline","border","input","overlayDivClassName","styles","overlayDivStyles","overflow","borderBottom","canvasStyles","renderedInside","renderedOutside","useImperativeHandle","pointerEvents","autoComplete","autoCorrect","autoCapitalize","spellCheck","onFocus","tabIndex","x1","y1","x2","y2","type","initialDataBig","r","col","push","initialDataBasic","initialDataFormatting","random","triangleDown","Image","useWidthHeightControl","initialWidths","initialHeights","getColumnOrder","getRowOrder","setCellWidth","setCellHeight","cw","idx","ch","useOrderControl","initialColumns","initialRows","columnOrder","setColumnOrder","rowOrder","setRowOrder","co","reduce","splice","ro","SheetBoxHeader","setData","onSelectionChanged","newData","change","cx","cy","readOnly","cacheLayout","SheetBoxBasic","parse","stringify","faCheck","SheetBoxStyle","colors","items","horizontalAlign","console","log","undefined","incrementCell","SheetBoxFormatting","toFixed","Number","SheetBoxRender","renderInside","noteOpen","includes","marker","borderTop","borderLeft","note","background","stopPropagation","SheetBoxGrouped","orderedGroupKeys","_","alternatingGroups","list","at","bit","SheetBoxVeryBigData","loadingStatus","setLoadingStatus","href","preventDefault","fetch","then","response","json","dataset","toString","padStart","g","customInputOptions","customInputOptions2","customInputData","SheetBoxCustomInput","inputComponent","CustomInput","boxShadow","opt","CustomOption","clickHandler","hover","setHover","onMouseEnter","onMouseLeave","cursor","SheetBoxSourceDisplayData","Header","copySuccess","setCopySuccess","id","select","execCommand","focus","rel","GitIcon","TitleSeparator","title","Wrap","children","xcode","hljs","borderRadius","SourceDisplayDataCode","xcode2","language","InitSheetCode","InitSheetWithDataCode","EditDataCode","CellStyleSizeCode","Footer","Emphased","App","overflowX","ReactDOM","render"],"mappings":"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","file":"static/js/main.aa913741.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/logo.aef13910.svg\";","module.exports = __webpack_public_path__ + \"static/media/git.f818b886.svg\";","import React from 'react';\nimport Logo from '../assets/logo.svg';\n\nfunction Menu() {\n    const scrollTo = (elId) => {\n        var element = document.getElementById(elId);\n        var headerOffset = elId === 'home' ? 0 : 86;\n        var elementPosition = window.pageYOffset + element.getBoundingClientRect().top;\n        var offsetPosition = elementPosition - headerOffset;\n\n        window.scrollTo({\n            top: offsetPosition,\n            behavior: 'smooth',\n        });\n    };\n\n    return (\n        <div className=\"container blue-bg menu\">\n            <div className=\"content flex-row\">\n                <div className=\"logo-box\">\n                    <img src={Logo} alt=\"Logo\" />\n                    <h2 className=\"page-title\">sheet - happens</h2>\n                </div>\n                <div className=\"nav\">\n                    <div className=\"nav-item\" onClick={() => scrollTo('home')}>\n                        home\n                    </div>\n                    <div className=\"nav-item\" onClick={() => scrollTo('usage')}>\n                        usage\n                    </div>\n                    <div className=\"nav-item\" onClick={() => scrollTo('features')}>\n                        features\n                    </div>\n                    <div className=\"nav-item\" onClick={() => scrollTo('documentation')}>\n                        documentation\n                    </div>\n                </div>\n            </div>\n        </div>\n    );\n}\n\nexport default Menu;\n","import React, { useState } from 'react';\nimport Sheet from 'sheet-happens';\nimport 'sheet-happens/dist/index.css';\n\nconst initialDataBig = [];\nfor (let row = 0; row < 1000; row++) {\n    const r = [];\n    for (let col = 0; col < 100; col++) {\n        r.push(`Row: ${row}, Col: ${col}`);\n    }\n    initialDataBig.push(r);\n}\n\nconst initialDataBasic = [\n    ['First', 'Second', 'Third', 'Fourth', 'Fifth', 'Sixth'],\n    [1, 2, 3, 4, 5, 6],\n    [1, 2, 3, 4, 5, 6],\n    [1, 2, 3, 4, 5, 6],\n    [1, 2, 3, 4, 5, 6],\n    [1, 2, 3, 4, 5, 6],\n    [1, 2, 3, 4, 5, 6],\n    [1, 2, 3, 4, 5, 6],\n    [1, 2, 3, 4, 5, 6],\n];\n\nconst initialDataFormatting = [];\nfor (let row = 0; row < 1000; row++) {\n    const r = [];\n    for (let col = 0; col < 100; col++) {\n        r.push(Math.random() * 1000000);\n    }\n    initialDataFormatting.push(r);\n}\n\nconst triangleDown = new Image();\ntriangleDown.src =\n    'data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgd2lkdGg9IjEwMCIgaGVpZ2h0PSIxMDAiDQoJIHZpZXdCb3g9IjAgMCAxMDAgMTAwIiBvdmVyZmxvdz0idmlzaWJsZSIgPg0KPHBvbHlnb24gcG9pbnRzPSIwLDAgMTAwLDAgNTAsMTAwIiBzdHlsZT0iZmlsbDojOTk5OTk5OyIvPg0KPC9zdmc+DQo=';\ntriangleDown.width = 10;\ntriangleDown.height = 10;\n\nexport const DEFAULT_CELL_WIDTH = 100;\nexport const DEFAULT_CELL_HEIGHT = 22;\n\nexport function useWidthHeightControl(\n    initialWidths = [],\n    initialHeights = [],\n    getColumnOrder = (i: number) => i,\n    getRowOrder = (i: number) => i\n) {\n    const [cellWidth, setCellWidth] = useState(initialWidths);\n    const [cellHeight, setCellHeight] = useState(initialHeights);\n\n    const onCellWidthChange = (indices, newWidth) => {\n        setCellWidth((cellWidth) => {\n            const cw = [...cellWidth];\n            for (const order of indices) {\n                const idx = getColumnOrder(order);\n                if (idx > cw.length) {\n                    for (let i = cw.length; i <= idx; i++) {\n                        cw.push(DEFAULT_CELL_WIDTH);\n                    }\n                }\n                cw[idx] = newWidth;\n            }\n            return cw;\n        });\n    };\n\n    const onCellHeightChange = (indices, newHeight) => {\n        setCellHeight((cellHeight) => {\n            const ch = [...cellHeight];\n            for (const order of indices) {\n                const idx = getRowOrder(order);\n                if (idx > ch.length) {\n                    for (let i = ch.length; i <= idx; i++) {\n                        ch.push(DEFAULT_CELL_HEIGHT);\n                    }\n                }\n                ch[idx] = newHeight;\n            }\n        });\n    };\n\n    const cw = (x: number) => cellWidth[getColumnOrder(x)] ?? DEFAULT_CELL_WIDTH;\n    const ch = (y: number) => cellHeight[getRowOrder(y)] ?? DEFAULT_CELL_HEIGHT;\n\n    return { onCellWidthChange, onCellHeightChange, cellWidth: cw, cellHeight: ch };\n}\n\nexport function useOrderControl(initialColumns = [], initialRows = []) {\n    const [columnOrder, setColumnOrder] = useState(initialColumns);\n    const [rowOrder, setRowOrder] = useState(initialRows);\n\n    const getColumnOrder = (x: number) => columnOrder[x] ?? x;\n    const getRowOrder = (y: number) => rowOrder[y] ?? y;\n\n    const onColumnOrderChange = (indices: number[], order: number) => {\n        const co = [...columnOrder];\n\n        // Extend column order to cover operation\n        const n = Math.max(order + indices.length, order + indices.reduce((a, b) => Math.max(a, b), 0));\n        while (co.length < n) co.push(co.length);\n\n        // Remove old columns one by one (indices may be disjoint but are always increasing)\n        for (let i = 0; i < indices.length; ++i) co.splice(indices[i] - i, 1);\n\n        // Splice in new indices mapped to old order\n        co.splice(order, 0, ...indices.map((i) => columnOrder[i] ?? i));\n\n        setColumnOrder(co);\n    };\n\n    const onRowOrderChange = (indices: number[], order: number) => {\n        const ro = [...rowOrder];\n\n        // Extend row order to cover operation\n        const n = Math.max(order + indices.length, order + indices.reduce((a, b) => Math.max(a, b), 0));\n\n        while (ro.length < n) ro.push(ro.length);\n\n        // Remove old rows one by one (indices may be disjoint but are always increasing)\n        for (let i = 0; i < indices.length; ++i) ro.splice(indices[i] - i, 1);\n\n        // Splice in new indices mapped to old order\n        ro.splice(order, 0, ...indices.map((i) => rowOrder[i] ?? i));\n\n        setRowOrder(ro);\n    };\n\n    return { getColumnOrder, getRowOrder, onColumnOrderChange, onRowOrderChange };\n}\n\nexport function SheetBoxHeader() {\n    const [data, setData] = useState(initialDataBig);\n\n    const { onColumnOrderChange, onRowOrderChange, getColumnOrder, getRowOrder } = useOrderControl();\n    const { onCellWidthChange, onCellHeightChange, cellWidth, cellHeight } = useWidthHeightControl(\n        [],\n        [],\n        getColumnOrder,\n        getRowOrder\n    );\n\n    const onSelectionChanged = (x1, y1, x2, y2) => {};\n    const onRightClick = () => {};\n    const columnHeaders = ['A', 'B', 'C'];\n    const cellStyle = (x, y) => {\n        return {};\n    };\n\n    const editData = (x, y) => {\n        return data?.[getRowOrder(y)]?.[getColumnOrder(x)];\n    };\n    const displayData = (x, y) => {\n        return data?.[getRowOrder(y)]?.[getColumnOrder(x)];\n    };\n    const sourceData = (x, y) => {\n        return data?.[getRowOrder(y)]?.[getColumnOrder(x)];\n    };\n    const editKeys = (x, y) => {\n        return `${x},${y}`;\n    };\n\n    const onChange = (changes) => {\n        const newData = [...data];\n        for (const change of changes) {\n            const cx = getColumnOrder(change.x);\n            const cy = getRowOrder(change.y);\n            if (!newData[cy]) {\n                newData[cy] = [];\n            }\n            newData[cy][cx] = change.value;\n        }\n        setData(newData);\n    };\n\n    const isReadOnly = (x, y) => {\n        return false;\n    };\n\n    return (\n        <div className=\"sheet-box\">\n            <Sheet\n                onSelectionChanged={onSelectionChanged}\n                onRightClick={onRightClick}\n                columnHeaders={columnHeaders}\n                cellStyle={cellStyle}\n                editData={editData}\n                displayData={displayData}\n                sourceData={sourceData}\n                cellWidth={cellWidth}\n                cellHeight={cellHeight}\n                onChange={onChange}\n                readOnly={isReadOnly}\n                onCellWidthChange={onCellWidthChange}\n                onCellHeightChange={onCellHeightChange}\n                onColumnOrderChange={onColumnOrderChange}\n                onRowOrderChange={onRowOrderChange}\n                editKeys={editKeys}\n                cacheLayout\n            />\n        </div>\n    );\n}\n\nexport function SheetBoxBasic() {\n    const [data, setData] = useState(JSON.parse(JSON.stringify(initialDataBasic)));\n    const { onColumnOrderChange, onRowOrderChange, getColumnOrder, getRowOrder } = useOrderControl();\n    const { onCellWidthChange, onCellHeightChange, cellWidth, cellHeight } = useWidthHeightControl(\n        [],\n        [],\n        getColumnOrder,\n        getRowOrder\n    );\n\n    const onSelectionChanged = (x1, y1, x2, y2) => {};\n    const onRightClick = () => {};\n    const columnHeaders = ['A', 'B', 'C'];\n    const cellStyle = (x, y) => {\n        return {};\n    };\n\n    const editData = (x, y) => {\n        return data?.[getRowOrder(y)]?.[getColumnOrder(x)];\n    };\n    const displayData = (x, y) => {\n        return data?.[getRowOrder(y)]?.[getColumnOrder(x)];\n    };\n    const sourceData = (x, y) => {\n        return data?.[getRowOrder(y)]?.[getColumnOrder(x)];\n    };\n\n    const onChange = (changes) => {\n        const newData = [...data];\n        for (const change of changes) {\n            const cx = getColumnOrder(change.x);\n            const cy = getRowOrder(change.y);\n            if (!newData[cy]) {\n                newData[cy] = [];\n            }\n            newData[cy][cx] = change.value;\n        }\n        setData(newData);\n    };\n\n    const isReadOnly = (x, y) => {\n        return false;\n    };\n\n    return (\n        <div className=\"sheet-box\">\n            <Sheet\n                onSelectionChanged={onSelectionChanged}\n                onRightClick={onRightClick}\n                columnHeaders={columnHeaders}\n                cellStyle={cellStyle}\n                editData={editData}\n                displayData={displayData}\n                sourceData={sourceData}\n                cellWidth={cellWidth}\n                cellHeight={cellHeight}\n                onChange={onChange}\n                readOnly={isReadOnly}\n                onCellWidthChange={onCellWidthChange}\n                onCellHeightChange={onCellHeightChange}\n                onColumnOrderChange={onColumnOrderChange}\n                onRowOrderChange={onRowOrderChange}\n                cacheLayout\n            />\n        </div>\n    );\n}\n\nconst faCheck = new Image();\nfaCheck.src =\n    'data:image/svg+xml;base64,PHN2ZyBhcmlhLWhpZGRlbj0idHJ1ZSIgZm9jdXNhYmxlPSJmYWxzZSIgZGF0YS1wcmVmaXg9ImZhcyIgZGF0YS1pY29uPSJjaGVjay1jaXJjbGUiIGNsYXNzPSJzdmctaW5saW5lLS1mYSBmYS1jaGVjay1jaXJjbGUgZmEtdy0xNiIgcm9sZT0iaW1nIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1MTIgNTEyIj48cGF0aCBmaWxsPSIjMGFkNjZiIiBkPSJNNTA0IDI1NmMwIDEzNi45NjctMTExLjAzMyAyNDgtMjQ4IDI0OFM4IDM5Mi45NjcgOCAyNTYgMTE5LjAzMyA4IDI1NiA4czI0OCAxMTEuMDMzIDI0OCAyNDh6TTIyNy4zMTQgMzg3LjMxNGwxODQtMTg0YzYuMjQ4LTYuMjQ4IDYuMjQ4LTE2LjM3OSAwLTIyLjYyN2wtMjIuNjI3LTIyLjYyN2MtNi4yNDgtNi4yNDktMTYuMzc5LTYuMjQ5LTIyLjYyOCAwTDIxNiAzMDguMTE4bC03MC4wNTktNzAuMDU5Yy02LjI0OC02LjI0OC0xNi4zNzktNi4yNDgtMjIuNjI4IDBsLTIyLjYyNyAyMi42MjdjLTYuMjQ4IDYuMjQ4LTYuMjQ4IDE2LjM3OSAwIDIyLjYyN2wxMDQgMTA0YzYuMjQ5IDYuMjQ5IDE2LjM3OSA2LjI0OSAyMi42MjguMDAxeiI+PC9wYXRoPjwvc3ZnPg==';\nfaCheck.width = 16;\nfaCheck.height = 16;\n\nexport function SheetBoxStyle() {\n    const [data, setData] = useState(JSON.parse(JSON.stringify(initialDataBasic)));\n    const { onCellWidthChange, onCellHeightChange, cellWidth, cellHeight } = useWidthHeightControl();\n\n    const onSelectionChanged = (x1, y1, x2, y2) => {};\n    const onRightClick = () => {};\n    const columnHeaders = (index) => {\n        if (index === 0) {\n            return {\n                items: [\n                    {\n                        content: 'A',\n                        x: 0,\n                        y: 0,\n                        horizontalAlign: 'center',\n                    },\n                    {\n                        content: triangleDown,\n                        x: 0,\n                        y: -6,\n                        width: 12,\n                        height: 12,\n                        horizontalAlign: 'right',\n                        onClick: () => {\n                            console.log('click');\n                        },\n                    },\n                ],\n            };\n        } else {\n            return null;\n        }\n    };\n    const colors = ['#f00', '#0f0', '#00f', '#000'];\n    const alignment = ['left', 'right', 'center'];\n    const weight = ['normal', 'bold', 'lighter'];\n    const marginRight = [0, 0, 0, 0, 20];\n    const cellStyle = (x, y) => {\n        if (x === 0 || y === 0) {\n            return {\n                fillColor: '#6DA2FB22',\n                marginRight: 10,\n            };\n        }\n        return {\n            color: colors[y % 4],\n            textAlign: alignment[x % 3],\n            marginRight: marginRight[x % 5],\n            weight: weight[y % 3],\n        };\n    };\n    const editData = (x, y) => {\n        return data?.[y]?.[x];\n    };\n    const incrementCell = (x, y) => {\n        const newData = [...data];\n        if (newData[y] && newData[y][x] !== undefined) {\n            newData[y][x] += 1;\n        }\n        setData(newData);\n    };\n    const displayData = (x, y) => {\n        if (x === 0 && y > 0 && y < 9) {\n            return {\n                items: [\n                    {\n                        content: faCheck,\n                        x: 0,\n                        y: -8,\n                        width: 16,\n                        height: 16,\n                        horizontalAlign: 'right',\n                        onClick: () => {\n                            incrementCell(x, y);\n                        },\n                    },\n                    {\n                        content: data?.[y]?.[x],\n                        x: 0,\n                        y: 0,\n                        horizontalAlign: 'left',\n                    },\n                ],\n            };\n        }\n        return data?.[y]?.[x];\n    };\n    const sourceData = (x, y) => {\n        return data?.[y]?.[x];\n    };\n    const onChange = (changes) => {\n        const newData = [...data];\n        for (const change of changes) {\n            if (!newData[change.y]) {\n                newData[change.y] = [];\n            }\n            newData[change.y][change.x] = change.value;\n        }\n        setData(newData);\n    };\n\n    const isReadOnly = (x, y) => {\n        return false;\n    };\n\n    return (\n        <div className=\"sheet-box\">\n            <Sheet\n                onSelectionChanged={onSelectionChanged}\n                onRightClick={onRightClick}\n                columnHeaders={columnHeaders}\n                cellStyle={cellStyle}\n                editData={editData}\n                displayData={displayData}\n                sourceData={sourceData}\n                cellWidth={cellWidth}\n                cellHeight={cellHeight}\n                onChange={onChange}\n                readOnly={isReadOnly}\n                onCellWidthChange={onCellWidthChange}\n                onCellHeightChange={onCellHeightChange}\n                sheetStyle={{\n                    freezeColumns: 1,\n                    freezeRows: 1,\n                }}\n                cacheLayout\n            />\n        </div>\n    );\n}\n\nexport function SheetBoxFormatting() {\n    const [data, setData] = useState(initialDataFormatting);\n    const { onCellWidthChange, onCellHeightChange, cellWidth, cellHeight } = useWidthHeightControl();\n\n    const cellStyle = (x, y) => {\n        return {};\n    };\n    const editData = (x, y) => {\n        return data?.[y]?.[x];\n    };\n    const displayData = (x, y) => {\n        return data?.[y]?.[x]?.toFixed?.(2);\n    };\n    const sourceData = (x, y) => {\n        return data?.[y]?.[x];\n    };\n\n    const onChange = (changes) => {\n        const newData = [...data];\n        for (const change of changes) {\n            if (!newData[change.y]) {\n                newData[change.y] = [];\n            }\n            newData[change.y][change.x] = Number(change.value);\n        }\n        setData(newData);\n    };\n\n    const isReadOnly = (x, y) => {\n        return false;\n    };\n\n    return (\n        <div className=\"sheet-box\">\n            <Sheet\n                cellStyle={cellStyle}\n                editData={editData}\n                displayData={displayData}\n                sourceData={sourceData}\n                cellWidth={cellWidth}\n                cellHeight={cellHeight}\n                onChange={onChange}\n                readOnly={isReadOnly}\n                onCellWidthChange={onCellWidthChange}\n                onCellHeightChange={onCellHeightChange}\n                cacheLayout\n            />\n        </div>\n    );\n}\n\nexport function SheetBoxRender() {\n    const [data, setData] = useState(JSON.parse(JSON.stringify(initialDataBasic)));\n    const { onCellWidthChange, onCellHeightChange, cellWidth, cellHeight } = useWidthHeightControl();\n\n    const onSelectionChanged = (x1, y1, x2, y2) => {};\n    const onRightClick = () => {};\n    const columnHeaders = ['A', 'B', 'C'];\n    const cellStyle = (x, y) => {\n        return {};\n    };\n\n    const editData = (x, y) => {\n        return data?.[y]?.[x];\n    };\n    const displayData = (x, y) => {\n        return data?.[y]?.[x];\n    };\n    const sourceData = (x, y) => {\n        return data?.[y]?.[x];\n    };\n\n    const onChange = (changes) => {\n        const newData = [...data];\n        for (const { x, y, value } of changes) {\n            if (!newData[y]) {\n                newData[y] = [];\n            }\n            newData[y][x] = value;\n        }\n        setData(newData);\n    };\n\n    const isReadOnly = (x, y) => {\n        return false;\n    };\n\n    const render = ({ visibleCells, cellLayout, selection, editMode }) => {\n        if (editMode) return;\n\n        const cell = [1, 2];\n        const [anchor] = selection;\n        const noteOpen = anchor[0] === cell[0] && anchor[1] === cell[1];\n\n        const isCellVisible = visibleCells.columns.includes(cell[0]) && visibleCells.rows.includes(cell[1]);\n        if (!isCellVisible) return null;\n\n        const [, top] = cellLayout.cellToPixel(cell, [0, 0]);\n        const [right] = cellLayout.cellToPixel(cell, [1, 1]);\n\n        const marker = (\n            <div\n                style={{\n                    position: 'absolute',\n                    left: right,\n                    top: top,\n                    marginLeft: '-12px',\n                    borderTop: '12px solid blue',\n                    borderLeft: '12px solid transparent',\n                    pointerEvents: 'none',\n                }}\n            />\n        );\n\n        const note = noteOpen ? (\n            <div\n                style={{\n                    position: 'absolute',\n                    left: right,\n                    top,\n                    padding: 10,\n                    background: '#fff',\n                    border: '1px solid #ccc',\n                }}\n            >\n                Hello world\n            </div>\n        ) : null;\n\n        return (\n            <div onPointerDown={(e: any) => e.stopPropagation()}>\n                {note}\n                {marker}\n            </div>\n        );\n    };\n\n    return (\n        <div className=\"sheet-box\">\n            <Sheet\n                selection={[\n                    [1, 2],\n                    [1, 2],\n                ]}\n                onSelectionChanged={onSelectionChanged}\n                onRightClick={onRightClick}\n                columnHeaders={columnHeaders}\n                cellStyle={cellStyle}\n                editData={editData}\n                displayData={displayData}\n                sourceData={sourceData}\n                cellWidth={cellWidth}\n                cellHeight={cellHeight}\n                onChange={onChange}\n                readOnly={isReadOnly}\n                onCellWidthChange={onCellWidthChange}\n                onCellHeightChange={onCellHeightChange}\n                renderInside={render}\n                cacheLayout\n            />\n        </div>\n    );\n}\n\nexport function SheetBoxGrouped() {\n    const [data, setData] = useState(initialDataBig);\n\n    const { onColumnOrderChange, onRowOrderChange, getColumnOrder, getRowOrder } = useOrderControl();\n    const { onCellWidthChange, onCellHeightChange, cellWidth, cellHeight } = useWidthHeightControl(\n        [],\n        [],\n        getColumnOrder,\n        getRowOrder\n    );\n\n    const groupKeys = [1, 1, 1, 2, 2, 2, 3, 3, 4, 4, 5, 6, 6, 7, 8, 8];\n    const orderedGroupKeys = groupKeys.map((_, i) => groupKeys[getRowOrder(i)]);\n\n    const alternatingGroups = orderedGroupKeys\n        .map((key, i) => key !== orderedGroupKeys[i - 1])\n        .reduce((list, start) => {\n            const last = list.at(-1) ?? 1;\n            const bit = start ? 1 - last : last;\n            list.push(bit);\n            return list;\n        }, []);\n\n    const onSelectionChanged = (x1, y1, x2, y2) => {};\n    const onRightClick = () => {};\n    const columnHeaders = ['A', 'B', 'C'];\n    const cellStyle = (x, y) => {\n        return {\n            fillColor: ['#ffffff', '#e0e0e0'][alternatingGroups[y]],\n        };\n    };\n\n    const rowGroupKeys = (y) => {\n        return orderedGroupKeys[y];\n    };\n\n    const editData = (x, y) => {\n        return data?.[getRowOrder(y)]?.[getColumnOrder(x)];\n    };\n    const displayData = (x, y) => {\n        return data?.[getRowOrder(y)]?.[getColumnOrder(x)];\n    };\n    const sourceData = (x, y) => {\n        return data?.[getRowOrder(y)]?.[getColumnOrder(x)];\n    };\n    const editKeys = (x, y) => {\n        return `${x},${y}`;\n    };\n\n    const onChange = (changes) => {\n        const newData = [...data];\n        for (const change of changes) {\n            const cx = getColumnOrder(change.x);\n            const cy = getRowOrder(change.y);\n            if (!newData[cy]) {\n                newData[cy] = [];\n            }\n            newData[cy][cx] = change.value;\n        }\n        setData(newData);\n    };\n\n    const isReadOnly = (x, y) => {\n        return false;\n    };\n\n    return (\n        <div className=\"sheet-box\">\n            <Sheet\n                onSelectionChanged={onSelectionChanged}\n                onRightClick={onRightClick}\n                columnHeaders={columnHeaders}\n                cellStyle={cellStyle}\n                editData={editData}\n                displayData={displayData}\n                sourceData={sourceData}\n                cellWidth={cellWidth}\n                cellHeight={cellHeight}\n                onChange={onChange}\n                readOnly={isReadOnly}\n                onCellWidthChange={onCellWidthChange}\n                onCellHeightChange={onCellHeightChange}\n                onColumnOrderChange={onColumnOrderChange}\n                onRowOrderChange={onRowOrderChange}\n                rowGroupKeys={rowGroupKeys}\n                editKeys={editKeys}\n                cacheLayout\n            />\n        </div>\n    );\n}\n\nexport function SheetBoxVeryBigData() {\n    const [loadingStatus, setLoadingStatus] = useState('initial');\n    const [data, setData] = useState([]);\n    const { onCellWidthChange, onCellHeightChange, cellWidth, cellHeight } = useWidthHeightControl();\n\n    const loadClick = (e) => {\n        e.preventDefault();\n        setLoadingStatus('loading');\n        fetch('./out.json')\n            .then((response) => {\n                return response.json();\n            })\n            .then((dataset) => {\n                setData(dataset);\n                setLoadingStatus('done');\n            });\n    };\n\n    const cellStyle = (x, y) => {\n        if (y === 0) {\n            return {\n                weight: 'bold',\n                fontSize: 14,\n            };\n        }\n        if (x === 4) {\n            return {\n                textAlign: 'right',\n            };\n        } else if (x === 1) {\n            return {\n                weight: 'bold',\n                color: '#3b85ff',\n            };\n        } else if (x === 2) {\n            return {\n                color: '#fc3bff',\n            };\n        }\n        return {};\n    };\n    const editData = (x, y) => {\n        return data?.[y]?.[x];\n    };\n    const displayData = (x, y) => {\n        if (x === 4 && y > 0) {\n            if (data && data[y] && data[y][x]) {\n                return Number(data[y][x]).toFixed(2);\n            } else {\n                return '';\n            }\n        }\n        return data?.[y]?.[x];\n    };\n    const sourceData = (x, y) => {\n        return data?.[y]?.[x];\n    };\n\n    const onChange = (changes) => {\n        const newData = [...data];\n        for (const change of changes) {\n            if (!newData[change.y]) {\n                newData[change.y] = [];\n            }\n            newData[change.y][change.x] = change.value;\n        }\n        setData(newData);\n    };\n\n    const isReadOnly = (x, y) => {\n        return false;\n    };\n\n    const headerStyle = (index) => {\n        const r = ((index * 2421) % 255).toString(16).padStart(2, '0');\n        const g = ((index * 3215) % 255).toString(16).padStart(2, '0');\n        const b = ((index * 1243) % 255).toString(16).padStart(2, '0');\n        const color = `#${r}${g}${b}55`;\n        return {\n            backgroundColor: color,\n        };\n    };\n\n    const columnHeaders = (index) => {\n        return '' + index;\n    };\n\n    return (\n        <>\n            {loadingStatus === 'initial' ? (\n                // eslint-disable-next-line jsx-a11y/anchor-is-valid\n                <a href=\"#\" onClick={loadClick}>\n                    Load global database of power plants\n                </a>\n            ) : loadingStatus === 'loading' ? (\n                'Loading...'\n            ) : null}\n            <div className=\"sheet-box\">\n                <Sheet\n                    cellStyle={cellStyle}\n                    editData={editData}\n                    displayData={displayData}\n                    sourceData={sourceData}\n                    cellWidth={cellWidth}\n                    cellHeight={cellHeight}\n                    onChange={onChange}\n                    readOnly={isReadOnly}\n                    onCellWidthChange={onCellWidthChange}\n                    onCellHeightChange={onCellHeightChange}\n                    columnHeaderStyle={headerStyle}\n                    columnHeaders={columnHeaders}\n                    sheetStyle={{\n                        freezeColumns: 0,\n                        freezeRows: 1,\n                    }}\n                    cacheLayout\n                />\n            </div>\n        </>\n    );\n}\n\nconst customInputOptions = ['First', 'Second', 'Third', 'Fourth', 'Fifth'];\nconst customInputOptions2 = ['Sixth', 'Seventh', 'Eighth', 'Ninth', 'Tenth'];\nconst customInputData = [\n    customInputOptions,\n    customInputOptions2,\n    customInputOptions,\n    customInputOptions2,\n    customInputOptions,\n    customInputOptions2,\n    customInputOptions,\n];\n\nexport function SheetBoxCustomInput() {\n    const [data, setData] = useState(JSON.parse(JSON.stringify(customInputData)));\n    const { onCellWidthChange, onCellHeightChange, cellWidth, cellHeight } = useWidthHeightControl();\n\n    const onSelectionChanged = (x1, y1, x2, y2) => {};\n    const onRightClick = () => {};\n    const columnHeaders = ['A', 'B', 'C'];\n    const cellStyle = (x, y) => {\n        return {};\n    };\n    const editData = (x, y) => {\n        return data?.[y]?.[x];\n    };\n    const displayData = (x, y) => {\n        return data?.[y]?.[x];\n    };\n    const sourceData = (x, y) => {\n        return data?.[y]?.[x];\n    };\n\n    const onChange = (changes) => {\n        const newData = [...data];\n        for (const change of changes) {\n            if (!newData[change.y]) {\n                newData[change.y] = [];\n            }\n            newData[change.y][change.x] = change.value;\n        }\n        setData(newData);\n    };\n\n    const isReadOnly = (x, y) => {\n        return false;\n    };\n\n    return (\n        <div className=\"sheet-box\">\n            <Sheet\n                onSelectionChanged={onSelectionChanged}\n                onRightClick={onRightClick}\n                columnHeaders={columnHeaders}\n                cellStyle={cellStyle}\n                editData={editData}\n                displayData={displayData}\n                sourceData={sourceData}\n                cellWidth={cellWidth}\n                cellHeight={cellHeight}\n                onChange={onChange}\n                readOnly={isReadOnly}\n                onCellWidthChange={onCellWidthChange}\n                onCellHeightChange={onCellHeightChange}\n                inputComponent={CustomInput}\n                cacheLayout\n            />\n        </div>\n    );\n}\n\nfunction CustomInput(x, y, inputProps, commitEditingCell) {\n    const clickHandler = (value) => {\n        commitEditingCell(value);\n    };\n\n    return (\n        <div style={{ ...inputProps.style, backgroundColor: '#fff' }}>\n            <div style={{ border: '1px solid #ddd', boxShadow: '3px 5px 5px #ddd' }}>\n                {(y % 2 ? customInputOptions2 : customInputOptions).map((opt) => {\n                    return (\n                        <CustomOption\n                            key={opt}\n                            opt={opt}\n                            value={inputProps.value}\n                            clickHandler={() => clickHandler(opt)}\n                        />\n                    );\n                })}\n            </div>\n        </div>\n    );\n}\n\nfunction CustomOption({ opt, value, clickHandler }) {\n    const [hover, setHover] = useState(false);\n\n    return (\n        <div\n            onMouseEnter={() => {\n                setHover(true);\n            }}\n            onMouseLeave={() => {\n                setHover(false);\n            }}\n            style={{\n                backgroundColor: value === opt || hover ? '#f6f6f6' : '#fff',\n                padding: '5px 10px',\n                cursor: 'pointer',\n            }}\n            value={opt}\n            onClick={() => clickHandler(opt)}\n        >\n            {opt}\n        </div>\n    );\n}\n\nexport function SheetBoxSourceDisplayData() {\n    const [data] = useState([\n        [1, 2, 3],\n        [10, 20, 30],\n    ]);\n\n    const displayData = (x, y) => {\n        return data?.[y]?.[x]?.toFixed?.(2);\n    };\n\n    return (\n        <div className=\"sheet-box\">\n            <Sheet\n                sourceData={data} // array of arrays of data\n                displayData={displayData}\n            />\n        </div>\n    );\n}\n","import { XY, Rectangle, Selection, Clickable, Direction, Style } from './types';\n\nexport const INITIAL_MAX_SCROLL: XY = [2000, 1000];\n\nexport const ORIGIN: XY = [0, 0];\nexport const ONE_ONE: XY = [1, 1];\n\nexport const NO_CELL: XY = [-1, -1];\nexport const NO_SELECTION: Rectangle = [NO_CELL, NO_CELL];\nexport const NO_SELECTIONS: Selection[] = [];\nexport const NO_CLICKABLES: Clickable[] = [];\nexport const NO_STYLE = {};\n\nexport const MAX_SEARCHABLE_INDEX = 65536;\nexport const MAX_XY: XY = [MAX_SEARCHABLE_INDEX, MAX_SEARCHABLE_INDEX];\n\nexport const COLORS = {\n    selectionBorder: '#1a66ff',\n    selectionBackground: '#d8e6ff80',\n\n    gridLine: '#0000001f',\n\n    dragGhost: '#1a66ff30',\n    dropTarget: '#1a66ff',\n    knobAreaBorder: '#707070',\n\n    headerBackground: '#f6f9fc',\n    headerText: '#666666',\n    headerActive: '#e8f0ff',\n    headerActiveText: '#1a66ff',\n\n    headerSelected: '#1a66ff',\n    headerSelectedGroup: '#1a66ff70',\n    headerSelectedText: '#ffffff',\n    headerSelectedGroupText: '#ffffff',\n\n    shadowColor: '#000000',\n};\n\nexport const SIZES = {\n    knobArea: 6,\n    headerWidth: 50,\n    headerHeight: 22,\n    minimumWidth: 50,\n    minimumHeight: 22,\n    resizeZone: 4,\n    scrollZone: 50,\n    scrollSpeed: 30,\n\n    shadowBlur: 12,\n    shadowOpacity: 0.05,\n};\n\nexport const DEFAULT_CELL_STYLE: Required<Style> = {\n    textAlign: 'left',\n    fontSize: 12,\n    marginRight: 5,\n    marginLeft: 5,\n    color: '#000',\n    fontFamily: 'sans-serif',\n    weight: '',\n    fillColor: '',\n    backgroundColor: '',\n};\n\nexport const DEFAULT_COLUMN_HEADER_STYLE: Required<Style> = {\n    textAlign: 'center',\n    fontSize: 12,\n    marginRight: 5,\n    marginLeft: 5,\n    color: '#000',\n    fontFamily: 'sans-serif',\n    weight: '',\n    fillColor: '',\n    backgroundColor: '',\n};\n\nexport const HEADER_ACTIVE_STYLE = {\n    color: COLORS.headerActiveText,\n};\n\nexport const HEADER_SELECTED_STYLE = {\n    backgroundColor: COLORS.headerSelected,\n    color: COLORS.headerSelectedText,\n};\n\nexport const HEADER_GROUP_SELECTED_STYLE = {\n    backgroundColor: COLORS.headerSelectedGroup,\n    color: COLORS.headerSelectedGroupText,\n};\n\nexport const ARROW_KEYS: Record<string, Direction> = {\n    ArrowRight: 'right',\n    ArrowLeft: 'left',\n    ArrowUp: 'up',\n    ArrowDown: 'down',\n};\n","export const tail = <T>(list: T[]): T => list[list.length - 1];\n\nexport const clamp = (x: number, min: number, max: number) => Math.max(Math.min(max, x), min);\n\nexport const seq = (n: number, s: number = 0, d: number = 1): number[] =>\n    Array.from({ length: n }).map((_, i: number) => s + d * i);\n\nexport const isInRange = (x: number, min: number, max: number) => min <= x && x <= max;\nexport const isInRangeLeft = (x: number, min: number, max: number) => min <= x && x < max;\nexport const isInRangeRight = (x: number, min: number, max: number) => min < x && x <= max;\nexport const isInRangeCenter = (x: number, min: number, max: number) => min < x && x < max;\n","import { XY, Rectangle } from './types';\nimport { clamp } from './util';\n\nexport const addXY = (a: XY, b: XY): XY => [a[0] + b[0], a[1] + b[1]];\nexport const subXY = (a: XY, b: XY): XY => [a[0] - b[0], a[1] - b[1]];\nexport const mulXY = (a: XY, b: XY): XY => [a[0] * b[0], a[1] * b[1]];\nexport const maxXY = (a: XY, b: XY): XY => [Math.max(a[0], b[0]), Math.max(a[1], b[1])];\nexport const minXY = (a: XY, b: XY): XY => [Math.min(a[0], b[0]), Math.min(a[1], b[1])];\nexport const clampXY = (p: XY, min: XY, max: XY = [Infinity, Infinity]): XY => [\n    clamp(p[0], min[0], max[0]),\n    clamp(p[1], min[1], max[1]),\n];\n\nexport const getDirectionStep = (direction: string): XY => {\n    if (direction === 'left') return [-1, 0];\n    if (direction === 'right') return [1, 0];\n    if (direction === 'up') return [0, -1];\n    if (direction === 'down') return [0, 1];\n    return [0, 0];\n};\n\nexport const isSameXY = (a: XY, b: XY) => a[0] === b[0] && a[1] === b[1];\n\nexport const isSameSelection = (a: Rectangle, b: Rectangle) => {\n    const [a1, a2] = a;\n    const [b1, b2] = b;\n    return isSameXY(a1, b1) && isSameXY(a2, b2);\n};\n\nexport const forRange = (min: number, max: number, callback: (i: number) => void) => {\n    for (let i = min; i <= max; ++i) callback(i);\n};\n\nexport const forSelectionColumns = (selection: Rectangle) => (callback: (i: number) => void) => {\n    const [[left], [right]] = normalizeSelection(selection);\n    forRange(left, right, callback);\n};\n\nexport const forSelectionRows = (selection: Rectangle) => (callback: (i: number) => void) => {\n    const [[, top], [, bottom]] = normalizeSelection(selection);\n    forRange(top, bottom, callback);\n};\n\nconst forToMap = <A extends Array<any>>(forLoop: (callback: (...args: A) => void) => void) => <B>(\n    map: (...args: A) => B\n) => {\n    const out: B[] = [];\n    forLoop((...args: A) => out.push(map(...args)));\n    return out;\n};\n\nexport const mapSelectionColumns = (selection: Rectangle) => forToMap(forSelectionColumns(selection));\nexport const mapSelectionRows = (selection: Rectangle) => forToMap(forSelectionRows(selection));\n\n// Selection is infinite horizontally\nexport const isMaybeRowSelection = (selection: Rectangle) => {\n    const [[left], [right]] = selection;\n    return left === -1 && right === -1;\n};\n\n// Selection is infinite vertically\nexport const isMaybeColumnSelection = (selection: Rectangle) => {\n    const [[, top], [, bottom]] = selection;\n    return top === -1 && bottom === -1;\n};\n\n// Selection is ONLY infinite horizontally\nexport const isRowSelection = (selection: Rectangle) => {\n    const [[left, top], [right, bottom]] = selection;\n    return left === -1 && right === -1 && top !== -1 && bottom !== -1;\n};\n\n// Selection is ONLY infinite vertically\nexport const isColumnSelection = (selection: Rectangle) => {\n    const [[left, top], [right, bottom]] = selection;\n    return top === -1 && bottom === -1 && left !== -1 && right !== -1;\n};\n\n// Selection is not infinite\nexport const isCellSelection = (selection: Rectangle) => {\n    const [[left, top], [right, bottom]] = selection;\n    return left !== -1 && right !== -1 && top !== -1 && bottom !== -1;\n};\n\n// Selection is null\nexport const isEmptySelection = (selection: Rectangle) => {\n    const [[left, top], [right, bottom]] = selection;\n    return left === -1 && right === -1 && top === -1 && bottom === -1;\n};\n\n// Test cell inside selection (inclusive edges)\nexport const isPointInsideSelection = (selection: Rectangle, point: XY) => {\n    const [[left, top], [right, bottom]] = normalizeSelection(selection);\n    const [x, y] = point;\n    return x >= left && x <= right && y >= top && y <= bottom;\n};\n\n// Validate selections to avoid half-infinite anchor/head\nexport const validateSelection = (selection: Rectangle): Rectangle => {\n    let [anchor, head] = selection;\n    anchor = anchor.slice() as XY;\n    head = head.slice() as XY;\n\n    const min = minXY(anchor, head);\n    if (min[0] === -1) anchor[0] = head[0] = -1;\n    if (min[1] === -1) anchor[1] = head[1] = -1;\n\n    return [anchor, head];\n};\n\n// Normalize rectangle to min/max pair\nexport const normalizeSelection = (selection: Rectangle): Rectangle => {\n    const [anchor, head] = selection;\n    return [minXY(anchor, head), maxXY(anchor, head)];\n};\n\n// Orient normalized rectangle to match existing orientation\nexport const orientSelection = (normalized: Rectangle, to: Rectangle): Rectangle => {\n    const [[left, top], [right, bottom]] = normalized;\n\n    const [anchor, head] = to;\n    const [ax, ay] = anchor;\n    const [hx, hy] = head;\n\n    const swapX = (ax - hx || 1) * (right - left || 1) < 0;\n    const swapY = (ay - hy || 1) * (bottom - top || 1) < 0;\n\n    return [\n        [swapX ? right : left, swapY ? bottom : top],\n        [swapX ? left : right, swapY ? top : bottom],\n    ];\n};\n\n// Clip rectangle to max range\nexport const clipSelection = (selection: Rectangle, max: XY): Rectangle => {\n    const [anchor, head] = selection;\n    return [minXY(anchor, max), minXY(head, max)];\n};\n","import { XY, Rectangle, RowOrColumnPropertyFunction } from './types';\nimport { normalizeSelection, orientSelection } from './coordinate';\n\nconst LIMIT = 1000;\n\nconst scanGroup = (\n    keys: RowOrColumnPropertyFunction<string | number | null>,\n    index: number,\n    direction: number,\n    matchKeys: Set<string | number | null>\n) => {\n    let i = 1;\n    const limit = direction > 0 ? LIMIT : Math.min(LIMIT, index + 1);\n    for (; i < limit; i++) {\n        const key = keys(index + i * direction);\n        if (key == null || !matchKeys.has(key)) break;\n    }\n    return index + (i - 1) * direction;\n};\n\n// Expand a selection to its adjacent row or column group\nexport const expandSelectionToRowOrColumnGroups = (\n    selection: Rectangle,\n    groupKeys: RowOrColumnPropertyFunction<string | number | null>,\n    matchKeys: Set<string | number | null> | null,\n    coordinate: number // 0/1 for X/Y\n) => {\n    if (!matchKeys) return selection;\n\n    const [first, second] = normalizeSelection(selection);\n\n    const start = first[coordinate];\n    const end = second[coordinate];\n\n    const startIndex = scanGroup(groupKeys, start, -1, matchKeys);\n    const endIndex = scanGroup(groupKeys, end, 1, matchKeys);\n\n    const expanded: Rectangle = [first.slice() as XY, second.slice() as XY];\n    expanded[0][coordinate] = startIndex;\n    expanded[1][coordinate] = endIndex;\n\n    const oriented = orientSelection(expanded, selection);\n    return oriented;\n};\n\nexport const isBoundaryInsideGroup = (\n    index: number,\n    groupKeys: RowOrColumnPropertyFunction<string | number | null>\n) => {\n    const before = groupKeys(index - 1);\n    const after = groupKeys(index);\n    return before != null && after != null && before === after;\n};\n","import {\n    Direction,\n    XY,\n    CellContentType,\n    CellProperty,\n    CellPropertyFunction,\n    PropTypes,\n    RowOrColumnProperty,\n    RowOrColumnPropertyFunction,\n} from './types';\nimport { MAX_SEARCHABLE_INDEX, MAX_XY, ORIGIN } from './constants';\nimport { clampXY, addXY, subXY, maxXY, getDirectionStep } from './coordinate';\n\n// Inject row/column props from an array, function, constant or default value\nexport const createRowOrColumnProp = <T extends PropTypes>(\n    rowColProp: RowOrColumnProperty<T> | undefined,\n    defaultValue: T\n): RowOrColumnPropertyFunction<T> => {\n    if (Array.isArray(rowColProp)) {\n        return (rowOrColIndex: number) => {\n            if (rowOrColIndex >= 0 && rowOrColIndex < rowColProp.length) {\n                return rowColProp[rowOrColIndex];\n            } else {\n                return defaultValue;\n            }\n        };\n    } else if (typeof rowColProp === 'function') {\n        return rowColProp;\n    } else if (rowColProp !== null && rowColProp !== undefined) {\n        return () => rowColProp;\n    } else {\n        return () => defaultValue;\n    }\n};\n\n// Inject cell props from a nested array, function, constant or default value\nexport const createCellProp = <T extends PropTypes>(\n    cellProp: CellProperty<T> | undefined,\n    defaultValue: T\n): CellPropertyFunction<T> => {\n    if (Array.isArray(cellProp)) {\n        return (x: number, y: number) => {\n            if (y >= 0 && y < cellProp.length) {\n                if (x >= 0 && x < cellProp[y].length) {\n                    return cellProp[y][x];\n                } else {\n                    return defaultValue;\n                }\n            } else {\n                return defaultValue;\n            }\n        };\n    } else if (typeof cellProp === 'function') {\n        return cellProp;\n    } else if (cellProp !== null && cellProp !== undefined) {\n        return () => cellProp;\n    } else {\n        return () => defaultValue;\n    }\n};\n\nexport const findApproxMaxEditDataIndex = (editData: CellPropertyFunction<string>): XY => {\n    let x = 0;\n    let y = 0;\n    let howManyEmpty = 0;\n    let growthIncrement = 10;\n    let growthIncrementFactor = 1.5;\n\n    // x\n    while (howManyEmpty < 4) {\n        let allEmpty = true;\n        for (let yy = 0; yy < 10; yy++) {\n            const data = editData(x, yy);\n            if (data !== null && data !== undefined && data !== '') {\n                allEmpty = false;\n                break;\n            }\n        }\n        if (allEmpty) {\n            howManyEmpty += 1;\n        }\n        x += growthIncrement;\n        if (x > MAX_SEARCHABLE_INDEX) {\n            break;\n        }\n        growthIncrement = Math.floor(growthIncrement * growthIncrementFactor);\n    }\n\n    howManyEmpty = 0;\n    growthIncrement = 10;\n    growthIncrementFactor = 1.5;\n\n    // y\n    while (howManyEmpty < 4) {\n        let allEmpty = true;\n        for (let xx = 0; xx < 10; xx++) {\n            const data = editData(xx, y);\n            if (data !== null && data !== undefined && data !== '') {\n                allEmpty = false;\n                break;\n            }\n        }\n        if (allEmpty) {\n            howManyEmpty += 1;\n        }\n        y += growthIncrement;\n        if (y > MAX_SEARCHABLE_INDEX) {\n            break;\n        }\n        growthIncrement = Math.floor(growthIncrement * growthIncrementFactor);\n    }\n    return [x, y];\n};\n\nexport const findInDisplayData = (\n    displayData: CellPropertyFunction<CellContentType>,\n    start: XY,\n    direction: Direction\n): XY => {\n    const step = getDirectionStep(direction);\n\n    let cell = clampXY(start, ORIGIN, MAX_XY);\n    const first = displayData(...addXY(cell, step));\n    const firstFilled = first !== '' && first !== null && first !== undefined;\n\n    if (!firstFilled) {\n        cell = addXY(cell, step);\n    }\n\n    let [cellX, cellY] = cell;\n    while (cellX <= MAX_SEARCHABLE_INDEX && cellY <= MAX_SEARCHABLE_INDEX && cellX >= 0 && cellY >= 0) {\n        const data = displayData(cellX, cellY);\n\n        // if first cell is filled, find the last filled cell, so first look for first unfilled\n        if (firstFilled && (data === '' || data === null || data === undefined)) {\n            return subXY(cell, step);\n        }\n        // if first cell is not filled, just find the first filled\n        if (!firstFilled && data !== '' && data !== null && data !== undefined) {\n            return cell;\n        }\n\n        [cellX, cellY] = cell = addXY(cell, step);\n    }\n\n    return maxXY(cell, [0, 0]);\n};\n","import {\n    CellLayout,\n    CellPropertyFunction,\n    Change,\n    Clickable,\n    Rectangle,\n    RowOrColumnPropertyFunction,\n    SheetMouseEvent,\n    SheetStyle,\n    VisibleLayout,\n    XY,\n} from './types';\nimport { MouseEvent, PointerEvent, RefObject, useCallback, useMemo, useRef, useState } from 'react';\nimport {\n    normalizeSelection,\n    mapSelectionColumns,\n    mapSelectionRows,\n    isColumnSelection,\n    isRowSelection,\n    isCellSelection,\n    isMaybeRowSelection,\n    isPointInsideSelection,\n    addXY,\n    subXY,\n    maxXY,\n} from './coordinate';\nimport { ONE_ONE, ORIGIN, SIZES } from './constants';\nimport { isBoundaryInsideGroup, expandSelectionToRowOrColumnGroups } from './group';\nimport { findApproxMaxEditDataIndex } from './props';\nimport { isInRange, seq } from './util';\n\ntype DragOp = {\n    anchor: number;\n    scroll: number;\n    size: number;\n    indices: number[];\n};\n\nexport const useMouse = (\n    hitmapRef: RefObject<Clickable[]>,\n    selection: Rectangle,\n    knobArea: Rectangle | null,\n    editMode: boolean,\n    editData: CellPropertyFunction<string>,\n    sourceData: CellPropertyFunction<string | number | null>,\n    cellReadOnly: CellPropertyFunction<boolean | null>,\n\n    canSizeColumn: RowOrColumnPropertyFunction<boolean | null>,\n    canSizeRow: RowOrColumnPropertyFunction<boolean | null>,\n    canOrderColumn: RowOrColumnPropertyFunction<boolean | null>,\n    canOrderRow: RowOrColumnPropertyFunction<boolean | null>,\n\n    cellLayout: CellLayout,\n    visibleCells: VisibleLayout,\n    sheetStyle: SheetStyle,\n\n    columnGroupKeys: RowOrColumnPropertyFunction<string | number | null>,\n    rowGroupKeys: RowOrColumnPropertyFunction<string | number | null>,\n    selectedColumnGroups: Set<string | number | null> | null,\n    selectedRowGroups: Set<string | number | null> | null,\n\n    getAutoSizeWidth: (column: number) => number,\n\n    onEdit?: (cell: XY) => void,\n    onCommit?: () => void,\n    onKnobAreaChange?: (knobArea: Rectangle | null) => void,\n    onDragIndicesChange?: (indices: [number[] | null, number[] | null]) => void,\n    onDragOffsetChange?: (dragOffset: XY | null) => void,\n    onDropTargetChange?: (selection: Rectangle | null) => void,\n    onSelectionChange?: (selection: Rectangle, scrollTo?: boolean, toHead?: boolean) => void,\n\n    onInvalidateColumn?: (column: number) => void,\n    onInvalidateRow?: (row: number) => void,\n\n    onChange?: (changes: Change[]) => void,\n    onColumnOrderChange?: (indices: number[], order: number) => void,\n    onRowOrderChange?: (indices: number[], order: number) => void,\n    onCellWidthChange?: (indices: number[], value: number) => void,\n    onCellHeightChange?: (indices: number[], value: number) => void,\n    onRightClick?: (e: SheetMouseEvent) => void,\n\n    dontCommitEditOnSelectionChange?: boolean,\n    dontChangeSelectionOnOrderChange?: boolean\n) => {\n    const [hitTarget, setHitTarget] = useState<Clickable | null>(null);\n\n    const [columnResize, setColumnResize] = useState<DragOp | null>(null);\n    const [rowResize, setRowResize] = useState<DragOp | null>(null);\n    const [columnDrag, setColumnDrag] = useState<DragOp | null>(null);\n    const [rowDrag, setRowDrag] = useState<DragOp | null>(null);\n\n    const [draggingKnob, setDraggingKnob] = useState(false);\n    const [draggingSelection, setDraggingSelection] = useState(false);\n    const [draggingRowSelection, setDraggingRowSelection] = useState(false);\n    const [draggingColumnSelection, setDraggingColumnSelection] = useState(false);\n\n    const { hideRowHeaders, hideColumnHeaders } = sheetStyle;\n    const { cellToPixel, getVersion } = cellLayout;\n    const version = getVersion();\n\n    const knobPosition = useMemo((): XY | null => {\n        const [, [maxX, maxY]] = normalizeSelection(selection);\n        if (isRowSelection(selection)) {\n            return subXY(addXY(cellToPixel([0, maxY], [0, 1]), [SIZES.knobArea * 0.5, 0]), ONE_ONE);\n        }\n        if (isColumnSelection(selection)) {\n            return subXY(addXY(cellToPixel([maxX, 0], [1, 0]), [0, SIZES.knobArea * 0.5]), ONE_ONE);\n        }\n        if (isCellSelection(selection)) {\n            return subXY(cellToPixel([maxX, maxY], ONE_ONE), ONE_ONE);\n        }\n        return null;\n    }, [selection, cellToPixel, version]);\n\n    // Pass pointer/dragging state into handlers via ref so they don't need to rebind during resizes/drags\n    const refState = {\n        selection,\n        knobArea,\n        editMode,\n        editData,\n        sourceData,\n        cellLayout,\n        visibleCells,\n        hitTarget,\n\n        knobPosition,\n        columnResize,\n        rowResize,\n        columnDrag,\n        rowDrag,\n\n        draggingKnob,\n        draggingSelection,\n        draggingRowSelection,\n        draggingColumnSelection,\n    };\n    const ref = useRef(refState);\n    ref.current = refState;\n\n    // Hit-testing for rendered objects\n    const getMousePosition = useCallback((e: PointerEvent<any> | MouseEvent<any>) => {\n        if (!e.target || !(e.target instanceof Element)) {\n            return null;\n        }\n\n        const rect = e.target.getBoundingClientRect();\n        const xy: XY = [e.clientX - rect.left, e.clientY - rect.top];\n\n        // Ignore clicks on scrollbar\n        if (xy[0] > e.target.clientWidth || xy[1] > e.target.clientHeight) {\n            return null;\n        }\n\n        return xy;\n    }, []);\n\n    const getScrollPosition = useCallback((e: PointerEvent<any> | MouseEvent<any>) => {\n        if (!e.target || !(e.target instanceof Element)) {\n            return [0, 0];\n        }\n\n        const { scrollLeft, scrollTop } = e.target as any;\n        const xy: XY = [scrollLeft, scrollTop];\n\n        return xy;\n    }, []);\n\n    const getMouseHit = useCallback(\n        (xy: XY) => {\n            const { current: hitmap } = hitmapRef;\n            if (!hitmap) return null;\n\n            for (const object of hitmap) {\n                const { rect } = object;\n                if (isPointInsideSelection(rect, xy)) {\n                    return object;\n                }\n            }\n\n            return null;\n        },\n        [hitmapRef]\n    );\n\n    const onPointerLeave = useCallback(() => {\n        window.document.body.style.cursor = 'auto';\n    }, []);\n\n    const onPointerDown = useCallback(\n        (e: PointerEvent<HTMLDivElement>) => {\n            const {\n                current: {\n                    selection,\n                    cellLayout: { columnToPixel, rowToPixel, pixelToCell, getIndentX, getIndentY },\n                    visibleCells: { columns, rows },\n                    knobPosition,\n                },\n            } = ref;\n\n            if (e.button !== 0) return;\n\n            (e.target as Element)?.setPointerCapture?.(e.pointerId);\n\n            const xy = getMousePosition(e);\n            if (!xy) return;\n\n            const [x, y] = xy;\n            const hitTarget = getMouseHit(xy);\n            if (hitTarget) {\n                setHitTarget(hitTarget);\n                // Update hitTarget in ref in case there is no re-render between pointerDown and pointerUp\n                ref.current.hitTarget = hitTarget;\n                return;\n            }\n\n            const normalized = normalizeSelection(selection);\n            const [[minX, minY], [maxX, maxY]] = normalized;\n\n            const selectedColumns = mapSelectionColumns(selection)((i) => i);\n            const selectedRows = mapSelectionRows(selection)((i) => i);\n\n            // Column header\n            if (!hideColumnHeaders && y < getIndentY()) {\n                // Grab selected columns in column selection\n                if (onColumnOrderChange) {\n                    // Trim off start/end so resize works there\n                    const start = columnToPixel(minX) + SIZES.resizeZone;\n                    const end = columnToPixel(maxX, 1) - SIZES.resizeZone;\n                    if (isInRange(x, start, end) || selectedColumnGroups) {\n                        for (const index of columns) {\n                            const start = columnToPixel(index, 0);\n                            const end = columnToPixel(index, 1);\n\n                            if (\n                                isColumnSelection(selection) &&\n                                isInRange(x, start, end) &&\n                                (isInRange(index, minX, maxX) || selectedColumnGroups?.has(columnGroupKeys(index))) &&\n                                canOrderColumn(index)\n                            ) {\n                                window.document.body.style.cursor = 'grabbing';\n\n                                // Find all indices that need to be moved, from selection or matching groups\n                                const indices = Array.from(\n                                    new Set([\n                                        ...selectedColumns,\n                                        ...(selectedColumnGroups\n                                            ? columns.filter((index) =>\n                                                  selectedColumnGroups.has(columnGroupKeys(index))\n                                              )\n                                            : []),\n                                    ]).values()\n                                );\n                                indices.sort((a, b) => a - b);\n\n                                // Make one continuous drag shadow around the cursor for a contiguous group\n                                let dragIndices = indices;\n                                if (selectedColumnGroups) {\n                                    const clickSelection: Rectangle = [\n                                        [index, -1],\n                                        [index, -1],\n                                    ];\n                                    const [[left], [right]] = expandSelectionToRowOrColumnGroups(\n                                        clickSelection,\n                                        columnGroupKeys,\n                                        selectedColumnGroups,\n                                        0\n                                    );\n\n                                    // Extend to whole selection if it's part of the same 'chunk'\n                                    const connected = !(minX > right || maxX < left);\n                                    const dragStart = connected ? Math.min(minX, left) : left;\n                                    const dragEnd = connected ? Math.max(maxX, right) : right;\n                                    dragIndices = seq(dragEnd - dragStart + 1, dragStart);\n                                }\n\n                                const size = columnToPixel(maxX, 1) - columnToPixel(minX);\n                                const [scroll] = getScrollPosition(e);\n\n                                setColumnDrag({\n                                    anchor: x,\n                                    scroll,\n                                    size,\n                                    indices,\n                                });\n                                onDragOffsetChange?.([0, 0]);\n                                onDragIndicesChange?.([dragIndices, null]);\n                                return;\n                            }\n                        }\n                    }\n                }\n\n                // Resize columns\n                if (onCellWidthChange) {\n                    for (const index of columns) {\n                        const edge = columnToPixel(index, 1);\n\n                        if (Math.abs(edge - x) < SIZES.resizeZone && canSizeColumn(index)) {\n                            window.document.body.style.cursor = 'col-resize';\n\n                            const asGroup = isColumnSelection(selection) && maxX === index;\n                            const indices = asGroup ? selectedColumns : [index];\n\n                            const size = asGroup\n                                ? columnToPixel(maxX, 1) - columnToPixel(minX)\n                                : columnToPixel(index, 1) - columnToPixel(index);\n                            const [scroll] = getScrollPosition(e);\n\n                            setColumnResize({\n                                anchor: x,\n                                scroll,\n                                size,\n                                indices,\n                            });\n                            return;\n                        }\n                    }\n                }\n            }\n\n            if (!hideRowHeaders && x < getIndentX()) {\n                // Grab selected rows in row selection\n                if (onRowOrderChange) {\n                    // Trim off start/end so resize works there\n                    const start = rowToPixel(minY) + SIZES.resizeZone;\n                    const end = rowToPixel(maxY, 1) - SIZES.resizeZone;\n\n                    if (isInRange(y, start, end) || selectedRowGroups) {\n                        for (const index of rows) {\n                            const start = rowToPixel(index, 0);\n                            const end = rowToPixel(index, 1);\n\n                            if (\n                                isRowSelection(selection) &&\n                                isInRange(y, start, end) &&\n                                (isInRange(index, minY, maxY) || selectedRowGroups?.has(rowGroupKeys(index))) &&\n                                canOrderRow(index)\n                            ) {\n                                window.document.body.style.cursor = 'grabbing';\n\n                                // Find all indices that need to be moved, from selection or matching groups\n                                const indices = Array.from(\n                                    new Set([\n                                        ...selectedRows,\n                                        ...(selectedRowGroups\n                                            ? rows\n                                                  .map((_, i) => i)\n                                                  .filter((index) => selectedRowGroups.has(rowGroupKeys(index)))\n                                            : []),\n                                    ]).values()\n                                );\n                                indices.sort((a, b) => a - b);\n\n                                // Make one continuous drag shadow around the cursor for a contiguous group\n                                let dragIndices = indices;\n                                if (selectedRowGroups) {\n                                    const clickSelection: Rectangle = [\n                                        [-1, index],\n                                        [-1, index],\n                                    ];\n                                    const [[, top], [, bottom]] = expandSelectionToRowOrColumnGroups(\n                                        clickSelection,\n                                        rowGroupKeys,\n                                        selectedRowGroups,\n                                        1\n                                    );\n\n                                    // Extend to whole selection if it's part of the same 'chunk'\n                                    const connected = !(minY > bottom || maxY < top);\n                                    const dragStart = connected ? Math.min(minY, top) : top;\n                                    const dragEnd = connected ? Math.max(maxY, bottom) : bottom;\n                                    dragIndices = seq(dragEnd - dragStart + 1, dragStart);\n                                }\n\n                                const size = rowToPixel(maxY, 1) - rowToPixel(minY);\n                                const [, scroll] = getScrollPosition(e);\n\n                                setRowDrag({\n                                    anchor: y,\n                                    scroll,\n                                    size,\n                                    indices,\n                                });\n                                onDragOffsetChange?.([0, 0]);\n                                onDragIndicesChange?.([null, dragIndices]);\n                                return;\n                            }\n                        }\n                    }\n                }\n\n                // Resize rows\n                if (onCellHeightChange) {\n                    for (const index of rows) {\n                        const edge = rowToPixel(index, 1);\n\n                        if (Math.abs(edge - y) < SIZES.resizeZone && canSizeRow(index)) {\n                            window.document.body.style.cursor = 'row-resize';\n\n                            const asGroup = isRowSelection(selection) && maxY === index;\n                            const indices = asGroup ? selectedRows : [index];\n\n                            const size = asGroup\n                                ? rowToPixel(maxY, 1) - rowToPixel(minY)\n                                : rowToPixel(index, 1) - rowToPixel(index);\n                            const [, scroll] = getScrollPosition(e);\n\n                            setRowResize({\n                                anchor: y,\n                                scroll,\n                                size,\n                                indices,\n                            });\n                            return;\n                        }\n                    }\n                }\n            }\n\n            // Knob drag mode\n            if (knobPosition) {\n                const [knobX, knobY] = knobPosition;\n                if (Math.abs(x - knobX) < SIZES.knobArea && Math.abs(y - knobY) < SIZES.knobArea) {\n                    setDraggingKnob(true);\n                    onKnobAreaChange?.(selection);\n                    return;\n                }\n            }\n\n            // Normal cell click\n            const head = pixelToCell(xy);\n            const anchor: XY = e.shiftKey ? [...selection[0]] : head;\n\n            if (editMode) {\n                if (!dontCommitEditOnSelectionChange) {\n                    onCommit?.();\n                }\n            }\n\n            let scrollTo = true;\n\n            if (!hideRowHeaders && x < getIndentX()) {\n                scrollTo = false;\n                setDraggingRowSelection(true);\n                anchor[0] = -1;\n                head[0] = -1;\n            }\n\n            if (!hideColumnHeaders && y < getIndentY()) {\n                scrollTo = false;\n                setDraggingColumnSelection(true);\n                anchor[1] = -1;\n                head[1] = -1;\n            }\n\n            setDraggingSelection(true);\n            onSelectionChange?.([anchor, head], scrollTo, true);\n        },\n        [\n            getMousePosition,\n            getScrollPosition,\n            getMouseHit,\n            onColumnOrderChange,\n            onRowOrderChange,\n            onCellWidthChange,\n            onCellHeightChange,\n            onKnobAreaChange,\n            onSelectionChange,\n            onCommit,\n            canSizeColumn,\n            canSizeRow,\n            canOrderColumn,\n            canOrderRow,\n            dontCommitEditOnSelectionChange,\n            columnGroupKeys,\n            rowGroupKeys,\n            selectedColumnGroups,\n            selectedRowGroups,\n        ]\n    );\n\n    const onPointerUp = useCallback(\n        (e: PointerEvent<HTMLDivElement>) => {\n            const {\n                current: {\n                    knobArea,\n                    selection,\n                    sourceData,\n                    editData,\n\n                    columnDrag,\n                    rowDrag,\n\n                    draggingKnob,\n                    hitTarget,\n\n                    cellLayout: { pixelToColumn, pixelToRow, getIndentX, getIndentY },\n                },\n            } = ref;\n\n            if (knobArea && draggingKnob) {\n                const changes = parseKnobOperation(knobArea, selection, sourceData, editData, cellReadOnly);\n\n                onChange?.(changes);\n                onSelectionChange?.(knobArea, true, true);\n                onKnobAreaChange?.(null);\n            }\n\n            const xy = getMousePosition(e);\n            if (xy && (columnDrag || rowDrag)) {\n                window.document.body.style.cursor = 'auto';\n                onDragIndicesChange?.([null, null]);\n                onDragOffsetChange?.(null);\n                onDropTargetChange?.(null);\n\n                const [x, y] = xy;\n                const [[minX, minY], [maxX, maxY]] = normalizeSelection(selection);\n\n                const cellX = pixelToColumn(Math.max(x, getIndentX()), 0.5);\n                const cellY = pixelToRow(Math.max(y, getIndentY()), 0.5);\n\n                if (columnDrag) {\n                    const { indices } = columnDrag;\n\n                    const insideSelection = cellX >= minX && cellX <= maxX + 1;\n                    const insideGroup = selectedColumnGroups?.has(columnGroupKeys(x));\n                    if (!insideSelection && !insideGroup) {\n                        const preceding = indices.filter((i) => i < cellX);\n                        const order = cellX - preceding.length;\n                        dontChangeSelectionOnOrderChange ||\n                            onSelectionChange?.([\n                                [order, minY],\n                                [order + indices.length - 1, maxY],\n                            ]);\n                        onColumnOrderChange?.(indices, order);\n                        onInvalidateColumn?.(Math.min(minX, order));\n                    }\n                }\n                if (rowDrag) {\n                    const { indices } = rowDrag;\n\n                    const insideSelection = cellY >= minY && cellY <= maxY + 1;\n                    const insideGroup = selectedRowGroups?.has(rowGroupKeys(y));\n                    if (!insideSelection && !insideGroup) {\n                        const preceding = indices.filter((i) => i < cellY);\n                        const order = cellY - preceding.length;\n                        dontChangeSelectionOnOrderChange ||\n                            onSelectionChange?.([\n                                [minX, order],\n                                [maxX, order + indices.length - 1],\n                            ]);\n                        onRowOrderChange?.(indices, order);\n                        onInvalidateRow?.(Math.min(minY, order));\n                    }\n                }\n            }\n\n            setDraggingSelection(false);\n            setDraggingRowSelection(false);\n            setDraggingColumnSelection(false);\n            setDraggingKnob(false);\n            setColumnResize(null);\n            setColumnDrag(null);\n            setRowResize(null);\n            setRowDrag(null);\n\n            if (!xy || !hitTarget) return;\n            setHitTarget(null);\n\n            // Check hit target rect to see if it is the same as pointerDown\n            // (object identity might have changed due to react re-render)\n            const previousRect = JSON.stringify(hitTarget.rect);\n            const currentRect = JSON.stringify(getMouseHit(xy)?.rect);\n            if (previousRect === currentRect) {\n                const { obj } = hitTarget;\n                obj.onClick?.(e);\n            }\n        },\n        [\n            getMousePosition,\n            getMouseHit,\n            onChange,\n            onSelectionChange,\n            onKnobAreaChange,\n            onDropTargetChange,\n            onColumnOrderChange,\n            onRowOrderChange,\n            dontChangeSelectionOnOrderChange,\n        ]\n    );\n\n    const onPointerMove = useCallback(\n        (e: PointerEvent<HTMLDivElement>) => {\n            const {\n                current: {\n                    selection,\n                    visibleCells,\n\n                    knobPosition,\n                    columnResize,\n                    columnDrag,\n                    rowResize,\n                    rowDrag,\n\n                    draggingKnob,\n                    draggingSelection,\n                    draggingColumnSelection,\n                    draggingRowSelection,\n\n                    cellLayout: {\n                        columnToPixel,\n                        rowToPixel,\n                        pixelToCell,\n                        pixelToColumn,\n                        pixelToRow,\n                        getIndentX,\n                        getIndentY,\n                    },\n                },\n            } = ref;\n\n            window.document.body.style.cursor = 'auto';\n\n            const xy = getMousePosition(e);\n            if (!xy) return;\n\n            const hitTarget = getMouseHit(xy);\n            if (hitTarget) {\n                window.document.body.style.cursor = 'pointer';\n            } else if (columnDrag || rowDrag) {\n                window.document.body.style.cursor = 'grabbing';\n            } else if (columnResize) {\n                window.document.body.style.cursor = 'col-resize';\n                e.preventDefault();\n            } else if (rowResize) {\n                window.document.body.style.cursor = 'row-resize';\n                e.preventDefault();\n            } else if (draggingRowSelection || draggingColumnSelection) {\n                e.preventDefault();\n            }\n\n            const { columns, rows } = visibleCells;\n            const [x, y] = xy;\n            const [[minX, minY], [maxX, maxY]] = normalizeSelection(selection);\n\n            const isDragging =\n                columnResize || columnDrag || rowResize || rowDrag || draggingRowSelection || draggingColumnSelection;\n\n            if (!isDragging) {\n                if (!hideColumnHeaders && y < getIndentY()) {\n                    if (onColumnOrderChange) {\n                        // Trim off start/end so resize works there\n                        const start = columnToPixel(minX) + SIZES.resizeZone;\n                        const end = columnToPixel(maxX, 1) - SIZES.resizeZone;\n                        if (isInRange(x, start, end) || selectedColumnGroups) {\n                            for (const index of columns) {\n                                const start = columnToPixel(index);\n                                const end = columnToPixel(index, 1);\n\n                                if (\n                                    !draggingColumnSelection &&\n                                    isColumnSelection(selection) &&\n                                    isInRange(x, start, end) &&\n                                    (isInRange(index, minX, maxX) ||\n                                        selectedColumnGroups?.has(columnGroupKeys(index))) &&\n                                    canOrderColumn(index)\n                                ) {\n                                    window.document.body.style.cursor = 'grab';\n                                    return;\n                                }\n                            }\n                        }\n                    }\n                    if (onCellWidthChange) {\n                        for (const index of columns) {\n                            const edge = columnToPixel(index, 1);\n                            if (Math.abs(edge - x) < SIZES.resizeZone && canSizeColumn(index)) {\n                                window.document.body.style.cursor = 'col-resize';\n                                return;\n                            }\n                        }\n                    }\n                }\n\n                if (!hideRowHeaders && x < getIndentX()) {\n                    if (onRowOrderChange) {\n                        // Trim off start/end so resize works there\n                        const start = rowToPixel(minY) + SIZES.resizeZone;\n                        const end = rowToPixel(maxY, 1) - SIZES.resizeZone;\n                        if (isInRange(y, start, end) || selectedRowGroups) {\n                            for (const index of rows) {\n                                const start = rowToPixel(index);\n                                const end = rowToPixel(index, 1);\n\n                                if (\n                                    !draggingRowSelection &&\n                                    isRowSelection(selection) &&\n                                    isInRange(y, start, end) &&\n                                    (isInRange(index, minY, maxY) || selectedRowGroups?.has(rowGroupKeys(index))) &&\n                                    canOrderRow(index)\n                                ) {\n                                    window.document.body.style.cursor = 'grab';\n                                    return;\n                                }\n                            }\n                        }\n                    }\n                    if (onCellHeightChange) {\n                        for (const index of rows) {\n                            const edge = rowToPixel(index, 1);\n                            if (Math.abs(edge - y) < SIZES.resizeZone && canSizeRow(index)) {\n                                window.document.body.style.cursor = 'row-resize';\n                                return;\n                            }\n                        }\n                    }\n                }\n\n                if (knobPosition) {\n                    const [knobX, knobY] = knobPosition;\n                    if (Math.abs(x - knobX) < SIZES.knobArea && Math.abs(y - knobY) < SIZES.knobArea) {\n                        window.document.body.style.cursor = 'crosshair';\n                        return;\n                    }\n                }\n            }\n\n            if (columnResize) {\n                if (onCellWidthChange) {\n                    const { size, anchor, scroll, indices } = columnResize;\n                    const [currentScroll] = getScrollPosition(e);\n                    const newWidth = Math.max(\n                        size + x - anchor + scroll - currentScroll,\n                        SIZES.minimumWidth * indices.length\n                    );\n                    onInvalidateColumn?.(indices[0] - 1);\n                    onCellWidthChange(indices, newWidth / indices.length);\n                }\n                return;\n            }\n\n            if (rowResize) {\n                if (onCellHeightChange) {\n                    const { size, anchor, scroll, indices } = rowResize;\n                    const [, currentScroll] = getScrollPosition(e);\n                    const newHeight = Math.max(\n                        size + y - anchor + scroll - currentScroll,\n                        SIZES.minimumHeight * indices.length\n                    );\n                    onInvalidateRow?.(indices[0] - 1);\n                    onCellHeightChange(indices, newHeight / indices.length);\n                }\n                return;\n            }\n\n            if (draggingSelection) {\n                const [anchor] = selection;\n                const head = pixelToCell(xy);\n\n                const [anchorX, anchorY] = anchor;\n                const [headX, headY] = head;\n\n                if (draggingRowSelection) {\n                    onSelectionChange?.(\n                        [\n                            [-1, anchorY],\n                            [-1, Math.max(0, headY)],\n                        ],\n                        false\n                    );\n                } else if (draggingColumnSelection) {\n                    onSelectionChange?.(\n                        [\n                            [anchorX, -1],\n                            [Math.max(0, headX), -1],\n                        ],\n                        false\n                    );\n                } else {\n                    onSelectionChange?.([maxXY(anchor, ORIGIN), maxXY(head, ORIGIN)], false);\n                }\n            }\n\n            if (draggingKnob) {\n                window.document.body.style.cursor = 'crosshair';\n\n                const [cellX, cellY] = pixelToCell(xy);\n                let [[minX, minY], [maxX, maxY]] = normalizeSelection(selection);\n\n                // check if vertical or horizontal\n                let xCellDiff = Math.min(cellX - minX, maxX - cellX, 0); // zero or less\n                let yCellDiff = Math.min(cellY - minY, maxY - cellY, 0); // zero or less\n\n                if (isMaybeRowSelection(selection) || xCellDiff > yCellDiff) {\n                    if (cellY < minY) {\n                        minY = cellY;\n                    } else if (cellY > maxY) {\n                        maxY = cellY;\n                    }\n                } else {\n                    if (cellX < minX) {\n                        minX = cellX;\n                    } else if (cellX > maxX) {\n                        maxX = cellX;\n                    }\n                }\n\n                onKnobAreaChange?.([\n                    [minX, minY],\n                    [maxX, maxY],\n                ]);\n            }\n\n            if (columnDrag || rowDrag) {\n                const [x, y] = xy;\n                if (columnDrag) {\n                    const cellX = pixelToColumn(Math.max(x, getIndentX()), 0.5);\n                    const insideSelection = cellX >= minX && cellX <= maxX + 1;\n                    const insideGroup = isBoundaryInsideGroup(cellX, columnGroupKeys);\n\n                    const { anchor, scroll } = columnDrag;\n                    const shift = x - anchor;\n                    const [currentScroll] = getScrollPosition(e);\n\n                    onDragOffsetChange?.([shift + currentScroll - scroll, 0]);\n                    onDropTargetChange?.(\n                        insideSelection || insideGroup\n                            ? null\n                            : [\n                                  [cellX, -1],\n                                  [cellX, -1],\n                              ]\n                    );\n                }\n                if (rowDrag) {\n                    const cellY = pixelToRow(Math.max(y, getIndentY()), 0.5);\n                    const insideSelection = cellY >= minY && cellY <= maxY + 1;\n                    const insideGroup = isBoundaryInsideGroup(cellY, rowGroupKeys);\n\n                    const { anchor, scroll } = rowDrag;\n                    const shift = y - anchor;\n                    const [, currentScroll] = getScrollPosition(e);\n\n                    onDragOffsetChange?.([0, shift + currentScroll - scroll]);\n                    onDropTargetChange?.(\n                        insideSelection || insideGroup\n                            ? null\n                            : [\n                                  [-1, cellY],\n                                  [-1, cellY],\n                              ]\n                    );\n                }\n            }\n        },\n        [\n            getMousePosition,\n            getScrollPosition,\n            getMouseHit,\n            onCellWidthChange,\n            onCellHeightChange,\n            onDragIndicesChange,\n            onDragOffsetChange,\n            onDropTargetChange,\n            onSelectionChange,\n            onKnobAreaChange,\n            onInvalidateRow,\n            onInvalidateColumn,\n            columnGroupKeys,\n            rowGroupKeys,\n        ]\n    );\n\n    const onDoubleClick = useCallback(\n        (e: MouseEvent) => {\n            const {\n                current: {\n                    selection,\n                    cellLayout: { pixelToCell, columnToPixel },\n                },\n            } = ref;\n\n            e.preventDefault();\n            if (e.shiftKey) return;\n\n            const xy = getMousePosition(e);\n            if (!xy) return;\n\n            // Double click column divider to autosize\n            const [x] = xy;\n            const { columns } = visibleCells;\n            if (onCellWidthChange) {\n                const autosized = [];\n\n                for (const index of columns) {\n                    const edge = columnToPixel(index, 1);\n\n                    if (Math.abs(edge - x) < SIZES.resizeZone && canSizeColumn(index)) {\n                        const [[minX], [maxX]] = normalizeSelection(selection);\n\n                        // Autosize entire selection if double-clicking a right edge\n                        const indices =\n                            isColumnSelection(selection) && index >= minX && index <= maxX\n                                ? mapSelectionColumns(selection)((i) => i)\n                                : [index];\n\n                        autosized.push(...indices);\n                    }\n                }\n\n                for (const column of autosized) {\n                    onInvalidateColumn?.(column - 1);\n                    onCellWidthChange([column], getAutoSizeWidth(column));\n                }\n                if (autosized.length) return;\n            }\n\n            const hitTarget = getMouseHit(xy);\n            if (hitTarget) {\n                window.document.body.style.cursor = 'pointer';\n                return;\n            }\n\n            const editCell = pixelToCell(xy);\n            if (editMode) onCommit?.();\n            onEdit?.(editCell);\n        },\n        [\n            getMousePosition,\n            getMouseHit,\n            onCommit,\n            onEdit,\n            onInvalidateColumn,\n            onCellWidthChange,\n            getAutoSizeWidth,\n            visibleCells,\n            canSizeColumn,\n        ]\n    );\n\n    const onContextMenu = useCallback(\n        (e: MouseEvent) => {\n            const {\n                current: {\n                    cellLayout: { pixelToCell, getIndentX, getIndentY },\n                },\n            } = ref;\n\n            const xy = getMousePosition(e);\n            if (!xy) return;\n\n            const [x, y] = xy;\n            if (x <= getIndentX() || y <= getIndentY()) {\n                return;\n            }\n\n            // If click is not inside of selection, select the right clicked cell\n            const cell = pixelToCell(xy);\n            if (!isPointInsideSelection(selection, cell)) {\n                onSelectionChange?.([cell, cell]);\n            }\n\n            onPointerMove(e as any);\n\n            const [cellX, cellY] = cell;\n            const event: SheetMouseEvent = {\n                ...e,\n                cellX,\n                cellY,\n            };\n            onRightClick?.(event);\n        },\n        [getMousePosition, onSelectionChange, onPointerMove, onRightClick]\n    );\n\n    const mouseHandlers = {\n        onPointerLeave,\n        onPointerDown,\n        onPointerMove,\n        onPointerUp,\n        onDoubleClick,\n        onContextMenu,\n    };\n\n    return { knobPosition, mouseHandlers };\n};\n\nconst parseKnobOperation = (\n    knobArea: Rectangle,\n    selection: Rectangle,\n    sourceData: CellPropertyFunction<string | number | null>,\n    editData: CellPropertyFunction<string>,\n    cellReadOnly: CellPropertyFunction<boolean | null>\n): Change[] => {\n    const [[kx1, ky1], [kx2, ky2]] = normalizeSelection(knobArea);\n    const [[sx1, sy1], [sx2, sy2]] = normalizeSelection(selection);\n\n    let fx1 = kx1;\n    let fy1 = ky1;\n    let fx2 = kx2;\n    let fy2 = ky2;\n\n    const changes: Change[] = [];\n\n    // TODO: this should be made less cryptic, using logical selection ops/fns\n\n    if (fx2 - fx1 === sx2 - sx1) {\n        // vertical\n        if (fy1 === sy1) {\n            fy1 = sy2 + 1;\n        } else {\n            fy2 = sy1 - 1;\n        }\n        if (fx1 === -1 && fx2 === -1) {\n            const [maxX] = findApproxMaxEditDataIndex(editData);\n            fx1 = 0;\n            fx2 = maxX;\n        }\n        let srcY = sy1;\n        for (let y = fy1; y <= fy2; y++) {\n            for (let x = fx1; x <= fx2; x++) {\n                const value = sourceData(x, srcY);\n                if (!cellReadOnly(x, y)) {\n                    changes.push({ x: x, y: y, value: value, source: { x: x, y: srcY } });\n                }\n            }\n            srcY = srcY + 1;\n            if (srcY > sy2) {\n                srcY = sy1;\n            }\n        }\n    } else {\n        // horizontal\n        if (fx1 === sx1) {\n            fx1 = sx2 + 1;\n        } else {\n            fx2 = sx1 - 1;\n        }\n        if (fy1 === -1 && fy2 === -1) {\n            const [, maxY] = findApproxMaxEditDataIndex(editData);\n            fy1 = 0;\n            fy2 = maxY;\n        }\n        let srcX = sx1;\n        for (let x = fx1; x <= fx2; x++) {\n            for (let y = fy1; y <= fy2; y++) {\n                const value = sourceData(srcX, y);\n                if (!cellReadOnly(x, y)) {\n                    changes.push({ x: x, y: y, value: value, source: { x: srcX, y: y } });\n                }\n            }\n            srcX = srcX + 1;\n            if (srcX > sx2) {\n                srcX = sx1;\n            }\n        }\n    }\n\n    return changes;\n};\n","import { UIEvent, useCallback } from 'react';\nimport { XY, CellLayout } from './types';\nimport { isSameXY, maxXY, mulXY } from './coordinate';\nimport { ONE_ONE } from './constants';\n\nexport const useScroll = (\n    offset: XY,\n    maxScroll: XY,\n    cellLayout: CellLayout,\n    onOffsetChange?: (offset: XY) => void,\n    onMaxScrollChange?: (maxScroll: XY) => void\n) => {\n    return useCallback(\n        (e: UIEvent) => {\n            if (!e.target || !(e.target instanceof Element)) {\n                return;\n            }\n            const { absoluteToCell, cellToAbsolute } = cellLayout;\n\n            // Zero scroll position is considered in the center of the top/left cell\n            const [nudgeX, nudgeY] = cellToAbsolute([0, 0], [0.5, 0.5]);\n\n            const xy: XY = [e.target.scrollLeft + nudgeX, e.target.scrollTop + nudgeY];\n\n            const cell = absoluteToCell(xy);\n            if (!isSameXY(cell, offset)) {\n                onOffsetChange?.(cell);\n            }\n\n            const [x, y] = xy;\n            const [maxScrollX, maxScrollY] = maxScroll;\n            const growX = maxScrollX < x + 1 ? 1.5 : 1;\n            const growY = maxScrollY < y + 1 ? 1.5 : 1;\n            if (growX > 1 || growY > 1) {\n                onMaxScrollChange?.(mulXY(maxScroll, [growX, growY]));\n            }\n        },\n        [cellLayout, onOffsetChange, onMaxScrollChange]\n    );\n};\n\n// If view extends past end of table\n// Limit view to table contents\nexport const clipDataOffset = (view: XY, offset: XY, freeze: XY, maxCells: XY, cellLayout: CellLayout): XY => {\n    let [newX, newY] = offset;\n    const [maxColumns, maxRows] = maxCells;\n\n    const { absoluteToColumn, columnToAbsolute, absoluteToRow, rowToAbsolute } = cellLayout;\n\n    const {\n        edge: [rightEdge, bottomEdge],\n        viewport: [scrollW, scrollH],\n    } = getViewExtent(view, [newX, newY], freeze, cellLayout);\n\n    // Move extra space on the right/bottom to equivalent on the left/top\n    if (rightEdge > maxColumns) {\n        const remainder = columnToAbsolute(maxColumns) - columnToAbsolute(newX);\n        newX = absoluteToColumn(columnToAbsolute(newX) - scrollW + remainder) + 1;\n    }\n    if (bottomEdge > maxRows) {\n        const remainder = rowToAbsolute(maxRows) - rowToAbsolute(newY);\n        newY = absoluteToRow(rowToAbsolute(newY) - scrollH + remainder) + 1;\n    }\n\n    return [newX, newY];\n};\n\n// Get bottom-right corner cell + non-frozen viewport size\nexport const getViewExtent = (\n    view: XY,\n    offset: XY,\n    freeze: XY,\n    cellLayout: CellLayout\n): {\n    edge: XY;\n    viewport: XY;\n} => {\n    const {\n        cellToAbsolute,\n        absoluteToColumn,\n        columnToAbsolute,\n        absoluteToRow,\n        rowToAbsolute,\n        getIndentX,\n        getIndentY,\n    } = cellLayout;\n\n    const [x, y] = offset;\n    const [w, h] = view;\n    const [frozenX, frozenY] = cellToAbsolute(freeze);\n\n    const scrollW = w - frozenX - getIndentX();\n    const scrollH = h - frozenY - getIndentY();\n\n    const leftEdge = x + freeze[0];\n    const topEdge = y + freeze[1];\n    const rightEdge = absoluteToColumn(columnToAbsolute(leftEdge) + scrollW);\n    const bottomEdge = absoluteToRow(rowToAbsolute(topEdge) + scrollH);\n\n    return {\n        edge: [rightEdge, bottomEdge],\n        viewport: [scrollW, scrollH],\n    };\n};\n\nexport const scrollToCell = (\n    element: HTMLDivElement,\n    cell: XY,\n    view: XY,\n    freeze: XY,\n    offset: XY,\n    maxScroll: XY,\n    cellLayout: CellLayout,\n    callback: (offset: XY, maxScroll: XY) => void\n) => {\n    const [x, y] = cell;\n    const [w, h] = view;\n    const [offsetX, offsetY] = offset;\n\n    const { cellToAbsolute, cellToPixel, columnToPixel, rowToPixel } = cellLayout;\n\n    const [frozenX, frozenY] = cellToAbsolute(freeze);\n    const [left, top] = cellToPixel(cell);\n    const [right, bottom] = cellToPixel(cell, ONE_ONE);\n\n    let [newX, newY] = offset;\n\n    // If moving left/up, scroll to head\n    if (left <= frozenX) {\n        newX = x - freeze[0];\n    }\n    if (top <= frozenY) {\n        newY = y - freeze[1];\n    }\n\n    // If moving right/down, scroll cell by cell until right/bottom of cell is visible\n    if (right > w) {\n        let edge = right - w + columnToPixel(newX);\n        while (columnToPixel(++newX) < edge) {}\n    }\n    if (bottom > h) {\n        let edge = bottom - h + rowToPixel(newY);\n        while (rowToPixel(++newY) < edge) {}\n    }\n\n    // Don't scroll on infinite axis\n    const newOffset: XY = [newX >= 0 ? newX : offsetX, newY >= 0 ? newY : offsetY];\n\n    if (!isSameXY(newOffset, offset)) {\n        const scroll = cellToAbsolute(newOffset);\n        const [nudgeX, nudgeY] = cellToAbsolute([0, 0], [0.5, 0.5]);\n\n        callback(newOffset, maxXY(maxScroll, scroll));\n        setTimeout(() => {\n            const [scrollX, scrollY] = scroll;\n            element.scrollLeft = scrollX - nudgeX;\n            element.scrollTop = scrollY - nudgeY;\n        });\n    }\n};\n","import { InternalSheetStyle, SheetStyle, Style } from './types';\nimport { COLORS, SIZES } from './constants';\n\nexport const resolveSheetStyle = (sheetStyle?: SheetStyle): InternalSheetStyle => {\n    return {\n        freezeColumns: sheetStyle?.freezeColumns || 0,\n        freezeRows: sheetStyle?.freezeRows || 0,\n        hideColumnHeaders: sheetStyle?.hideColumnHeaders || false,\n        hideRowHeaders: sheetStyle?.hideRowHeaders || false,\n        hideGridlines: sheetStyle?.hideGridlines || false,\n        hideScrollBars: sheetStyle?.hideScrollBars || false,\n        columnHeaderHeight: sheetStyle?.hideColumnHeaders ? 1 : SIZES.headerHeight,\n        rowHeaderWidth: sheetStyle?.hideRowHeaders ? 1 : SIZES.headerWidth,\n        shadowBlur: sheetStyle?.shadowBlur ?? SIZES.shadowBlur,\n        shadowOpacity: sheetStyle?.shadowOpacity ?? SIZES.shadowOpacity,\n        shadowColor: sheetStyle?.shadowColor ?? COLORS.shadowColor,\n    };\n};\n\nexport const resolveCellStyle = (optionalStyle: Style, defaultStyle: Required<Style>): Required<Style> => {\n    return {\n        ...defaultStyle,\n        ...optionalStyle,\n    };\n};\n\nexport const applyAlignment = (\n    start: number,\n    cellSize: number,\n    style: Required<Style>,\n    imageWidth: number,\n    alignment: 'left' | 'center' | 'right' = style.textAlign\n): number => {\n    if (alignment === 'left') {\n        return start + style.marginLeft;\n    } else if (alignment === 'center') {\n        return start + cellSize * 0.5 - imageWidth / 2;\n    } else if (alignment === 'right') {\n        return start + (cellSize - style.marginRight - imageWidth);\n    }\n    return start;\n};\n","import { CellPropertyFunction, Change, ParsedChange, Rectangle } from './types';\nimport { RefObject, useLayoutEffect, useEffect } from 'react';\nimport { findApproxMaxEditDataIndex } from './props';\nimport { normalizeSelection, isMaybeRowSelection, isMaybeColumnSelection, isEmptySelection } from './coordinate';\n\nexport const useClipboardCopy = (\n    textAreaRef: RefObject<HTMLTextAreaElement>,\n    selection: Rectangle,\n    editMode: boolean,\n    editData: CellPropertyFunction<string>\n) => {\n    useLayoutEffect(() => {\n        const { current: textArea } = textAreaRef;\n        if (!textArea) return;\n\n        if (editMode) return;\n        if (isEmptySelection(selection)) return;\n\n        let v = formatSelectionAsTSV(selection, editData);\n\n        // Bizarre: having only TAB/RETURN characters inside the textarea\n        // prevents native auto-scroll. Also bizarre: auto-scroll doesn't work\n        // if we don't focus the textarea at all.\n        if (v.match(/^[\\t\\n]*$/)) {\n            v = ' ' + v;\n        }\n        textArea.value = v;\n    }, [selection, editMode, editData, textAreaRef]);\n\n    useLayoutEffect(() => {\n        const { current: textArea } = textAreaRef;\n        if (!textArea) return;\n\n        const focus = () => {\n            textArea.focus({ preventScroll: true });\n            textArea.select();\n        };\n\n        if (editMode) return;\n        if (document.activeElement === textArea) return;\n\n        const activeTagName = (document as any).activeElement.tagName.toLowerCase();\n        if (\n            !(\n                (activeTagName === 'div' && (document as any).activeElement.contentEditable === 'true') ||\n                activeTagName === 'input' ||\n                activeTagName === 'textarea' ||\n                activeTagName === 'select'\n            )\n        ) {\n            focus();\n        }\n    });\n};\n\nexport const useClipboardPaste = (\n    textAreaRef: RefObject<HTMLTextAreaElement>,\n    selection: Rectangle,\n    onSelectionChange?: (selection: Rectangle) => void,\n    onChange?: (changes: Array<Change>) => void,\n    isReadOnly?: CellPropertyFunction<boolean>\n) => {\n    useEffect(() => {\n        const onPaste = (e: any) => {\n            const { current: textArea } = textAreaRef;\n            if (!textArea) return;\n\n            if (e.target !== textArea) return;\n            e.preventDefault();\n\n            const clipboardData = e.clipboardData || (window as any).clipboardData;\n            const types = clipboardData.types;\n\n            let parsed;\n            if (types.includes('text/html')) {\n                const pastedHtml = clipboardData.getData('text/html');\n                parsed = parsePastedHtml(selection, pastedHtml, isReadOnly);\n            } else if (types.includes('text/plain')) {\n                const text = clipboardData.getData('text/plain');\n                parsed = parsePastedText(selection, text, isReadOnly);\n            }\n            if (!parsed) return;\n\n            const { selection: s, changes } = parsed;\n            onChange?.(changes);\n            onSelectionChange?.(s);\n        };\n\n        window.document.addEventListener('paste', onPaste);\n        return () => {\n            window.document.removeEventListener('paste', onPaste);\n        };\n    }, [textAreaRef, selection]);\n};\n\nconst formatTSV = (rows: string[][]) => rows.map((row) => row.join('\\t')).join('\\n');\n\nconst formatSelectionAsTSV = (selection: Rectangle, editData: CellPropertyFunction<string>) => {\n    if (isEmptySelection(selection)) return '';\n\n    let [[minX, minY], [maxX, maxY]] = normalizeSelection(selection);\n    if (isMaybeRowSelection(selection)) {\n        const [cellX] = findApproxMaxEditDataIndex(editData);\n        minX = 0;\n        maxX = cellX;\n    }\n    if (isMaybeColumnSelection(selection)) {\n        const [, cellY] = findApproxMaxEditDataIndex(editData);\n        minY = 0;\n        maxY = cellY;\n    }\n\n    const rows: string[][] = [];\n\n    for (let y = minY; y <= maxY; y++) {\n        const row: string[] = [];\n\n        for (let x = minX; x <= maxX; x++) {\n            const value = editData(x, y);\n            if (value !== null && value !== undefined) {\n                row.push(value != null ? value : '');\n            }\n        }\n\n        rows.push(row);\n    }\n\n    return formatTSV(rows);\n};\n\nconst findTable = (element: any): any => {\n    for (const child of element.children) {\n        if (child.nodeName === 'TABLE') {\n            return child;\n        }\n        const maybeTable = findTable(child);\n        if (maybeTable) {\n            return maybeTable;\n        }\n    }\n};\n\nconst parsePastedHtml = (\n    selection: Rectangle,\n    html: string,\n    isReadOnly?: CellPropertyFunction<boolean>\n): ParsedChange | null => {\n    const div = document.createElement('div');\n    div.innerHTML = html.trim();\n\n    const [[minX, minY]] = normalizeSelection(selection);\n    let left = isMaybeRowSelection(selection) ? 0 : minX;\n    let top = isMaybeColumnSelection(selection) ? 0 : minY;\n\n    const changes = [];\n\n    const tableNode = findTable(div);\n    if (!tableNode) {\n        return null;\n    }\n\n    let right = left;\n    let bottom = top;\n\n    let y = top;\n    for (const tableChild of tableNode.children) {\n        if (tableChild.nodeName === 'TBODY') {\n            for (const tr of tableChild.children) {\n                let x = left;\n                if (tr.nodeName === 'TR') {\n                    for (const td of tr.children) {\n                        if (td.nodeName === 'TD') {\n                            let str: string = '';\n                            if (td.children.length !== 0 && td.children[0].nodeName === 'P') {\n                                const p = td.children[0];\n                                if (p.children.length !== 0 && p.children[0].nodeName === 'FONT') {\n                                    str = p.children[0].textContent.trim();\n                                } else {\n                                    str = p.textContent.trim();\n                                }\n                            } else {\n                                str = td.textContent.trim();\n                            }\n                            str = str.replaceAll('\\n', '');\n                            str = str.replaceAll(/\\s\\s+/g, ' ');\n\n                            if (!isReadOnly?.(x, y)) changes.push({ x, y, value: str });\n                            x++;\n                        }\n                    }\n                    y++;\n                }\n                right = Math.max(right, x - 1);\n            }\n        }\n    }\n    bottom = Math.max(top, y - 1);\n\n    return {\n        selection: [\n            [left, top],\n            [right, bottom],\n        ],\n        changes,\n    };\n};\n\nconst parsePastedText = (\n    selection: Rectangle,\n    text: string,\n    isReadOnly?: CellPropertyFunction<boolean>\n): ParsedChange => {\n    const [[minX, minY]] = normalizeSelection(selection);\n    let left = isMaybeRowSelection(selection) ? 0 : minX;\n    let top = isMaybeColumnSelection(selection) ? 0 : minY;\n\n    const rows = text.split(/\\r?\\n/);\n    let right = left;\n    let bottom = top + rows.length - 1;\n\n    const changes = [];\n    for (let y = 0; y < rows.length; y++) {\n        const cols = rows[y].split('\\t');\n        right = Math.max(right, left + cols.length - 1);\n\n        for (let x = 0; x < cols.length; x++) {\n            const X = left + x;\n            const Y = top + y;\n\n            if (!isReadOnly?.(X, Y)) changes.push({ x: X, y: Y, value: cols[x] });\n        }\n    }\n\n    return {\n        selection: [\n            [left, top],\n            [right, bottom],\n        ],\n        changes,\n    };\n};\n","import { XY, CellLayout, VisibleLayout, LayoutCache } from './types';\nimport { seq } from './util';\nimport { ORIGIN } from './constants';\n\nconst INITIAL_SIZE = 256;\n\n// Local cell layout (virtualized with frozen columns/rows)\n//\n// - converts cell indices to (x, y) canvas pixels for any cell, including off-screen\n// - maps (x, y) canvas pixels back to cell index for any visible cell\n// - can also generate absolute, unscrolled offsets relative to (0,0) to drive scrolling\n// - generates list of visible cols/rows in view\n//\n// Note that adjacent column indices are not necessarily adjacent, i.e. end of [i] != start of [i + 1].\nexport const makeCellLayout = (\n    freeze: XY,\n    indent: XY,\n    offset: XY,\n\n    columns: LayoutCache,\n    rows: LayoutCache\n): CellLayout => {\n    const [freezeX, freezeY] = freeze;\n    const [indentX, indentY] = indent;\n    const [offsetX, offsetY] = offset;\n\n    const getIndentX = () => indentX;\n    const getIndentY = () => indentY;\n\n    // Origin for cell, frozen or relative\n    const getBaseOriginFor = (index: number, freeze: number, offset: number) => {\n        return index < freeze ? 0 : offset + freeze;\n    };\n\n    // Get visible pixel x of cell\n    const columnToPixel = (column: number, anchor: number = 0): number => {\n        const base = getBaseOriginFor(column, freezeX, offsetX);\n        const relative = columns.getStart(column) - columns.getStart(base);\n        const adjust = column < freezeX ? 0 : columns.getStart(freezeX) - columns.getStart(0);\n        const size = column < 0 ? indentX : columns.getSize(column);\n\n        return column < 0 ? 0 : indentX + relative + adjust + anchor * size;\n    };\n\n    // Get visible pixel y of cell\n    const rowToPixel = (row: number, anchor: number = 0): number => {\n        const base = getBaseOriginFor(row, freezeY, offsetY);\n        const relative = rows.getStart(row) - rows.getStart(base);\n        const adjust = row < freezeY ? 0 : rows.getStart(freezeY) - rows.getStart(0);\n        const size = row < 0 ? indentY : rows.getSize(row);\n\n        return row < 0 ? 0 : indentY + relative + adjust + anchor * size;\n    };\n\n    // Get visible pixel position of cell, offset with anchor [0..1, 0..1]\n    const cellToPixel = (cell: XY, anchor: XY = ORIGIN): XY => {\n        const [cellX, cellY] = cell;\n        const [anchorX, anchorY] = anchor;\n        return [columnToPixel(cellX, anchorX), rowToPixel(cellY, anchorY)];\n    };\n\n    // Get absolute / unscrolled pixel x of cell\n    const columnToAbsolute = (column: number, anchorX: number = 0): number => {\n        const relative = columns.getStart(column);\n        const size = column < 0 ? 0 : columns.getSize(column);\n\n        return relative + anchorX * size;\n    };\n\n    // Get absolute / unscrolled pixel y of cell\n    const rowToAbsolute = (row: number, anchorY: number = 0): number => {\n        const relative = rows.getStart(row);\n        const size = row < 0 ? 0 : rows.getSize(row);\n\n        return relative + anchorY * size;\n    };\n\n    // Get absolute / unscrolled pixel position of cell, offset with anchor [0..1, 0..1]\n    const cellToAbsolute = (cell: XY, anchor: XY = ORIGIN): XY => {\n        const [cellX, cellY] = cell;\n        const [anchorX, anchorY] = anchor;\n        return [columnToAbsolute(cellX, anchorX), rowToAbsolute(cellY, anchorY)];\n    };\n\n    // Lookup pixel X or Y in cell layout\n    const pixelToIndex = (\n        pixel: number,\n        anchor: number,\n        indent: number,\n        freeze: number,\n        offset: number,\n        layout: LayoutCache\n    ) => {\n        const relative = pixel - indent;\n        if (relative < 0) return -1;\n\n        const { getStart, lookupIndex } = layout;\n        const frozen = getStart(freeze);\n        if (relative < frozen) {\n            return lookupIndex(relative, anchor);\n        } else {\n            const base = getStart(offset + freeze);\n            const adjust = getStart(freeze) - getStart(0);\n            return lookupIndex(base + relative - adjust, anchor);\n        }\n    };\n\n    // Lookup pixel X or Y in cell layout (helpers)\n    const pixelToColumn = (pixelX: number, anchorX: number = 0) =>\n        pixelToIndex(pixelX, anchorX, indentX, freezeX, offsetX, columns);\n    const pixelToRow = (pixelY: number, anchorY: number = 0) =>\n        pixelToIndex(pixelY, anchorY, indentY, freezeY, offsetY, rows);\n\n    // Lookup pixel XY in cell layout\n    const pixelToCell = (pixel: XY, anchor: XY = ORIGIN): XY => {\n        const [pixelX, pixelY] = pixel;\n        const [anchorX, anchorY] = anchor;\n        return [pixelToColumn(pixelX, anchorX), pixelToRow(pixelY, anchorY)];\n    };\n\n    // Lookup absolute / unscrolled pixel X or Y in cell layout\n    const absoluteToIndex = (pixel: number, anchor: number, layout: LayoutCache) => {\n        if (pixel < 0) return -1;\n\n        const { lookupIndex } = layout;\n        return lookupIndex(pixel, anchor);\n    };\n\n    // Lookup absolute / unscrolled X or Y in cell layout (helpers)\n    const absoluteToColumn = (pixelX: number, anchorX: number = 0) => absoluteToIndex(pixelX, anchorX, columns);\n    const absoluteToRow = (pixelY: number, anchorY: number = 0) => absoluteToIndex(pixelY, anchorY, rows);\n\n    // Lookup absolute / unscrolled XY in cell layout\n    const absoluteToCell = (pixel: XY, anchor: XY = ORIGIN): XY => {\n        const [pixelX, pixelY] = pixel;\n        const [anchorX, anchorY] = anchor;\n        return [absoluteToColumn(pixelX, anchorX), absoluteToRow(pixelY, anchorY)];\n    };\n\n    // Get visible range of columns or rows\n    const getVisibleIndices = (view: number, indent: number, freeze: number, offset: number, layout: LayoutCache) => {\n        const indices = [...seq(freeze)];\n\n        const { getStart, getEnd } = layout;\n\n        const frozen = getEnd(freeze - 1);\n        const notFrozen = getStart(offset + freeze);\n\n        const relative = view - indent - frozen;\n        for (let i = offset + freeze; getStart(i) - notFrozen <= relative; ++i) {\n            indices.push(i);\n        }\n\n        return indices;\n    };\n\n    // Get visible range for an XY viewport\n    const getVisibleCells = (view: XY): VisibleLayout => {\n        const [viewX, viewY] = view;\n        return {\n            columns: getVisibleIndices(viewX, indentX, freezeX, offsetX, columns),\n            rows: getVisibleIndices(viewY, indentY, freezeY, offsetY, rows),\n        };\n    };\n\n    const getVersion = () => columns.getVersion() + rows.getVersion();\n\n    return {\n        columnToPixel,\n        rowToPixel,\n        cellToPixel,\n\n        columnToAbsolute,\n        rowToAbsolute,\n        cellToAbsolute,\n\n        pixelToColumn,\n        pixelToRow,\n        pixelToCell,\n\n        absoluteToColumn,\n        absoluteToRow,\n        absoluteToCell,\n\n        getVisibleCells,\n        getIndentX,\n        getIndentY,\n\n        getVersion,\n    };\n};\n\n// Offset cache in 1 dimension.\n//\n// Allows O(1) queries of distance between any two points, once warmed up.\n// Can do reverse lookup back to index with binary search, once warmed up.\n//\n// - caches sizer(i), each is only called once\n// - offset[0] = 0\n// - adds up offset[i] = sizer(0) + sizer(1) + ... + sizer(i - 1)\n// - cache can be truncated during resizing ops at split\n// - to replace sizer function, cache must be destroyed\nexport const makeLayoutCache = (sizer: (index: number) => number): LayoutCache => {\n    const offsets = makeIntMap(INITIAL_SIZE);\n    const sizes = makeIntMap(INITIAL_SIZE);\n\n    let version = 0;\n    offsets.set(0, 0);\n\n    // Cache size lookup directly\n    const getSize = (i: number): number => {\n        if (i < 0) return 0;\n        if (sizes.has(i)) return sizes.get(i)!;\n\n        const size = sizer(i) || 0;\n        sizes.set(i, size);\n        return size;\n    };\n\n    // Cache offset sum recursively\n    const getOffset = (i: number): number => {\n        if (i < 0) return 0;\n        if (offsets.has(i)) return offsets.get(i)!;\n\n        let j = offsets.tail() || 0;\n\n        // Use a while loop to avoid stack overflow\n        while (j < i) {\n            const size = getSize(j);\n            const offset = (offsets.get(j) || 0) + size;\n            offsets.set(++j, offset);\n        }\n\n        return offsets.get(i)!;\n    };\n\n    // Boundary points\n    const getStart = (i: number) => getOffset(i);\n    const getEnd = (i: number) => getOffset(i + 1);\n\n    // Reverse lookup from offset to index\n    const lookupIndex = (x: number, anchor: number = 0) => {\n        // Get end of offsets array\n        let last = offsets.tail() || 0;\n\n        // Extend cache if value exceeds current end\n        while (getOffset(last) < x && getSize(last)) last += 64;\n\n        // Do binary search for exact position\n        let start = 0;\n        let end = last;\n        while (start < end) {\n            let mid = start + Math.floor((end - start) / 2) + 1;\n            let value = getOffset(mid) - (anchor ? anchor * getSize(mid - 1) : 0);\n            if (value <= x) start = mid;\n            else end = mid - 1;\n        }\n\n        return start;\n    };\n\n    const clearAfter = (index: number) => {\n        index = Math.max(0, index);\n        offsets.truncate(index);\n        sizes.truncate(index);\n        version++;\n    };\n\n    const setSizer = (s: (index: number) => number) => {\n        sizer = s;\n    };\n    const getVersion = () => version;\n\n    return { getSize, getStart, getEnd, getVersion, lookupIndex, setSizer, clearAfter };\n};\n\n// Fast map<integer, integer> that is mostly filled in from start to end.\n// Elements are only removed by truncating all indices > n.\nconst makeIntMap = (initialSize: number = 128) => {\n    let used: Uint8Array;\n    let values: Uint32Array;\n    let last = 0;\n\n    const GROW = 1.2; // 20% growth at a time\n\n    const allocate = (size: number) => {\n        let newUsed = new Uint8Array(size);\n        let newValues = new Uint32Array(size);\n        if (used) copy(used, newUsed);\n        if (values) copy(values, newValues);\n        used = newUsed;\n        values = newValues;\n    };\n    allocate(initialSize);\n\n    const copy = (from: Uint8Array | Uint32Array, to: Uint8Array | Uint32Array) => {\n        let n = Math.min(from.length, to.length);\n        for (let i = 0; i < n; ++i) {\n            to[i] = from[i];\n        }\n    };\n\n    const ensure = (size: number) => {\n        const l = values.length;\n        const grow = Math.round(l * GROW);\n        if (l < size) allocate(Math.max(grow, size));\n    };\n\n    const truncate = (size: number) => {\n        const l = values.length;\n\n        // Do nothing if smaller\n        if (l < size) return;\n\n        // If more than 20% bigger, shrink to exact size\n        const shrink = Math.round(size * GROW);\n        if (l > shrink) allocate(size);\n        // Else zero out tail\n        else for (let i = size; i < l; ++i) used[i] = 0;\n\n        // Track last filled element\n        last = Math.min(last, size);\n        while (last > 0 && !used[last]) last--;\n    };\n\n    const getTail = () => (used[last] ? last : null);\n\n    const setValue = (i: number, value: number) => {\n        ensure(i + 1);\n        values[i] = value;\n        used[i] = 1;\n        last = Math.max(last, i);\n    };\n\n    const getValue = (i: number) => (used[i] ? values[i] : null);\n    const hasValue = (i: number) => !!used[i];\n\n    return { truncate, set: setValue, get: getValue, has: hasValue, tail: getTail };\n};\n","import {\n    CellLayout,\n    CellPropertyFunction,\n    RowOrColumnPropertyFunction,\n    InternalSheetStyle,\n    Rectangle,\n    Selection,\n    Clickable,\n    Style,\n    CellContentType,\n    VisibleLayout,\n    XY,\n} from './types';\nimport { applyAlignment, resolveCellStyle } from './style';\nimport { normalizeSelection, isEmptySelection, isColumnSelection, isRowSelection } from './coordinate';\nimport { isInRange, isInRangeLeft, isInRangeCenter } from './util';\nimport {\n    COLORS,\n    SIZES,\n    DEFAULT_CELL_STYLE,\n    DEFAULT_COLUMN_HEADER_STYLE,\n    HEADER_SELECTED_STYLE,\n    HEADER_GROUP_SELECTED_STYLE,\n    HEADER_ACTIVE_STYLE,\n    NO_STYLE,\n    ONE_ONE,\n} from './constants';\n\nexport const renderSheet = (\n    context: CanvasRenderingContext2D,\n    cellLayout: CellLayout,\n    visibleCells: VisibleLayout,\n\n    sheetStyle: InternalSheetStyle,\n    cellStyle: CellPropertyFunction<Style>,\n\n    selection: Rectangle,\n    secondarySelections: Selection[],\n\n    knobPosition: XY | null,\n    knobArea: Rectangle | null,\n    dragIndices: [number[] | null, number[] | null],\n    dragOffset: XY | null,\n    dropTarget: Rectangle | null,\n\n    columnHeaders: RowOrColumnPropertyFunction<CellContentType>,\n    columnHeaderStyle: RowOrColumnPropertyFunction<Style>,\n    displayData: CellPropertyFunction<CellContentType>,\n\n    columnGroupKeys: RowOrColumnPropertyFunction<string | number | null>,\n    rowGroupKeys: RowOrColumnPropertyFunction<string | number | null>,\n    selectedColumnGroups: Set<string | number | null> | null,\n    selectedRowGroups: Set<string | number | null> | null,\n\n    dataOffset: XY\n): Clickable[] => {\n    const { canvas } = context;\n    const { width, height } = canvas;\n    const {\n        hideGridlines,\n        hideRowHeaders,\n        hideColumnHeaders,\n        rowHeaderWidth,\n        columnHeaderHeight,\n        freezeColumns,\n        freezeRows,\n        shadowBlur,\n        shadowColor,\n        shadowOpacity,\n    } = sheetStyle;\n    const { columns, rows } = visibleCells;\n    const { columnToPixel, rowToPixel, columnToAbsolute, rowToAbsolute } = cellLayout;\n\n    const clickables: Clickable[] = [];\n\n    const freeze: XY = [freezeColumns, freezeRows];\n    const indent: XY = [rowHeaderWidth, columnHeaderHeight];\n\n    resizeCanvas(canvas);\n    context.clearRect(0, 0, width, height);\n    context.fillStyle = 'white';\n    context.fillRect(0, 0, width, height);\n    context.shadowColor = '#00000080';\n\n    // Cell fill\n    for (const y of rows) {\n        for (const x of columns) {\n            const left = columnToPixel(x);\n            const right = columnToPixel(x, 1);\n            const top = rowToPixel(y);\n            const bottom = rowToPixel(y, 1);\n\n            const { fillColor } = cellStyle(x, y);\n            if (fillColor) {\n                context.fillStyle = fillColor;\n                context.fillRect(left, top, right - left, bottom - top);\n            }\n        }\n    }\n\n    const selectionActive = !isEmptySelection(selection);\n    const rowSelectionActive = isRowSelection(selection);\n    const columnSelectionActive = isColumnSelection(selection);\n\n    // Get selection range\n    const [selected, hideKnob] = resolveFrozenSelection(selection, cellLayout, freeze, indent, dataOffset);\n\n    // Selection fill\n    if (selectionActive) {\n        const [[left, top], [right, bottom]] = selected;\n        context.fillStyle = COLORS.selectionBackground;\n        context.fillRect(left, top, right - left, bottom - top);\n    }\n\n    if (!hideRowHeaders) {\n        // Row header background\n        context.fillStyle = COLORS.headerBackground;\n        context.fillRect(0, 0, rowHeaderWidth, context.canvas.height);\n\n        // Row header selection shadow\n        if (selectionActive && !columnSelectionActive) {\n            const [[, top], [, bottom]] = selected;\n            context.fillStyle = COLORS.headerActive;\n            context.fillRect(0, top, rowHeaderWidth, bottom - top);\n        }\n    }\n\n    if (!hideColumnHeaders) {\n        // Column header background\n        context.fillStyle = COLORS.headerBackground;\n        context.fillRect(0, 0, context.canvas.width, columnHeaderHeight);\n\n        // Column header selection shadow\n        if (selectionActive && !rowSelectionActive) {\n            const [[left], [right]] = selected;\n            context.fillStyle = COLORS.headerActive;\n            context.fillRect(left, 0, right - left, columnHeaderHeight);\n        }\n    }\n\n    // Grid\n    context.strokeStyle = COLORS.gridLine;\n    context.lineWidth = 1;\n\n    const gridRight = hideGridlines ? rowHeaderWidth : context.canvas.width;\n    const gridBottom = hideGridlines ? columnHeaderHeight : context.canvas.height;\n\n    const drawGridLineX = (x: number, height: number) => {\n        context.beginPath();\n        context.moveTo(x - 0.5, 0);\n        context.lineTo(x - 0.5, height);\n        context.stroke();\n    };\n\n    const drawGridLineY = (y: number, width: number) => {\n        context.beginPath();\n        context.moveTo(0, y - 0.5);\n        context.lineTo(width, y - 0.5);\n        context.stroke();\n    };\n\n    drawGridLineX(rowHeaderWidth, context.canvas.height);\n    drawGridLineY(columnHeaderHeight, context.canvas.width);\n\n    for (const column of columns) {\n        const right = columnToPixel(column, 1);\n        drawGridLineX(right, gridBottom);\n    }\n\n    for (const row of rows) {\n        const bottom = rowToPixel(row, 1);\n        drawGridLineY(bottom, gridRight);\n    }\n\n    const [[minX, minY], [maxX, maxY]] = normalizeSelection(selection);\n\n    // Row header text\n    if (!hideRowHeaders) {\n        context.textBaseline = 'middle';\n        context.textAlign = 'center';\n        context.font = DEFAULT_CELL_STYLE.fontSize + 'px ' + DEFAULT_CELL_STYLE.fontFamily;\n        context.fillStyle = COLORS.headerText;\n\n        for (const row of rows) {\n            const content = `${row + 1}`;\n\n            // Row selection mode\n            // (this is separate from the header selection shadow because we only want to highlight visible headers)\n            const isActive = isInRange(row, minY, maxY);\n\n            const groupKey = rowGroupKeys(row);\n            const isInRowGroup = groupKey != null && selectedRowGroups?.has(groupKey);\n\n            const isSelfSelected = rowSelectionActive && isActive;\n            const isGroupSelected = rowSelectionActive && isInRowGroup;\n\n            const style = isSelfSelected\n                ? HEADER_SELECTED_STYLE\n                : isGroupSelected\n                ? HEADER_GROUP_SELECTED_STYLE\n                : isActive\n                ? HEADER_ACTIVE_STYLE\n                : NO_STYLE;\n\n            const top = rowToPixel(row);\n            const bottom = rowToPixel(row, 1);\n\n            clickables.push(\n                ...renderCell(\n                    context,\n                    content,\n                    style,\n                    DEFAULT_COLUMN_HEADER_STYLE,\n                    0,\n                    top,\n                    rowHeaderWidth,\n                    bottom - top\n                )\n            );\n        }\n    }\n\n    // Column header text\n    if (!hideColumnHeaders) {\n        context.textBaseline = 'middle';\n        context.textAlign = 'center';\n\n        for (const column of columns) {\n            const content = columnHeaders(column) ?? excelHeaderString(column + 1);\n\n            // Column selection mode\n            // (this is separate from the header selection shadow because we only want to highlight visible headers)\n            const isActive = isInRange(column, minX, maxX);\n\n            const groupKey = columnGroupKeys(column);\n            const isInColumnGroup = groupKey != null && selectedColumnGroups?.has(groupKey);\n\n            const isSelected = columnSelectionActive && !rowSelectionActive && (isActive || isInColumnGroup);\n            const selectedStyle = isSelected ? HEADER_SELECTED_STYLE : NO_STYLE;\n            const activeStyle = isActive ? HEADER_ACTIVE_STYLE : NO_STYLE;\n            const style = {\n                ...columnHeaderStyle(column),\n                ...activeStyle,\n                ...selectedStyle,\n            };\n\n            const left = columnToPixel(column);\n            const right = columnToPixel(column, 1);\n\n            clickables.push(\n                ...renderCell(\n                    context,\n                    content,\n                    style,\n                    DEFAULT_COLUMN_HEADER_STYLE,\n                    left,\n                    0,\n                    right - left,\n                    columnHeaderHeight\n                )\n            );\n        }\n    }\n\n    // Selection outline\n    if (selectionActive) {\n        context.strokeStyle = COLORS.selectionBorder;\n        context.lineWidth = 2;\n\n        const [[left, top], [right, bottom]] = selected;\n        context.strokeRect(left, top, right - left - 1, bottom - top - 1);\n    }\n\n    for (const secondarySelection of secondarySelections) {\n        const selection = secondarySelection.span;\n        if (isEmptySelection(selection)) continue;\n\n        const [selected] = resolveFrozenSelection(selection, cellLayout, freeze, indent, dataOffset);\n        const [[left, top], [right, bottom]] = selected;\n\n        context.strokeStyle = secondarySelection.color;\n        context.lineWidth = 1;\n        context.beginPath();\n        context.strokeRect(left - 1, top - 1, right - left + 1, bottom - top + 1);\n    }\n\n    // Knob drag outline\n    if (knobArea) {\n        let [[minX, minY], [maxX, maxY]] = normalizeSelection(knobArea);\n        const left = columnToPixel(minX);\n        const top = rowToPixel(minY);\n        const right = columnToPixel(maxX, 1);\n        const bottom = rowToPixel(maxY, 1);\n\n        context.strokeStyle = COLORS.knobAreaBorder;\n        context.setLineDash([3, 3]);\n        context.lineWidth = 1;\n\n        context.strokeRect(left - 1, top - 1, right - left + 1, bottom - top + 1);\n        context.setLineDash([]);\n    }\n\n    // Selection knob\n    if (knobPosition && !hideKnob) {\n        const [knobX, knobY] = knobPosition;\n        context.fillStyle = COLORS.selectionBorder;\n        context.fillRect(knobX - SIZES.knobArea * 0.5, knobY - SIZES.knobArea * 0.5, SIZES.knobArea, SIZES.knobArea);\n    }\n\n    // Drag ghost (pixels)\n    if (dragOffset) {\n        const [shiftX, shiftY] = dragOffset;\n        const [dragColumns, dragRows] = dragIndices;\n\n        context.fillStyle = COLORS.dragGhost;\n\n        if (dragColumns) {\n            for (const column of dragColumns) {\n                const left = columnToPixel(column);\n                const right = columnToPixel(column, 1);\n                context.fillRect(left + shiftX, 0, right - left, height);\n            }\n        }\n        if (dragRows) {\n            for (const row of dragRows) {\n                const top = rowToPixel(row);\n                const bottom = rowToPixel(row, 1);\n                context.fillRect(0, top + shiftY, width, bottom - top);\n            }\n        }\n    }\n\n    // Drop target\n    if (dropTarget) {\n        let [[left, top], [right, bottom]] = resolveSelection(dropTarget, cellLayout);\n\n        context.strokeStyle = COLORS.dropTarget;\n        context.lineWidth = 4;\n\n        if (isColumnSelection(dropTarget)) {\n            right = left;\n        }\n        if (isRowSelection(dropTarget)) {\n            bottom = top;\n        }\n        context.strokeRect(left - 1, top - 1, right - left, bottom - top);\n    }\n\n    // Draw frozen row/col shadow\n    const [scrollX, scrollY] = dataOffset;\n    const hasRowShadow = freezeRows > 0 && scrollY > 0;\n    const hasColumnShadow = freezeColumns > 0 && scrollX > 0;\n    if (hasRowShadow || hasColumnShadow) {\n        if (hasRowShadow) {\n            const h = columnHeaderHeight + rowToAbsolute(freezeRows);\n            const gradient = context.createLinearGradient(0, h, 0, h + shadowBlur);\n            halfShadowGradient(gradient, shadowColor, shadowOpacity);\n            context.fillStyle = gradient;\n            context.fillRect(0, h, width, shadowBlur);\n        }\n        if (hasColumnShadow) {\n            const w = rowHeaderWidth + columnToAbsolute(freezeColumns);\n            const gradient = context.createLinearGradient(w, 0, w + shadowBlur, 0);\n            halfShadowGradient(gradient, shadowColor, shadowOpacity);\n            context.fillStyle = gradient;\n            context.fillRect(w, 0, shadowBlur, height);\n        }\n    }\n\n    // Cell contents\n    context.textBaseline = 'middle';\n\n    for (const y of rows) {\n        for (const x of columns) {\n            const left = columnToPixel(x);\n            const right = columnToPixel(x, 1);\n            const top = rowToPixel(y);\n            const bottom = rowToPixel(y, 1);\n\n            const cellContent = displayData(x, y);\n            if (cellContent !== null && cellContent !== undefined) {\n                const style = cellStyle(x, y);\n                clickables.push(\n                    ...renderCell(\n                        context,\n                        cellContent,\n                        style,\n                        DEFAULT_CELL_STYLE,\n                        left,\n                        top,\n                        right - left,\n                        bottom - top\n                    )\n                );\n            }\n        }\n    }\n\n    return clickables;\n};\n\nexport const renderCell = (\n    context: CanvasRenderingContext2D,\n    cellContent: CellContentType,\n    style: Style,\n    defaultCellStyle: Required<Style>,\n    xCoord: number,\n    yCoord: number,\n    cellWidth: number,\n    cellHeight: number\n): Clickable[] => {\n    const clickables: Clickable[] = [];\n\n    if (cellContent === null) {\n        return clickables;\n    }\n\n    const finalStyle = resolveCellStyle(style, defaultCellStyle);\n    context.fillStyle = finalStyle.color;\n    context.font = finalStyle.weight + ' ' + finalStyle.fontSize + 'px ' + finalStyle.fontFamily;\n    context.textAlign = finalStyle.textAlign;\n\n    const yy = Math.floor(yCoord + cellHeight * 0.5);\n\n    context.save();\n    context.beginPath();\n    context.rect(xCoord, yCoord, cellWidth, cellHeight);\n    context.clip();\n\n    if (finalStyle.backgroundColor !== '') {\n        context.fillStyle = finalStyle.backgroundColor;\n        context.fillRect(xCoord, yCoord, cellWidth, cellHeight);\n        context.fillStyle = finalStyle.color;\n    }\n\n    if (typeof cellContent === 'string' || typeof cellContent === 'number') {\n        const xx = applyAlignment(xCoord, cellWidth, finalStyle, 0);\n        const text = '' + cellContent;\n        context.fillText(text, xx, yy);\n    } else if (typeof cellContent === 'object') {\n        for (const obj of cellContent.items) {\n            let x = 0;\n            let y = 0;\n            let w = 0;\n            let h = 0;\n\n            if (obj.content instanceof HTMLImageElement) {\n                w = obj.width || cellWidth;\n                h = obj.height || cellHeight;\n\n                const finalX = applyAlignment(xCoord, cellWidth, finalStyle, w, obj.horizontalAlign);\n                x = finalX + obj.x;\n                y = yy + obj.y;\n\n                context.drawImage(obj.content, x, y, w, h);\n            } else if (typeof obj.content === 'string' || typeof obj.content === 'number') {\n                if (obj.horizontalAlign) {\n                    context.textAlign = obj.horizontalAlign;\n                }\n                const finalX = applyAlignment(xCoord, cellWidth, finalStyle, 0, obj.horizontalAlign);\n                const text = '' + obj.content;\n\n                const left = finalX + obj.x;\n                const top = yy + obj.y;\n                context.fillText(text, left, top);\n\n                const measure = context.measureText(text);\n                x = left - measure.actualBoundingBoxLeft;\n                y = top - measure.actualBoundingBoxAscent;\n                w = left + measure.actualBoundingBoxRight - x;\n                h = top + measure.actualBoundingBoxDescent - y;\n            }\n            if (obj.onClick) {\n                clickables.push({\n                    rect: [\n                        [x, y],\n                        [x + w, y + h],\n                    ],\n                    obj,\n                });\n            }\n        }\n    }\n    context.restore();\n\n    return clickables;\n};\n\n// Resolve selection into a consistent rectangle, without dealing with frozen rows/columns\nconst resolveSelection = (selection: Rectangle, cellLayout: CellLayout) => {\n    const { cellToPixel } = cellLayout;\n\n    const rowSelectionActive = isRowSelection(selection);\n    const columnSelectionActive = isColumnSelection(selection);\n\n    // Get selection range\n    const [min, max] = normalizeSelection(selection);\n\n    // Direct projection to visible grid\n    let [left, top] = cellToPixel(min);\n    let [right, bottom] = cellToPixel(max, ONE_ONE);\n\n    // Extend full row/column selection infinitely right/down\n    if (rowSelectionActive) {\n        right = 1e5;\n    }\n    if (columnSelectionActive) {\n        bottom = 1e5;\n    }\n\n    return [\n        [left, top],\n        [right, bottom],\n    ];\n};\n\n// Resolve selection into a consistent rectangle, handling edge cases around frozen rows/columns.\nconst resolveFrozenSelection = (\n    selection: Rectangle,\n    cellLayout: CellLayout,\n\n    freeze: XY,\n    indent: XY,\n    offset: XY\n) => {\n    const { cellToPixel, columnToAbsolute, rowToAbsolute } = cellLayout;\n\n    const rowSelectionActive = isRowSelection(selection);\n    const columnSelectionActive = isColumnSelection(selection);\n\n    const [freezeX, freezeY] = freeze;\n    const [indentX, indentY] = indent;\n    const [offsetX, offsetY] = offset;\n\n    // Get selection range\n    const [min, max] = normalizeSelection(selection);\n    const [minX, minY] = min;\n    const [maxX, maxY] = max;\n\n    // Direct projection to visible grid\n    let [left, top] = cellToPixel(min);\n    let [right, bottom] = cellToPixel(max, ONE_ONE);\n\n    // Get frozen edge\n    const frozenX = columnToAbsolute(freezeX);\n    const frozenY = rowToAbsolute(freezeY);\n\n    let hideKnob = false;\n\n    // If the selection crosses the frozen edge, it needs to always cover the entire frozen area.\n    if (isInRangeCenter(freezeX, minX, maxX + 1)) {\n        const edge = indentX + frozenX;\n        if (right <= edge) {\n            right = edge;\n            hideKnob = true;\n        }\n    }\n    if (isInRangeCenter(freezeY, minY, maxY + 1)) {\n        const edge = indentY + frozenY;\n        if (bottom <= edge) {\n            bottom = edge;\n            hideKnob = true;\n        }\n    }\n\n    // If the selection starts/ends under the frozen area, treat as off-screen\n    if (isInRangeLeft(minX, freezeX, offsetX + freezeX)) {\n        left = -1e5;\n\n        const lastInvisibleX = offsetX + freezeX - 1;\n        if (maxX <= lastInvisibleX) {\n            if (maxX === lastInvisibleX) right = indentX;\n            else right = -1e5;\n            hideKnob = true;\n        }\n    }\n    if (isInRangeLeft(minY, freezeY, offsetY + freezeY)) {\n        top = -1e5;\n\n        const lastInvisibleY = offsetY + freezeY - 1;\n        if (maxY <= lastInvisibleY) {\n            if (maxY === lastInvisibleY) bottom = indentY;\n            else bottom = -1e5;\n            hideKnob = true;\n        }\n    }\n\n    if (rowSelectionActive && offsetX > 0) {\n        hideKnob = true;\n    }\n    if (columnSelectionActive && offsetY > 0) {\n        hideKnob = true;\n    }\n\n    // Extend full row/column selection infinitely right/down\n    if (rowSelectionActive) {\n        right = 1e5;\n    }\n    if (columnSelectionActive) {\n        bottom = 1e5;\n    }\n\n    return [\n        [\n            [left, top],\n            [right, bottom],\n        ],\n        hideKnob,\n    ] as [Rectangle, boolean];\n};\n\nconst resizeCanvas = (canvas: HTMLCanvasElement) => {\n    const { width, height } = canvas.getBoundingClientRect();\n    let { devicePixelRatio: ratio = 1 } = window;\n    if (ratio < 1) {\n        ratio = 1;\n    }\n    const newCanvasWidth = Math.round(width * ratio);\n    const newCanvasHeight = Math.round(height * ratio);\n\n    if (canvas.width !== newCanvasWidth || canvas.height !== newCanvasHeight) {\n        const context = canvas.getContext('2d');\n        if (context) {\n            canvas.width = newCanvasWidth;\n            canvas.height = newCanvasHeight;\n            context.scale(ratio, ratio);\n        }\n        return true;\n    }\n\n    return false;\n};\n\nconst excelHeaderString = (num: number) => {\n    let s = '';\n    let t = 0;\n    while (num > 0) {\n        t = (num - 1) % 26;\n        s = String.fromCharCode(65 + t) + s;\n        num = ((num - t) / 26) | 0;\n    }\n    return s || '';\n};\n\nconst halfShadowGradient = (gradient: CanvasGradient, rgb: string, opacity: number) => {\n    const hex = (x: number) => ('0' + Math.round(x).toString(16)).slice(-2);\n    // Half-sine ease\n    const ease = (x: number) => 1.0 - Math.sin((x * Math.PI) / 2);\n    // Gamma adjustment assuming blend on white\n    const adjust = (x: number) => 1.0 - Math.pow(1.0 - x, 2.2);\n    for (let i = 0; i <= 16; ++i) {\n        const f = i / 16;\n        gradient.addColorStop(f, rgb + hex(adjust(opacity * ease(f) * 0.5) * 255));\n    }\n};\n","import styles from './styles.module.css';\nimport React, {\n    forwardRef,\n    useRef,\n    useImperativeHandle,\n    useLayoutEffect,\n    useState,\n    useMemo,\n    KeyboardEvent,\n    KeyboardEventHandler,\n    ReactElement,\n} from 'react';\nimport useResizeObserver from 'use-resize-observer';\n\nimport {\n    XY,\n    Rectangle,\n    CellLayout,\n    CellProperty,\n    CellContentType,\n    RowOrColumnProperty,\n    Selection,\n    Clickable,\n    Change,\n    SheetPointerEvent,\n    InternalSheetStyle,\n    InputStyle,\n    SheetStyle,\n    Style,\n    VisibleLayout,\n} from './types';\n\nimport {\n    ARROW_KEYS,\n    MAX_SEARCHABLE_INDEX,\n    DEFAULT_CELL_STYLE,\n    INITIAL_MAX_SCROLL,\n    NO_CELL,\n    NO_CLICKABLES,\n    NO_SELECTION,\n    NO_SELECTIONS,\n    ORIGIN,\n    ONE_ONE,\n} from './constants';\nimport {\n    normalizeSelection,\n    validateSelection,\n    isSameSelection,\n    isRowSelection,\n    isColumnSelection,\n    isEmptySelection,\n    getDirectionStep,\n    mapSelectionColumns,\n    mapSelectionRows,\n    maxXY,\n    addXY,\n} from './coordinate';\nimport { useMouse } from './mouse';\nimport { useScroll, scrollToCell, clipDataOffset } from './scroll';\nimport { useAutoSizeColumn } from './autosize';\nimport { useClipboardCopy, useClipboardPaste } from './clipboard';\nimport { makeLayoutCache, makeCellLayout } from './layout';\nimport { createCellProp, createRowOrColumnProp, findInDisplayData } from './props';\nimport { renderSheet } from './render';\nimport { resolveSheetStyle } from './style';\n\nexport type SheetInputProps = {\n    value: string;\n    autoFocus: boolean;\n    onKeyDown: KeyboardEventHandler<HTMLElement>;\n    onChange: (value: string) => void;\n    style: InputStyle;\n};\n\nexport type SheetRenderProps = {\n    visibleCells: VisibleLayout;\n    cellLayout: CellLayout;\n    selection: Rectangle;\n    editMode: boolean;\n};\n\nexport type SheetProps = {\n    cellWidth?: RowOrColumnProperty<number>;\n    cellHeight?: RowOrColumnProperty<number>;\n    columnHeaders?: RowOrColumnProperty<CellContentType>;\n    columnHeaderStyle?: RowOrColumnProperty<Style>;\n    cellStyle?: CellProperty<Style>;\n    readOnly?: CellProperty<boolean>;\n    canSizeColumn?: RowOrColumnProperty<boolean>;\n    canSizeRow?: RowOrColumnProperty<boolean>;\n    canOrderColumn?: RowOrColumnProperty<boolean>;\n    canOrderRow?: RowOrColumnProperty<boolean>;\n    columnGroupKeys?: RowOrColumnProperty<string | number | null>;\n    rowGroupKeys?: RowOrColumnProperty<string | number | null>;\n    sourceData?: CellProperty<string | number | null>;\n    displayData?: CellProperty<CellContentType>;\n    editData?: CellProperty<string>;\n    editKeys?: CellProperty<string>;\n    sheetStyle?: SheetStyle;\n    selection?: Rectangle;\n    secondarySelections?: Selection[];\n\n    maxRows?: number;\n    maxColumns?: number;\n    cacheLayout?: boolean | number;\n    dontCommitEditOnSelectionChange?: boolean;\n    dontChangeSelectionOnOrderChange?: boolean;\n\n    inputComponent?: (\n        x: number,\n        y: number,\n        props: SheetInputProps,\n        commitEditingCell?: (value?: string | number | null) => void\n    ) => ReactElement | undefined;\n\n    renderInside?: (props: SheetRenderProps) => React.ReactNode;\n    renderOutside?: (props: SheetRenderProps) => React.ReactNode;\n\n    onSelectionChanged?: (minX: number, minY: number, maxX: number, maxY: number) => void;\n    onRightClick?: (e: SheetPointerEvent) => void;\n    onChange?: (changes: Array<Change>) => void;\n    onColumnOrderChange?: (indices: number[], order: number) => void;\n    onRowOrderChange?: (indices: number[], order: number) => void;\n    onCellWidthChange?: (indices: number[], value: number) => void;\n    onCellHeightChange?: (indices: number[], value: number) => void;\n    onScrollChange?: (visibleRows: number[], visibleColumns: number[]) => void;\n};\n\nexport type SheetRef = CellLayout & {\n    startEditingCell: (editCell: XY, arrowKeyCommitMode?: boolean) => void;\n};\n\nconst Sheet = forwardRef<SheetRef, SheetProps>((props, ref) => {\n    const canvasRef = useRef<HTMLCanvasElement>(null);\n    const overlayRef = useRef<HTMLDivElement>(null);\n\n    const [maxScroll, setMaxScroll] = useState<XY>(INITIAL_MAX_SCROLL);\n    const [dataOffset, setDataOffset] = useState<XY>(ORIGIN);\n\n    const selectionProp = props.selection ?? NO_SELECTION;\n\n    const [selection, setSelection] = useState<Rectangle>(selectionProp);\n    const [knobArea, setKnobArea] = useState<Rectangle | null>(null);\n    const [dragOffset, setDragOffset] = useState<XY | null>(null);\n    const [dragIndices, setDragIndices] = useState<[number[] | null, number[] | null]>([null, null]);\n    const [dropTarget, setDropTarget] = useState<Rectangle | null>(null);\n    const [editCell, setEditCell] = useState<XY>(NO_CELL);\n\n    const [lastSelectionProp, setLastSelectionProp] = useState<Rectangle>(selectionProp);\n    if (lastSelectionProp !== selectionProp) {\n        setLastSelectionProp(selectionProp);\n        setSelection(selectionProp);\n    }\n\n    const [editValue, setEditValue] = useState<string | number>('');\n    const [arrowKeyCommitMode, setArrowKeyCommitMode] = useState(false);\n\n    const { width: canvasWidth = 3000, height: canvasHeight = 3000 } = useResizeObserver({ ref: overlayRef });\n\n    const cellWidth = useMemo(() => createRowOrColumnProp(props.cellWidth, 100), [props.cellWidth]);\n    const cellHeight = useMemo(() => createRowOrColumnProp(props.cellHeight, 22), [props.cellHeight]);\n    const columnHeaders = useMemo(() => createRowOrColumnProp(props.columnHeaders, null), [props.columnHeaders]);\n    const columnHeaderStyle = useMemo(() => createRowOrColumnProp(props.columnHeaderStyle, {}), [\n        props.columnHeaderStyle,\n    ]);\n\n    const canSizeColumn = useMemo(() => createRowOrColumnProp(props.canSizeColumn, true), [props.canSizeColumn]);\n    const canSizeRow = useMemo(() => createRowOrColumnProp(props.canSizeRow, true), [props.canSizeRow]);\n    const canOrderColumn = useMemo(() => createRowOrColumnProp(props.canOrderColumn, true), [props.canOrderColumn]);\n    const canOrderRow = useMemo(() => createRowOrColumnProp(props.canOrderRow, true), [props.canOrderRow]);\n\n    const rowGroupKeys = useMemo(() => createRowOrColumnProp(props.rowGroupKeys, null), [props.rowGroupKeys]);\n    const columnGroupKeys = useMemo(() => createRowOrColumnProp(props.columnGroupKeys, null), [props.columnGroupKeys]);\n\n    const cellReadOnly = useMemo(() => createCellProp(props.readOnly, false), [props.readOnly]);\n\n    const sourceData = useMemo(() => createCellProp(props.sourceData, null), [props.sourceData]);\n    const displayData = useMemo(() => createCellProp(props.displayData, ''), [props.displayData]);\n    const editData = useMemo(() => createCellProp(props.editData, ''), [props.editData]);\n    const editKeys = useMemo(() => createCellProp(props.editKeys, ''), [props.editKeys]);\n    const cellStyle = useMemo(() => createCellProp(props.cellStyle, DEFAULT_CELL_STYLE), [props.cellStyle]);\n\n    const sheetStyle: InternalSheetStyle = useMemo(() => resolveSheetStyle(props.sheetStyle), [props.sheetStyle]);\n    const secondarySelections = props.secondarySelections ?? NO_SELECTIONS;\n\n    const selectedColumnGroups = useMemo(\n        () =>\n            props.columnGroupKeys\n                ? new Set(mapSelectionColumns(selection)((x: number) => columnGroupKeys(x)).filter((x) => x != null))\n                : null,\n        [props.columnGroupKeys, columnGroupKeys, selection]\n    );\n    const selectedRowGroups = useMemo(\n        () =>\n            props.rowGroupKeys\n                ? new Set(mapSelectionRows(selection)((y: number) => rowGroupKeys(y)).filter((x) => x != null))\n                : null,\n        [props.rowGroupKeys, rowGroupKeys, selection]\n    );\n\n    const [maxScrollX, maxScrollY] = maxScroll;\n\n    const [editCellX, editCellY] = editCell;\n    const editMode = editCellX !== -1 && editCellY !== -1;\n\n    // Global layout for unscrolled/unfrozen grid\n    // Cached either per width/height pair, or permanently with invalidation on resize/reorder.\n    const shouldCacheLayout = (props.cacheLayout ?? false) !== false;\n    const layoutVersion = typeof props.cacheLayout === 'number' ? props.cacheLayout : 0;\n    const columnLayout = useMemo(() => makeLayoutCache(cellWidth), [shouldCacheLayout ? layoutVersion : cellWidth]);\n    const rowLayout = useMemo(() => makeLayoutCache(cellHeight), [shouldCacheLayout ? layoutVersion : cellHeight]);\n    useMemo(() => {\n        if (!shouldCacheLayout) return;\n\n        columnLayout.setSizer(cellWidth);\n        rowLayout.setSizer(cellHeight);\n\n        // Depend on layoutVersion to allow for controlled external invalidation\n        // eslint-disable-next-line\n    }, [shouldCacheLayout, layoutVersion, cellWidth, cellHeight]);\n\n    // Virtual layout for indented/scrolled/frozen grid\n    const { freezeColumns, freezeRows, rowHeaderWidth, columnHeaderHeight } = sheetStyle;\n    const cellLayout = useMemo(\n        () =>\n            makeCellLayout(\n                [freezeColumns, freezeRows],\n                [rowHeaderWidth, columnHeaderHeight],\n                dataOffset,\n                columnLayout,\n                rowLayout\n            ),\n        [freezeColumns, freezeRows, rowHeaderWidth, columnHeaderHeight, dataOffset, columnLayout, rowLayout]\n    );\n\n    // Build range of visible cells\n    const { getVisibleCells, cellToPixel, getVersion } = cellLayout;\n    const visibleCells = useMemo(\n        () => getVisibleCells([canvasWidth, canvasHeight]),\n        // Need to invalidate view if cached layout version changed\n        // eslint-disable-next-line\n        [getVisibleCells, canvasWidth, canvasHeight, getVersion()]\n    );\n\n    // Notify of viewport change\n    useLayoutEffect(() => {\n        if (props.onScrollChange) {\n            props.onScrollChange([...visibleCells.rows], [...visibleCells.columns]);\n        }\n    }, [visibleCells, props.onScrollChange]);\n\n    const scrollToSelection = (selection: Rectangle, toHead = false) => {\n        const { current: overlay } = overlayRef;\n        if (!overlay) return;\n\n        const [anchor, head] = selection;\n        const view: XY = [canvasWidth, canvasHeight];\n        const freeze: XY = [freezeColumns, freezeRows];\n\n        scrollToCell(\n            overlay,\n            toHead ? head : anchor,\n            view,\n            freeze,\n            dataOffset,\n            maxScroll,\n            cellLayout,\n            (dataOffset: XY, maxScroll: XY) => {\n                setDataOffset(dataOffset);\n                setMaxScroll(maxScroll);\n            }\n        );\n    };\n\n    // Set selection with scrolling\n    const changeSelection = (newSelection: Rectangle, scrollTo = true, toHead = false) => {\n        if (!isSameSelection(selection, newSelection)) {\n            setSelection(validateSelection(newSelection));\n        }\n\n        const { current: overlay } = overlayRef;\n        if (!overlay) return;\n\n        if (scrollTo) {\n            scrollToSelection(newSelection, toHead);\n        }\n\n        if (props.onSelectionChanged) {\n            const [[minX, minY], [maxX, maxY]] = normalizeSelection(newSelection);\n            props.onSelectionChanged(minX, minY, maxX, maxY);\n        }\n    };\n\n    const commitEditingCell = (value?: string) => {\n        if (props.onChange) {\n            const [cellX, cellY] = editCell;\n            props.onChange([{ x: cellX, y: cellY, value: value !== undefined ? value : editValue }]);\n        }\n        setEditCell(NO_CELL);\n    };\n\n    const startEditingCell = (editCell: XY, arrowKeyCommitMode = false) => {\n        const [cellX, cellY] = editCell;\n        if (cellReadOnly(cellX, cellY)) {\n            return;\n        }\n\n        const editDataValue = editData(cellX, cellY);\n        let val = '';\n        if (editDataValue !== null && editDataValue !== undefined) {\n            val = editDataValue;\n        }\n        setEditCell(editCell);\n        setEditValue(val);\n        setArrowKeyCommitMode(arrowKeyCommitMode);\n        setLastEditKey(editKeys(...editCell));\n    };\n\n    // If max row or column count changes, keep sheet in view\n    const { maxColumns = Infinity, maxRows = Infinity } = props;\n    useLayoutEffect(() => {\n        const view: XY = [canvasWidth, canvasHeight];\n        const freeze: XY = [freezeColumns, freezeRows];\n\n        setDataOffset(clipDataOffset(view, dataOffset, freeze, [maxColumns, maxRows], cellLayout));\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [maxRows, maxColumns]);\n\n    // Output from rendered layout is used to drive events on user content\n    const hitmapRef = useRef<Clickable[]>(NO_CLICKABLES);\n\n    // Textarea is used to hold text to copy, and receives pastes\n    const textAreaRef = useRef<HTMLTextAreaElement>(null);\n    useClipboardCopy(textAreaRef, selection, editMode, editData);\n    useClipboardPaste(textAreaRef, selection, changeSelection, props.onChange, cellReadOnly);\n\n    const onScroll = useScroll(dataOffset, maxScroll, cellLayout, setDataOffset, setMaxScroll);\n\n    const getAutoSizeWidth = useAutoSizeColumn(\n        visibleCells.rows,\n        displayData,\n        cellStyle,\n        columnHeaders,\n        columnHeaderStyle,\n        canvasWidth\n    );\n\n    const { mouseHandlers, knobPosition } = useMouse(\n        hitmapRef,\n        selection,\n        knobArea,\n        editMode,\n        editData,\n        sourceData,\n        cellReadOnly,\n\n        canSizeColumn,\n        canSizeRow,\n        canOrderColumn,\n        canOrderRow,\n\n        cellLayout,\n        visibleCells,\n        sheetStyle,\n\n        columnGroupKeys,\n        rowGroupKeys,\n        selectedColumnGroups,\n        selectedRowGroups,\n\n        getAutoSizeWidth,\n\n        startEditingCell,\n        commitEditingCell,\n        setKnobArea,\n        setDragIndices,\n        setDragOffset,\n        setDropTarget,\n        changeSelection,\n\n        props.cacheLayout ? columnLayout.clearAfter : undefined,\n        props.cacheLayout ? rowLayout.clearAfter : undefined,\n\n        props.onChange,\n        props.onColumnOrderChange,\n        props.onRowOrderChange,\n        props.onCellWidthChange,\n        props.onCellHeightChange,\n        props.onRightClick,\n        props.dontCommitEditOnSelectionChange,\n        props.dontChangeSelectionOnOrderChange\n    );\n\n    useLayoutEffect(() => {\n        const { current: canvas } = canvasRef;\n        if (!canvas) {\n            return;\n        }\n\n        const context = canvas.getContext('2d');\n        if (!context) {\n            return;\n        }\n\n        const animationFrameId = window.requestAnimationFrame(() => {\n            hitmapRef.current = renderSheet(\n                context,\n\n                cellLayout,\n                visibleCells,\n                sheetStyle,\n                cellStyle,\n                selection,\n                secondarySelections,\n\n                knobPosition,\n                knobArea,\n                dragIndices,\n                dragOffset,\n                dropTarget,\n\n                columnHeaders,\n                columnHeaderStyle,\n                displayData,\n\n                columnGroupKeys,\n                rowGroupKeys,\n                selectedColumnGroups,\n                selectedRowGroups,\n\n                dataOffset\n            );\n        });\n\n        return () => {\n            window.cancelAnimationFrame(animationFrameId);\n        };\n    }, [\n        cellLayout,\n        visibleCells,\n        sheetStyle,\n        cellStyle,\n        selection,\n        secondarySelections,\n\n        knobPosition,\n        knobArea,\n        dragOffset,\n        dropTarget,\n\n        columnHeaders,\n        columnHeaderStyle,\n        displayData,\n\n        columnGroupKeys,\n        rowGroupKeys,\n        selectedColumnGroups,\n        selectedRowGroups,\n\n        dataOffset,\n    ]);\n\n    const onKeyDown = (e: KeyboardEvent) => {\n        if (e.key === 'Escape') {\n            setEditCell(NO_CELL);\n            return;\n        }\n\n        const direction =\n            e.key === 'Enter' ? 'down' : e.key === 'Tab' ? 'right' : arrowKeyCommitMode ? ARROW_KEYS[e.key] : null;\n\n        if (direction) {\n            e.preventDefault();\n            const step = getDirectionStep(direction);\n            const head = maxXY(addXY(editCell, step), ORIGIN);\n            commitEditingCell();\n            changeSelection([head, head]);\n        }\n    };\n\n    const onGridKeyDown = (e: KeyboardEvent) => {\n        if (editMode && arrowKeyCommitMode && e.key in ARROW_KEYS) {\n            commitEditingCell();\n            return;\n        }\n\n        if ((e.metaKey || e.ctrlKey) && String.fromCharCode(e.which).toLowerCase() === 'v') {\n            return;\n        }\n\n        // copy\n        if ((e.metaKey || e.ctrlKey) && String.fromCharCode(e.which).toLowerCase() === 'c') {\n            const { current: textArea } = textAreaRef;\n            textArea?.select();\n            return;\n        }\n\n        if (e.key === 'Backspace' || e.key === 'Delete') {\n            let [[x1, y1], [x2, y2]] = normalizeSelection(selection);\n            if (isRowSelection(selection)) {\n                x1 = 0;\n                x2 = MAX_SEARCHABLE_INDEX;\n            }\n            if (isColumnSelection(selection)) {\n                y1 = 0;\n                y2 = MAX_SEARCHABLE_INDEX;\n            }\n\n            const changes: Change[] = [];\n            for (let y = y1; y <= y2; y++) {\n                for (let x = x1; x <= x2; x++) {\n                    if (!cellReadOnly(x, y)) {\n                        changes.push({ x: x, y: y, value: null });\n                    }\n                }\n            }\n            if (props.onChange) {\n                props.onChange(changes);\n            }\n            return;\n        }\n\n        // nothing selected\n        if (isEmptySelection(selection)) {\n            return;\n        }\n\n        if (\n            (e.keyCode >= 48 && e.keyCode <= 57) ||\n            (e.keyCode >= 96 && e.keyCode <= 105) ||\n            (e.keyCode >= 65 && e.keyCode <= 90) ||\n            e.key === 'Enter' ||\n            e.key === '-' ||\n            e.key === '.' ||\n            e.key === ','\n        ) {\n            const [cell] = selection;\n            const [cellX, cellY] = cell;\n            if (cellReadOnly(cellX, cellY)) {\n                e.preventDefault(); // so we dont get keystrokes inside the text area\n                return;\n            }\n\n            startEditingCell(cell, e.key !== 'Enter');\n            return;\n        }\n\n        if (e.key in ARROW_KEYS) {\n            let [anchor, head] = selection;\n\n            const direction = ARROW_KEYS[e.key];\n            const step = getDirectionStep(direction);\n\n            if (e.metaKey || e.ctrlKey) {\n                head = findInDisplayData(displayData, head, direction);\n            } else {\n                head = maxXY(addXY(head, step), ORIGIN);\n            }\n            if (!e.shiftKey) {\n                anchor = head;\n            }\n            changeSelection([anchor, head], true, true);\n            return;\n        }\n\n        e.preventDefault();\n    };\n\n    const [lastEditKey, setLastEditKey] = useState('');\n\n    let editTextPosition = ORIGIN;\n    let editTextWidth = 0;\n    let editTextHeight = 0;\n    let editTextTextAlign: 'right' | 'left' | 'center' = 'right';\n    if (editMode) {\n        const style = cellStyle(...editCell);\n        editTextPosition = cellToPixel(editCell);\n        editTextPosition = addXY(editTextPosition, ONE_ONE);\n        editTextWidth = cellWidth(editCellX) - 3;\n        editTextHeight = cellHeight(editCellY) - 3;\n        editTextTextAlign = style.textAlign || DEFAULT_CELL_STYLE.textAlign || 'left';\n        const editKey = editKeys(...editCell);\n        if (editKey !== lastEditKey) {\n            setLastEditKey('');\n            setEditCell(NO_CELL);\n        }\n    }\n\n    const [textX, textY] = editTextPosition;\n    const inputProps = {\n        value: editValue,\n        autoFocus: true,\n        onKeyDown: onKeyDown,\n        style: {\n            position: 'absolute',\n            left: textX,\n            top: textY,\n            padding: '0px 4px',\n            width: editTextWidth,\n            height: editTextHeight,\n            outline: 'none',\n            border: 'none',\n            textAlign: editTextTextAlign,\n            color: 'black',\n            fontSize: DEFAULT_CELL_STYLE.fontSize,\n            fontFamily: 'sans-serif',\n        } as InputStyle,\n    };\n\n    const input = props.inputComponent?.(\n        editCellX,\n        editCellY,\n        { ...inputProps, onChange: setEditValue } as SheetInputProps,\n        commitEditingCell\n    );\n\n    let overlayDivClassName = styles.sheetscroll;\n    const overlayDivStyles: React.CSSProperties = {\n        position: 'absolute',\n        width: '100%',\n        height: '100%',\n        top: 0,\n        left: 0,\n        overflow: 'scroll',\n        borderBottom: '1px solid #ddd',\n    };\n    const canvasStyles: React.CSSProperties = {\n        width: canvasWidth,\n        height: canvasHeight,\n        outline: '1px solid #ddd', // find another better solution ?\n    };\n\n    if (sheetStyle.hideScrollBars) {\n        delete canvasStyles['outline'];\n        delete overlayDivStyles['borderBottom'];\n        overlayDivClassName = '';\n    }\n\n    const renderedInside = useMemo(() => props.renderInside?.({ visibleCells, cellLayout, selection, editMode }), [\n        props.renderInside,\n        visibleCells,\n        cellLayout,\n        selection,\n        editMode,\n    ]);\n\n    const renderedOutside = useMemo(() => props.renderOutside?.({ visibleCells, cellLayout, selection, editMode }), [\n        props.renderOutside,\n        visibleCells,\n        cellLayout,\n        selection,\n        editMode,\n    ]);\n\n    // External component API\n    useImperativeHandle(\n        ref,\n        () => ({\n            ...cellLayout,\n            startEditingCell,\n        }),\n        [cellLayout, startEditingCell]\n    );\n\n    return (\n        <div style={{ position: 'relative', height: '100%', overflow: 'hidden' }}>\n            <canvas style={canvasStyles} ref={canvasRef} />\n            <div\n                ref={overlayRef}\n                {...mouseHandlers}\n                onScroll={onScroll}\n                className={overlayDivClassName}\n                style={overlayDivStyles}\n            >\n                <div\n                    style={{\n                        position: 'absolute',\n                        left: 0,\n                        top: 0,\n                        width: 1,\n                        height: maxScrollY + 2000,\n                        backgroundColor: 'rgba(0,0,0,0.0)',\n                    }}\n                ></div>\n                <div\n                    style={{\n                        position: 'absolute',\n                        left: 0,\n                        top: 0,\n                        width: maxScrollX + 5000,\n                        height: 1,\n                        backgroundColor: 'rgba(0,0,0,0.0)',\n                    }}\n                ></div>\n                {renderedInside ? (\n                    <div\n                        style={{\n                            position: 'sticky',\n                            left: 0,\n                            top: 0,\n                        }}\n                    >\n                        {renderedInside}\n                    </div>\n                ) : null}\n            </div>\n            {renderedOutside ? (\n                <div\n                    style={{\n                        position: 'absolute',\n                        left: 0,\n                        top: 0,\n                        width: '100%',\n                        height: '100%',\n                        pointerEvents: 'none',\n                    }}\n                >\n                    {renderedOutside}\n                </div>\n            ) : null}\n            <textarea\n                style={{ position: 'absolute', top: 0, left: 0, width: 1, height: 1, opacity: 0.01 }}\n                ref={textAreaRef}\n                autoComplete=\"off\"\n                autoCorrect=\"off\"\n                autoCapitalize=\"off\"\n                spellCheck=\"false\"\n                onFocus={(e) => e.target.select()}\n                tabIndex={0}\n                onKeyDown={onGridKeyDown}\n            ></textarea>\n            {editMode &&\n                (input !== undefined ? (\n                    input\n                ) : (\n                    <input\n                        {...inputProps}\n                        type=\"text\"\n                        onFocus={(e) => e.target.select()}\n                        onChange={(e) => setEditValue(e.target.value)}\n                    />\n                ))}\n        </div>\n    );\n});\n\nexport default Sheet;\n","import { useCallback, useMemo } from 'react';\nimport { DEFAULT_CELL_STYLE, SIZES } from './constants';\nimport { resolveCellStyle } from './style';\nimport { RowOrColumnPropertyFunction, CellPropertyFunction, CellContentType, Style } from './types';\n\nexport const useAutoSizeColumn = (\n    rows: number[],\n    displayData: CellPropertyFunction<CellContentType>,\n    cellStyle: CellPropertyFunction<Style>,\n    columnHeaders: RowOrColumnPropertyFunction<CellContentType>,\n    columnHeaderStyle: RowOrColumnPropertyFunction<Style>,\n    canvasWidth: number\n) => {\n    const context = useMemo(() => document.createElement('canvas').getContext('2d'), []);\n\n    const getAutoSizeWidth = useCallback(\n        (x: number) => {\n            if (!context) return 0;\n\n            const getWidth = (cellContent: Exclude<CellContentType, null>, style: Style) => {\n                const finalStyle = resolveCellStyle(style, DEFAULT_CELL_STYLE);\n                context.font = finalStyle.weight + ' ' + finalStyle.fontSize + 'px ' + finalStyle.fontFamily;\n\n                const inlineMargin = finalStyle.marginLeft + finalStyle.marginRight;\n                if (typeof cellContent === 'string' || typeof cellContent === 'number') {\n                    const { width } = context.measureText(cellContent.toString());\n                    return width + inlineMargin;\n                } else if (typeof cellContent === 'object') {\n                    let maxWidth = 0;\n                    let extraWidth = 0;\n\n                    for (const obj of cellContent.items) {\n                        let width = 0;\n                        if (typeof obj.content === 'string' || typeof obj.content === 'number') {\n                            const { width: w } = context.measureText(obj.content.toString());\n                            width = obj.x + w + inlineMargin;\n                        } else if (obj.width) {\n                            width = obj.width;\n                        }\n\n                        if (obj.horizontalAlign === 'right') {\n                            extraWidth += width;\n                        } else {\n                            maxWidth = Math.max(maxWidth, width);\n                        }\n                    }\n\n                    return maxWidth + extraWidth;\n                }\n                return 0;\n            };\n\n            let maxWidth = SIZES.minimumWidth;\n\n            const headerContent = columnHeaders(x);\n            if (headerContent) {\n                const headerStyle = columnHeaderStyle(x);\n                maxWidth = Math.max(maxWidth, getWidth(headerContent, headerStyle));\n            }\n\n            for (const y of rows) {\n                const cellContent = displayData(x, y);\n                if (cellContent != null) {\n                    const style = cellStyle(x, y);\n                    maxWidth = Math.max(maxWidth, getWidth(cellContent, style));\n                }\n            }\n\n            return Math.ceil(Math.min(canvasWidth, maxWidth));\n        },\n        [context, displayData, cellStyle, columnHeaders, columnHeaderStyle]\n    );\n\n    return getAutoSizeWidth;\n};\n","import React from 'react';\nimport { useRef, useState } from 'react';\nimport { SheetBoxHeader } from './SheetBox';\nimport GitIcon from '../assets/git.svg';\n\nfunction Header() {\n    const textAreaRef = useRef(null);\n    const [copySuccess, setCopySuccess] = useState('');\n\n    const copyToClipboard = (e) => {\n        textAreaRef.current.select();\n        document.execCommand('copy');\n        e.target.focus();\n        setCopySuccess('Copied!');\n        setTimeout(() => {\n            setCopySuccess('');\n        }, 1000);\n    };\n\n    return (\n        <div className=\"container blue-bg\" id=\"home\">\n            <div className=\"content flex-row header\">\n                <div className=\"box text-box\">\n                    <div>\n                        <h1>Beautiful and fast spreadsheet component for React</h1>\n                        <p className=\"lightblue-p\">\n                            Sheet Happens is easy to implement and extend.\n                            <br></br>\n                            And it's super fast.\n                        </p>\n                    </div>\n                    <div className=\"lib-box\">\n                        <div className=\"install-box\" onClick={copyToClipboard}>\n                            <input readOnly ref={textAreaRef} value=\"npm install --save sheet-happens\" />\n                            {copySuccess !== '' && <div className=\"copy-success\">{copySuccess}</div>}\n                        </div>\n                        <a\n                            href=\"https://github.com/farseerdev/sheet-happens\"\n                            rel=\"noopener noreferrer\"\n                            className=\"git-box\"\n                            target=\"_blank\"\n                        >\n                            <img src={GitIcon} alt=\"Git\" />\n                            view on github\n                        </a>\n                    </div>\n                </div>\n                <div className=\"box\">\n                    <SheetBoxHeader />\n                </div>\n            </div>\n        </div>\n    );\n}\n\nexport default Header;\n","import React from 'react';\n\nfunction TitleSeparator({ title, id }) {\n    return (\n        <div className=\"title-separator\" id={id ? id : ''}>\n            <p>{title ? title : 'No title'}</p>\n            <div className=\"separator\"></div>\n        </div>\n    );\n}\n\nexport default TitleSeparator;\n","import React from 'react';\n\nfunction Wrap({ children }) {\n    return (\n        <div className=\"container\">\n            <div className=\"content flex-row\">{children}</div>\n        </div>\n    );\n}\n\nexport default Wrap;\n","import React from 'react';\nimport SyntaxHighlighter from 'react-syntax-highlighter';\nimport { xcode } from 'react-syntax-highlighter/dist/esm/styles/hljs';\nxcode.hljs.padding = '10px 20px';\nxcode.hljs.background = '#f8f9fa';\nxcode.hljs.width = '100%';\nxcode.hljs.maxWidth = '100%';\nxcode.hljs.overflow = 'auto';\nxcode.hljs.borderRadius = '3px';\nxcode.hljs.fontSize = '14px';\n\nfunction Code() {\n    return (\n        <SyntaxHighlighter language=\"javascript\" style={xcode}>\n            {`function SheetBox() {\n    const [data, setData] = useState(initialData);\n    const [cellWidth, setCellWidth] = useState([]);\n    const [cellHeight, setCellHeight] = useState([]);\n\n    const onSelectionChanged = (x1, y1, x2, y2) => {};\n    const onRightClick = () => {};\n    const columnHeaders = ['A', 'B', 'C'];\n    const cellStyle = (x, y) => {\n        return {};\n    };\n    const editData = (x, y) => {\n        return data?.[y]?.[x];\n    };\n    const displayData = (x, y) => {\n        return data?.[y]?.[x];\n    };\n    const sourceData = (x, y) => {\n        return data?.[y]?.[x];\n    };\n\n    const onChange = (changes) => {\n        const newData = [...data];\n        for (const change of changes) {\n            if (!newData[change.y]) {\n                newData[change.y] = [];\n            }\n            newData[change.y][change.x] = change.value;\n        }\n        setData(newData);\n    };\n\n    const isReadOnly = (x, y) => {\n        return false;\n    };\n\n    const onCellWidthChange = (columnIdx, newWidth) => {\n        const cw = [...cellWidth];\n        if (columnIdx > cw.length) {\n            for (let i = cw.length; i <= columnIdx; i++) {\n                cw.push(100);\n            }\n        }\n        cw[columnIdx] = newWidth;\n        setCellWidth(cw);\n    };\n    const onCellHeightChange = (rowIdx, newHeight) => {\n        const ch = [...cellHeight];\n        if (rowIdx > ch.length) {\n            for (let i = ch.length; i <= rowIdx; i++) {\n                ch.push(22);\n            }\n        }\n        ch[rowIdx] = newHeight;\n        setCellHeight(ch);\n    };\n\n    return (\n        <div className=\"sheet-box\">\n            <Sheet\n                onSelectionChanged={onSelectionChanged}\n                onRightClick={onRightClick}\n                columnHeaders={columnHeaders}\n                cellStyle={cellStyle}\n                editData={editData}\n                displayData={displayData}\n                sourceData={sourceData}\n                cellWidth={cellWidth}\n                cellHeight={cellHeight}\n                onChange={onChange}\n                readOnly={isReadOnly}\n                onCellWidthChange={onCellWidthChange}\n                onCellHeightChange={onCellHeightChange}\n                freezeColumns={0}\n                freezeRows={0}\n            />\n        </div>\n    );\n}`}\n        </SyntaxHighlighter>\n    );\n}\n\nexport default Code;\n\nexport function SourceDisplayDataCode() {\n    let xcode2 = { ...xcode };\n    xcode2.hljs.height = '100%';\n    return (\n        <SyntaxHighlighter language=\"javascript\" style={xcode2}>\n            {`const [data, setData] = useState([[1,2,3], [10,20,30]]);\n    \nconst displayData = (x, y) => {\n    return data?.[y]?.[x]?.toFixed?.(2);\n};\n\nreturn (\n    <div className=\"sheet-box\">\n        <Sheet\n            sourceData={data} // array of arrays of data \n            displayData={displayData} // function example\n        />\n    </div>\n);`}\n        </SyntaxHighlighter>\n    );\n}\n\nexport function InitSheetCode() {\n    return (\n        <SyntaxHighlighter language=\"javascript\" style={xcode}>\n            {`import React, { Component } from 'react'\nimport Sheet from 'sheet-happens'\nimport 'sheet-happens/dist/index.css'\n\nclass Example extends Component {\n  render() {\n    return <Sheet />\n  }\n}`}\n        </SyntaxHighlighter>\n    );\n}\n\nexport function InitSheetWithDataCode() {\n    return (\n        <SyntaxHighlighter language=\"javascript\" style={xcode}>\n            {`const [data, setData] = useState([[1,2,3], [10,20,30]]);\n    \nconst displayData = (x, y) => {\n    return data?.[y]?.[x]?.toFixed?.(2);\n};\n\nreturn (\n    <div className=\"sheet-box\">\n        <Sheet\n            sourceData={data}\n            displayData={displayData}\n        />\n    </div>\n);`}\n        </SyntaxHighlighter>\n    );\n}\n\nexport function EditDataCode() {\n    return (\n        <SyntaxHighlighter language=\"javascript\" style={xcode}>\n            {`...\n\nconst editData = (x, y) => {\n    return data?.[y]?.[x];\n};\n\nconst onChange = (changes) => {\n    const newData = [...data];\n    for (const change of changes) {\n        if (!newData[change.y]) {\n            newData[change.y] = [];\n        }\n        newData[change.y][change.x] = change.value;\n    }\n    setData(newData);\n};\n\nconst isReadOnly = (x, y) => {\n    return false;\n};\n\nreturn (\n    <div className=\"sheet-box\">\n        <Sheet\n            ...\n            sourceData={sourceData}\n            onChange={onChange}\n            readOnly={isReadOnly}\n        />\n    </div>\n);`}\n        </SyntaxHighlighter>\n    );\n}\n\nexport function CellStyleSizeCode() {\n    return (\n        <SyntaxHighlighter language=\"javascript\" style={xcode}>\n            {`...\n\nconst cellStyle = (x, y) => {\n    return { textAlign: 'right' };\n};\n\nconst [cellWidth, setCellWidth] = useState([]);\n\nconst onCellWidthChange = (columnIdx, newWidth) => {\n    const cw = [...cellWidth];\n    if (columnIdx > cw.length) {\n        for (let i = cw.length; i <= columnIdx; i++) {\n            cw.push(100);\n        }\n    }\n    cw[columnIdx] = newWidth;\n    setCellWidth(cw);\n};\n\nreturn (\n    <div className=\"sheet-box\">\n        <Sheet\n            ...\n            cellStyle={cellStyle}\n            cellWidth={cellWidth}\n            onCellWidthChange={onCellWidthChange}\n        />\n    </div>\n);`}\n        </SyntaxHighlighter>\n    );\n}\n","import React from 'react';\n\nfunction Footer() {\n    return (\n        <div className=\"footer\">\n            <p className=\"copy\">\n                made by <a href=\"https://www.farseer.io\">farseer</a>\n            </p>\n        </div>\n    );\n}\n\nexport default Footer;\n","import React from 'react';\nimport './index.css';\n\nimport Menu from './components/Menu';\nimport Header from './components/Header';\nimport TitleSeparator from './components/TitleSeparator';\nimport Wrap from './components/Wrap';\nimport {\n    InitSheetCode,\n    InitSheetWithDataCode,\n    SourceDisplayDataCode,\n    EditDataCode,\n    CellStyleSizeCode,\n} from './components/Code';\nimport {\n    SheetBoxStyle,\n    SheetBoxBasic,\n    SheetBoxRender,\n    SheetBoxGrouped,\n    SheetBoxFormatting,\n    SheetBoxVeryBigData,\n    SheetBoxCustomInput,\n    SheetBoxSourceDisplayData,\n} from './components/SheetBox';\nimport Footer from './components/Footer';\n\nconst App = () => {\n    return (\n        <>\n            <Menu />\n            <Header />\n\n            <TitleSeparator title=\"Get started\" id=\"usage\" />\n            <Wrap>\n                <div className=\"box full-width colored-pre\" style={{ overflowX: 'auto' }}>\n                    <p>Import the component and its style, and render it</p>\n                    <InitSheetCode />\n\n                    <div className=\"spacer\" />\n\n                    <p>Display some data</p>\n                    <InitSheetWithDataCode />\n                </div>\n            </Wrap>\n\n            <TitleSeparator title=\"Learn more about features\" id=\"features\" />\n            <Wrap>\n                <div className=\"box\">\n                    <SheetBoxBasic />\n                </div>\n                <div className=\"box\">\n                    <h3>Basic spreadsheet</h3>\n                    <p>\n                        It has all the features you'd expect from the spreadsheet: keyboard navigation, copy cells by\n                        dragging the small square, copy/paste from and to Excel and Google Sheets, resize and reorder\n                        columns and rows.\n                    </p>\n                </div>\n            </Wrap>\n            <Wrap>\n                <div className=\"box\">\n                    <SheetBoxStyle />\n                </div>\n                <div className=\"box\">\n                    <h3>Styling</h3>\n                    <p>\n                        You can change the cell color, alignment, font weight, margins and more. It's also possible to\n                        freeze first rows or columns, and add clickable images.\n                    </p>\n                </div>\n            </Wrap>\n            <Wrap>\n                <div className=\"box\">\n                    <SheetBoxFormatting />\n                </div>\n                <div className=\"box\">\n                    <h3>Formatting</h3>\n                    <p>\n                        Sheet Happens uses different datasets for display and edit so you can apply different formatting\n                        when displaying the cell and editing the cell.\n                    </p>\n                </div>\n            </Wrap>\n            <Wrap>\n                <div className=\"box\">\n                    <SheetBoxRender />\n                </div>\n                <div className=\"box\">\n                    <h3>Overlays</h3>\n                    <p>You can attach HTML overlays to the sheet, for additional controls, notes, etc.</p>\n                </div>\n            </Wrap>\n            <Wrap>\n                <div className=\"box\">\n                    <SheetBoxGrouped />\n                </div>\n                <div className=\"box\">\n                    <h3>Grouped rows and columns</h3>\n                    <p>You can make rows act as a group for drag-and-drop operation.</p>\n                </div>\n            </Wrap>\n\n            <div className=\"spacer\" />\n\n            <TitleSeparator title=\"Big dataset example\" id=\"big dataset example\" />\n            <Wrap>\n                <div className=\"box full-width\">\n                    <p>\n                        Our Sheet is designed and built with big datasets in mind. No matter the size of your data, it\n                        will be handled blazingly fast and super responsive because component is canvas-based and it\n                        draws only the small chunk of data user sees at the moment.\n                    </p>\n                    <br />\n                    <SheetBoxVeryBigData />\n                </div>\n            </Wrap>\n\n            <div className=\"spacer\" />\n\n            <TitleSeparator title=\"Custom input fields\" id=\"custom input example\" />\n            <Wrap>\n                <div className=\"box\">\n                    <SheetBoxCustomInput />\n                </div>\n                <div className=\"box\">\n                    <h3>Custom input component</h3>\n                    <p>\n                        If basic text input isn't enough, you can send your own React component to be displayed instead.\n                    </p>\n                </div>\n            </Wrap>\n\n            <div className=\"spacer\" />\n\n            <TitleSeparator title=\"Documentation\" id=\"documentation\" />\n            <Wrap>\n                <div className=\"box full-width\">\n                    {/* sourceData displayData */}\n                    <h3>Displaying data</h3>\n                    <p>\n                        If you have some data you want to display, you send it via <Emphased text=\"sourceData\" /> and{' '}\n                        <Emphased text=\"displayData\" /> props.\n                    </p>\n                    <p>\n                        The first one receives unformatted data which is used for data manipulation, and the second one\n                        formatted which is used for displaying in cells.\n                    </p>\n                    <br />\n                    <p>\n                        Each of this can be either array of arrays of values (where each array is representing data for\n                        one row) or function (which returns value based on x and y coordinates that are sent as\n                        arguments to your function).\n                    </p>\n                </div>\n            </Wrap>\n\n            <Wrap>\n                <div className=\"box colored-pre unmargin-pre\" style={{ maxWidth: '100%', overflow: 'auto' }}>\n                    <SourceDisplayDataCode />\n                </div>\n                <div className=\"box\">\n                    <SheetBoxSourceDisplayData />\n                </div>\n            </Wrap>\n\n            <div className=\"spacer\" />\n\n            <Wrap>\n                <div className=\"box\">\n                    {/*editData onChange readOnly */}\n                    <h3>Editing data</h3>\n                    <p>\n                        Same as the previous two, prop <Emphased text=\"editData\" /> can recieve either array of arrays\n                        of values or function for data which will be displayed in edit mode. Edit mode is activated by\n                        double click on the cell.\n                    </p>\n                    <br />\n                    <p>\n                        Once edit is done, function sent in <Emphased text=\"onChange\" /> prop will be called with array\n                        of changes as an argument. Each element of this array has value, x and y coordinates. Use this\n                        information to change values in your data array.\n                    </p>\n                    <br />\n                    <p>\n                        Sheet also accepts <Emphased text=\"readOnly\" /> prop which you can use if some cells should not\n                        be editable. Same as the most of sheet's props, you can send function, array of arrays, or a\n                        single value which then is applied to the whole table.\n                    </p>\n                </div>\n\n                <div className=\"box unmargin-pre\">\n                    <EditDataCode />\n                </div>\n            </Wrap>\n\n            <div className=\"spacer\" />\n\n            <Wrap>\n                <div className=\"box full-width\">\n                    {/* columnHeaders */}\n                    <h3>Column headers</h3>\n                    <p>\n                        By default, sheet has excel-like headers (A, B, C, ...) but you can send yours via{' '}\n                        <Emphased text=\"columnHeaders\" /> prop as an array or function.\n                    </p>\n                </div>\n            </Wrap>\n\n            <div className=\"spacer\" />\n\n            <Wrap>\n                <div className=\"box\">\n                    {/* cellStyle cellWidth cellHeight onCellWidthChange onCellHeightChange */}\n                    <h3>Cell style and width/height</h3>\n                    <p>\n                        Use prop <Emphased text=\"cellStyle\" /> and <Emphased text=\"columnHeaderStyle\" /> for customizing\n                        cells visually.\n                    </p>\n                    <br />\n                    <p>\n                        You can also use <Emphased text=\"cellWidth\" /> and <Emphased text=\"cellHeight\" /> props to\n                        customize cell size. If you send single value {`cellWidth={200}`}, it will be applied to all\n                        cells. If you send array of values {`cellWidth={[200, 80, 80]}`}, they will be applied in\n                        respect to the index number.\n                    </p>\n                    <br />\n                    <p>\n                        There are also <Emphased text=\"onCellWidthChange\" /> and <Emphased text=\"onCellHeightChange\" />{' '}\n                        props for functions which are called when user drags cell for resize. You can use these for\n                        updating your cellWidth/cellHeight arrays.\n                    </p>\n                </div>\n                <div className=\"box unmargin-pre\">\n                    <CellStyleSizeCode />\n                </div>\n            </Wrap>\n\n            <div className=\"spacer\" />\n\n            <Wrap>\n                <div className=\"box full-width\">\n                    {/* onSelectionChanged */}\n                    <h3>Selection</h3>\n                    <p>\n                        You can send a function to the <Emphased text=\"onSelectionChanged\" /> prop. It will be called on\n                        selection change with x1, y1, x2 and y2 arguments.\n                    </p>\n                </div>\n            </Wrap>\n\n            <div className=\"spacer\" />\n\n            <Wrap>\n                <div className=\"box full-width\">\n                    {/* onRightClick */}\n                    <h3>Right click handler</h3>\n                    <p>\n                        If you send a function to <Emphased text=\"onRightClick\" /> prop, it will be called on right\n                        click with whole mouse event (extended with cellX and cellY values) as an argument.\n                    </p>\n                </div>\n            </Wrap>\n\n            <div className=\"spacer\" />\n\n            <Wrap>\n                <div className=\"box full-width\">\n                    {/* freezeColumns freezeRows */}\n                    <h3>Sticky columns/rows</h3>\n                    <p>\n                        Send a number to <Emphased text=\"freezeColumns\" /> and/or <Emphased text=\"freezeRows\" /> to make\n                        first n of columns/rows sticky.\n                    </p>\n                </div>\n            </Wrap>\n\n            <div className=\"spacer\" />\n\n            <Wrap>\n                <div className=\"box full-width\">\n                    {/* inputComponent */}\n                    <h3>Custom input</h3>\n                    <p>\n                        By default edit mode turns the cell into a text edit component. But you can send your custom\n                        input component via <Emphased text=\"inputComponent\" /> props. It will be called with{' '}\n                        <Emphased text=\"x\" />, <Emphased text=\"y\" />, <Emphased text=\"inputProps\" /> and{' '}\n                        <Emphased text=\"commitEditingCell\" /> arguments.\n                    </p>\n                </div>\n            </Wrap>\n\n            <div className=\"spacer\" />\n\n            <Footer />\n        </>\n    );\n};\n\nfunction Emphased({ text }) {\n    return <span className=\"emphased\">{text}</span>;\n}\n\nexport default App;\n","import './index.css';\n\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(<App />, document.getElementById('root'));\n"],"sourceRoot":""}