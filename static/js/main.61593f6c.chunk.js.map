{"version":3,"sources":["../../node_modules/use-resize-observer/dist/bundle.esm.js","../../src/index.js","App.js","index.js"],"names":["useResizeObserver","opts","onResize","onResizeRef","undefined","current","resizeObserverRef","_useState","width","height","size","setSize","didUnmount","previous","refCallback","subscriber","refOrElement","_ref","ref","refElement","callbackRefElement","element","callSubscriber","lastReportedElementRef","cleanupRef","HTMLElement","useResolvedElement","ResizeObserver","entries","Array","isArray","length","entry","newWidth","Math","round","contentRect","newHeight","newSize","observe","unobserve","resizeCanvas","canvas","devicePixelRatio","ratio","newCanvasWidth","newCanvasHeight","context","createRowOrColumnPropFunction","sizeProp","defaultValue","cell","createCellPropFunction","cellProp","x","y","drawCell","cellContent","style","defaultCellStyle","xCoord","yCoord","cellWidth","cellHeight","xx","yy","obj","calculateRowsOrColsSizes","freezeCount","startingSize","startingIndex","visibleArea","visible","start","end","prev","ind","props","canvasRef","useRef","overlayRef","copyPasteTextAreaRef","useState","x1","y1","x2","y2","hitTarget","canvasWidth","canvasHeight","freezeColumns","freezeRows","textAlign","fontSize","marginRight","marginLeft","color","fontFamily","weight","columnHeaders","cellReadOnly","sourceData","displayData","editData","cellStyle","dataOffset","columnXEnd","rowYEnd","changeSelection","scrollToP2","setSelection","newDataOffset","newScrollLeft","newScrollTop","visibleColumns","increment","newX","visibleRows","newY","setDataOffset","setTimeout","sx1","sy1","sx2","sy2","absCoordianteToCell","absX","absY","cellX","cellY","i","columnXStart","rowYStart","cellToAbsCoordinate","indX","indY","knobCoordinates","useMemo","selection","selx2","sely2","c","hitMap","hitM","absX1","absY1","absX2","absY2","w","h","onClick","x1key","x2key","y1key","y2key","xkey","xbin","ykey","useEffect","animationFrameId","window","yCoord1","xCoord1","hideKnob","selx1","sely1","selectionActive","p1","p2","currentCol","currentRow","startX","startY","rowHeaderWidth","row","columnHeaderHeight","ch","headerCellStyle","col","kx1","knobArea","kx2","ky1","ky2","knobPoint1","knobPoint2","knobSize","cw","setFocusToTextArea","preventScroll","setCopyPasteText","document","activeTagName","onPaste","e","clipboardData","types","pastedHtml","parsePastedHtml","text","parsePastedText","findTable","child","maybeTable","html","div","pasteLocX","pasteLocY","changes","tableNode","tableChild","tr","td","value","innerHTML","rows","pasteX2","pasteY2","cols","dy1","dy2","dx1","dx2","cptext","commitEditingCell","editCell","editValue","setEditCell","startEditingCell","editDataValue","val","setEditValue","onMouseUp","fx1","fy1","fx2","fy2","srcY","srcX","setSelectionInProgress","setRowSelectionInProgress","setColumnSelectionInProgress","setKnobDragInProgress","setColumnResize","setRowResize","buttonClickMouseDownCoordinates","rect","setButtonClickMouseDownCoordinates","onMouseMove","hitTargetKeyX","hitTargetKeyY","columnResize","rowResize","sel2","columnSelectionInProgress","setKnobArea","editMode","editTextPosition","editTextWidth","editTextHeight","editTextTextAlign","position","outline","onDoubleClick","setArrowKeyCommitMode","onMouseDown","oldWidth","colIdx","oldHeight","rowIdx","sel1","shiftKeyDown","onMouseLeave","onContextMenu","onScroll","newMaxScroll","maxScroll","setMaxScroll","className","styles","top","left","overflow","borderBottom","backgroundColor","opacity","onFocus","autoFocus","tabIndex","onKeyDown","includes","String","setShiftKeyDown","onKeyUp","type","arrowKeyCommitMode","onChange","border","App","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.61593f6c.chunk.js","sourcesContent":["import { useRef, useState, useEffect, useMemo, useCallback } from 'react';\n\n// This of course could've been more streamlined with internal state instead of\n// refs, but then host hooks / components could not opt out of renders.\n// This could've been exported to its own module, but the current build doesn't\n// seem to work with module imports and I had no more time to spend on this...\nfunction useResolvedElement(subscriber, refOrElement) {\n  var _ref;\n\n  // The default ref has to be non-conditionally declared here whether or not\n  // it'll be used as that's how hooks work.\n  // @see https://reactjs.org/docs/hooks-rules.html#explanation\n  var ref = null; // Default ref\n\n  var refElement = useRef(null);\n  var callbackRefElement = useRef(null);\n  var refCallback = useCallback(function (element) {\n    callbackRefElement.current = element;\n    callSubscriber();\n  }, []);\n  var lastReportedElementRef = useRef(null);\n  var cleanupRef = useRef();\n\n  var callSubscriber = function callSubscriber() {\n    var element = null;\n\n    if (callbackRefElement.current) {\n      element = callbackRefElement.current;\n    } else if (refElement.current) {\n      element = refElement.current;\n    } else if (refOrElement instanceof HTMLElement) {\n      element = refOrElement;\n    }\n\n    if (lastReportedElementRef.current === element) {\n      return;\n    }\n\n    if (cleanupRef.current) {\n      cleanupRef.current(); // Making sure the cleanup is not called accidentally multiple times.\n\n      cleanupRef.current = null;\n    }\n\n    lastReportedElementRef.current = element; // Only calling the subscriber, if there's an actual element to report.\n\n    if (element) {\n      cleanupRef.current = subscriber(element);\n    }\n  };\n\n  if (refOrElement && !(refOrElement instanceof HTMLElement)) {\n    // Overriding the default ref with the given one\n    ref = refOrElement;\n  } // On each render, we check whether a ref changed, or if we got a new raw\n  // element.\n\n\n  useEffect(function () {\n    // Note that this does not mean that \"element\" will necessarily be whatever\n    // the ref currently holds. It'll simply \"update\" `element` each render to\n    // the current ref value, but there's no guarantee that the ref value will\n    // not change later without a render.\n    // This may or may not be a problem depending on the specific use case.\n    if (ref) {\n      refElement.current = ref.current;\n    }\n\n    callSubscriber();\n  }, [ref, (_ref = ref) == null ? void 0 : _ref.current, refOrElement]);\n  return refCallback;\n}\n\nfunction useResizeObserver(opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  // Saving the callback as a ref. With this, I don't need to put onResize in the\n  // effect dep array, and just passing in an anonymous function without memoising\n  // will not reinstantiate the hook's ResizeObserver\n  var onResize = opts.onResize;\n  var onResizeRef = useRef(undefined);\n  onResizeRef.current = onResize; // Using a single instance throughout the hook's lifetime\n\n  var resizeObserverRef = useRef();\n\n  var _useState = useState({\n    width: undefined,\n    height: undefined\n  }),\n      size = _useState[0],\n      setSize = _useState[1]; // In certain edge cases the RO might want to report a size change just after\n  // the component unmounted.\n\n\n  var didUnmount = useRef(false);\n  useEffect(function () {\n    return function () {\n      didUnmount.current = true;\n    };\n  }, []); // Using a ref to track the previous width / height to avoid unnecessary renders\n\n  var previous = useRef({\n    width: undefined,\n    height: undefined\n  }); // This block is kinda like a useEffect, only it's called whenever a new\n  // element could be resolved based on the ref option. It also has a cleanup\n  // function.\n\n  var refCallback = useResolvedElement(function (element) {\n    // Initialising the RO instance\n    if (!resizeObserverRef.current) {\n      // Saving a single instance, used by the hook from this point on.\n      resizeObserverRef.current = new ResizeObserver(function (entries) {\n        if (!Array.isArray(entries)) {\n          return;\n        } // Since we only observe the one element, we don't need to loop over the\n        // array\n\n\n        if (!entries.length) {\n          return;\n        }\n\n        var entry = entries[0]; // `Math.round` is in line with how CSS resolves sub-pixel values\n\n        var newWidth = Math.round(entry.contentRect.width);\n        var newHeight = Math.round(entry.contentRect.height);\n\n        if (previous.current.width !== newWidth || previous.current.height !== newHeight) {\n          var newSize = {\n            width: newWidth,\n            height: newHeight\n          };\n\n          if (onResizeRef.current) {\n            onResizeRef.current(newSize);\n          } else {\n            previous.current.width = newWidth;\n            previous.current.height = newHeight;\n\n            if (!didUnmount.current) {\n              setSize(newSize);\n            }\n          }\n        }\n      });\n    }\n\n    resizeObserverRef.current.observe(element);\n    return function () {\n      if (resizeObserverRef.current) {\n        resizeObserverRef.current.unobserve(element);\n      }\n    };\n  }, opts.ref);\n  return useMemo(function () {\n    return {\n      ref: refCallback,\n      width: size.width,\n      height: size.height\n    };\n  }, [refCallback, size ? size.width : null, size ? size.height : null]);\n}\n\nexport default useResizeObserver;\n","import styles from './styles.module.css';\nimport React, { useRef, useEffect, useState, useMemo } from 'react';\nimport useResizeObserver from 'use-resize-observer';\n\nfunction resizeCanvas(canvas) {\n    const { width, height } = canvas.getBoundingClientRect();\n    let { devicePixelRatio: ratio = 1 } = window;\n    if (ratio < 1) {\n        ratio = 1;\n    }\n    const newCanvasWidth = Math.round(width * ratio);\n    const newCanvasHeight = Math.round(height * ratio);\n\n    if (canvas.width !== newCanvasWidth || canvas.height !== newCanvasHeight) {\n        const context = canvas.getContext('2d');\n        canvas.width = newCanvasWidth;\n        canvas.height = newCanvasHeight;\n        context.scale(ratio, ratio);\n        return true;\n    }\n\n    return false;\n}\n\nfunction createRowOrColumnPropFunction(sizeProp, defaultValue) {\n    return (cell) => {\n        if (Array.isArray(sizeProp)) {\n            if (cell >= 0 && cell < sizeProp.length) {\n                return sizeProp[cell];\n            } else {\n                return defaultValue;\n            }\n        } else if (typeof sizeProp === 'function') {\n            return sizeProp(cell);\n        } else if (typeof sizeProp === 'number') {\n            return sizeProp;\n        } else {\n            return defaultValue;\n        }\n    };\n}\n\nfunction createCellPropFunction(cellProp, defaultValue) {\n    return (x, y) => {\n        if (Array.isArray(cellProp)) {\n            if (y >= 0 && y < cellProp.length) {\n                if (x >= 0 && x < cellProp[y].length) {\n                    return cellProp[y][x];\n                } else {\n                    return defaultValue;\n                }\n            } else {\n                return defaultValue;\n            }\n        } else if (typeof cellProp === 'function') {\n            return cellProp(x, y);\n        } else if (cellProp !== null && cellProp !== undefined) {\n            return cellProp;\n        } else {\n            return defaultValue;\n        }\n    };\n}\n\nfunction drawCell(context, cellContent, style, defaultCellStyle, xCoord, yCoord, cellWidth, cellHeight) {\n    style.color = style.color || defaultCellStyle.color;\n    style.fontSize = style.fontSize || defaultCellStyle.fontSize;\n    style.fontFamily = style.fontFamily || defaultCellStyle.fontFamily;\n    style.textAlign = style.textAlign || defaultCellStyle.textAlign;\n    style.marginRight = style.marginRight || defaultCellStyle.marginRight;\n    style.marginLeft = style.marginLeft || defaultCellStyle.marginLeft;\n    style.weight = style.weight || defaultCellStyle.weight;\n\n    context.fillStyle = style.color;\n    context.font = style.weight + style.fontSize + 'px ' + style.fontFamily;\n    context.textAlign = style.textAlign;\n\n    const adjustment = style.textAlign === 'right' ? cellWidth - style.marginRight : style.marginLeft;\n    const xx = xCoord + adjustment;\n    const yy = yCoord + cellHeight * 0.5;\n\n    context.save();\n    context.beginPath();\n    context.rect(xCoord, yCoord, cellWidth, cellHeight);\n    context.clip();\n\n    if (style.backgroundColor) {\n        context.fillStyle = style.backgroundColor;\n        context.fillRect(xCoord, yCoord, cellWidth, cellHeight);\n        context.fillStyle = style.color;\n    }\n\n    if (Array.isArray(cellContent)) {\n        for (const obj of cellContent) {\n            if (obj.content instanceof HTMLImageElement) {\n                context.drawImage(obj.content, xCoord + obj.x, yy + obj.y, obj.width, obj.height);\n            } else if (typeof obj.content === 'string') {\n                context.fillText(obj.content, xCoord + obj.x, yy + obj.y);\n            }\n        }\n    } else {\n        context.fillText(cellContent, xx, yy);\n    }\n    context.restore();\n}\n\nfunction calculateRowsOrColsSizes(freezeCount, size, startingSize, startingIndex, visibleArea) {\n    const visible = [];\n    const start = [];\n    const end = [];\n    let prev = 0;\n\n    start.push(startingSize);\n    visible.push(freezeCount > 0 ? 0 : startingIndex);\n    let firstSize = freezeCount > 0 ? size(0) : size(startingIndex);\n    prev = startingSize + firstSize;\n    end.push(prev);\n\n    let ind = freezeCount > 0 ? 1 : startingIndex + 1;\n\n    if (freezeCount > 0) {\n        for (; ind < freezeCount; ind++) {\n            visible.push(ind);\n            start.push(prev);\n            prev = prev + size(ind);\n            end.push(prev);\n        }\n        ind = Math.max(startingIndex, freezeCount);\n    }\n\n    while (true) {\n        visible.push(ind);\n        start.push(prev);\n        prev = prev + size(ind);\n        end.push(prev);\n        if (end[end.length - 1] >= visibleArea) {\n            break;\n        }\n        ind++;\n    }\n    return {\n        visible,\n        start,\n        end,\n    };\n}\n\nfunction Sheet(props) {\n    const canvasRef = useRef(null);\n    const overlayRef = useRef(null);\n    const copyPasteTextAreaRef = useRef(null);\n    const [maxScroll, setMaxScroll] = useState({ x: 5000, y: 5000 });\n    const [dataOffset, setDataOffset] = useState({ x: 0, y: 0 });\n    const [selection, setSelection] = useState({ x1: -1, y1: -1, x2: -1, y2: -1 });\n    const [knobArea, setKnobArea] = useState({ x1: -1, y1: -1, x2: -1, y2: -1 });\n    const [editCell, setEditCell] = useState({ x: -1, y: -1 });\n    const [editValue, setEditValue] = useState('');\n    const [arrowKeyCommitMode, setArrowKeyCommitMode] = useState(false);\n    const [shiftKeyDown, setShiftKeyDown] = useState(false);\n    const [knobDragInProgress, setKnobDragInProgress] = useState(false);\n    const [selectionInProgress, setSelectionInProgress] = useState(false);\n    const [columnResize, setColumnResize] = useState(null);\n    const [rowResize, setRowResize] = useState(null);\n    const [rowSelectionInProgress, setRowSelectionInProgress] = useState(false);\n    const [columnSelectionInProgress, setColumnSelectionInProgress] = useState(false);\n    const [buttonClickMouseDownCoordinates, setButtonClickMouseDownCoordinates] = useState({\n        x: -1,\n        y: -1,\n        hitTarget: null,\n    });\n    const { width: canvasWidth = 3000, height: canvasHeight = 3000 } = useResizeObserver({ ref: canvasRef });\n\n    const selBorderColor = '#1b73e7';\n    const selBackColor = '#e9f0fd';\n    const knobSize = 6;\n    const gridColor = '#e2e3e3';\n    const knobAreaBorderColor = '#707070';\n    const rowHeaderWidth = 50;\n    const rowHeaderBackgroundColor = '#f8f9fa';\n    const rowHeaderTextColor = '#666666';\n    const rowHeaderSelectedBackgroundColor = '#e8eaed';\n    const columnHeaderHeight = 22;\n    const columnHeaderBackgroundColor = rowHeaderBackgroundColor;\n    const columnHeaderSelectedBackgroundColor = rowHeaderSelectedBackgroundColor;\n    const columnHeaderTextColor = rowHeaderTextColor;\n    const xBinSize = 10;\n    const yBinSize = 10;\n    const scrollSpeed = 30;\n    const resizeColumnRowMouseThreshold = 4;\n    const minimumColumnWidth = 50;\n    const minimumRowHeight = 22;\n\n    const freezeColumns = props.freezeColumns || 0;\n    const freezeRows = props.freezeRows || 0;\n\n    const defaultCellStyle = {\n        textAlign: 'left',\n        fontSize: 13,\n        marginRight: 5,\n        marginLeft: 5,\n        color: '#000',\n        fontFamily: 'sans-serif',\n        weight: '',\n    };\n\n    const cellWidth = createRowOrColumnPropFunction(props.cellWidth, 100);\n    const cellHeight = createRowOrColumnPropFunction(props.cellHeight, 22);\n    const columnHeaders = createRowOrColumnPropFunction(props.columnHeaders, null);\n\n    const cellReadOnly = createCellPropFunction(props.readOnly, false);\n\n    const sourceData = createCellPropFunction(props.sourceData, null);\n    const displayData = createCellPropFunction(props.displayData, null);\n    const editData = createCellPropFunction(props.editData, null);\n    const cellStyle = createCellPropFunction(props.cellStyle, defaultCellStyle);\n\n    // todo: somehow memoize, or only recalculate when inputs change...\n    const { visible: visibleColumns, start: columnXStart, end: columnXEnd } = calculateRowsOrColsSizes(\n        freezeColumns,\n        cellWidth,\n        rowHeaderWidth,\n        dataOffset.x,\n        canvasWidth\n    );\n\n    const { visible: visibleRows, start: rowYStart, end: rowYEnd } = calculateRowsOrColsSizes(\n        freezeRows,\n        cellHeight,\n        columnHeaderHeight,\n        dataOffset.y,\n        canvasHeight\n    );\n\n    const changeSelection = (x1, y1, x2, y2, scrollToP2 = true) => {\n        setSelection({ x1, y1, x2, y2 });\n\n        if (scrollToP2) {\n            const newDataOffset = { x: dataOffset.x, y: dataOffset.y };\n            let newScrollLeft = -1;\n            let newScrollTop = -1;\n\n            if (!visibleColumns.includes(x2) || visibleColumns[visibleColumns.length - 1] === x2) {\n                const increment = visibleColumns[visibleColumns.length - 1] <= x2 ? 1 : -1;\n                const newX = Math.max(dataOffset.x, freezeColumns) + increment;\n                newDataOffset.x = newX;\n                newScrollLeft = newX * scrollSpeed;\n            }\n\n            if (!visibleRows.includes(y2) || visibleRows[visibleRows.length - 1] === y2) {\n                const increment = visibleRows[visibleRows.length - 1] <= y2 ? 1 : -1;\n                const newY = Math.max(dataOffset.y, freezeRows) + increment;\n                newDataOffset.y = newY;\n                newScrollTop = newY * scrollSpeed;\n            }\n\n            if (newDataOffset.x !== dataOffset.x || dataOffset.y !== newDataOffset.y) {\n                setDataOffset({ x: newDataOffset.x, y: newDataOffset.y });\n                setTimeout(() => {\n                    if (overlayRef.current) {\n                        if (newScrollLeft !== -1) {\n                            overlayRef.current.scrollLeft = newScrollLeft;\n                        }\n                        if (newScrollTop !== -1) {\n                            overlayRef.current.scrollTop = newScrollTop;\n                        }\n                    }\n                }, 0);\n            }\n        }\n\n        if (props.onSelectionChanged) {\n            let sx1 = x1;\n            let sy1 = y1;\n            let sx2 = x2;\n            let sy2 = y2;\n            if (sx1 > sx2) {\n                sx1 = x2;\n                sx2 = x1;\n            }\n            if (sy1 > sy2) {\n                sy1 = y2;\n                sy2 = y1;\n            }\n            props.onSelectionChanged(sx1, sy1, sx2, sy2);\n        }\n    };\n\n    const absCoordianteToCell = (absX, absY) => {\n        let cellX = 0;\n        let cellY = 0;\n\n        for (let i = 0; i < visibleColumns.length; i++) {\n            if (absX >= columnXStart[i] && absX <= columnXEnd[i]) {\n                cellX = visibleColumns[i];\n                break;\n            }\n        }\n        for (let i = 0; i < visibleRows.length; i++) {\n            if (absY >= rowYStart[i] && absY <= rowYEnd[i]) {\n                cellY = visibleRows[i];\n                break;\n            }\n        }\n\n        return { x: cellX, y: cellY };\n    };\n\n    const cellToAbsCoordinate = (cellX, cellY) => {\n        let absX = rowHeaderWidth;\n        const indX = visibleColumns.findIndex((i) => i === cellX);\n        if (indX !== -1) {\n            absX = columnXStart[indX];\n        } else {\n            for (let i = 0; i < dataOffset.x; i++) {\n                absX -= cellWidth(i);\n            }\n            for (let i = 0; i < cellX; i++) {\n                absX += cellWidth(i);\n            }\n        }\n\n        let absY = columnHeaderHeight;\n        const indY = visibleRows.findIndex((i) => i === cellY);\n        if (indY !== -1) {\n            absY = rowYStart[indY];\n        } else {\n            for (let i = 0; i < dataOffset.y; i++) {\n                absY -= cellHeight(i);\n            }\n            for (let i = 0; i < cellY; i++) {\n                absY += cellHeight(i);\n            }\n        }\n        return { x: absX, y: absY };\n    };\n\n    const knobCoordinates = useMemo(() => {\n        if (selection.x2 !== -1 && selection.y2 !== -1) {\n            let selx2 = selection.x2;\n            if (selection.x1 > selection.x2) {\n                selx2 = selection.x1;\n            }\n\n            let sely2 = selection.y2;\n            if (selection.y1 > selection.y2) {\n                sely2 = selection.y1;\n            }\n            const c = cellToAbsCoordinate(selx2, sely2);\n            return { x: c.x + cellWidth(selx2), y: c.y + cellHeight(sely2) };\n        }\n        return { x: -1, y: -1 };\n    }, [selection, visibleRows, visibleColumns]);\n\n    const hitMap = useMemo(() => {\n        const hitM = {};\n        const canvas = canvasRef.current;\n        if (!canvas) {\n            return hitM;\n        }\n        resizeCanvas(canvas);\n        let yCoord = columnHeaderHeight;\n        for (const y of visibleRows) {\n            let xCoord = rowHeaderWidth;\n            for (const x of visibleColumns) {\n                const cellContent = displayData(x, y);\n                if (cellContent === null || cellContent === undefined) {\n                    xCoord += cellWidth(x);\n                    continue;\n                }\n\n                const xx = xCoord;\n                const yy = yCoord + cellHeight(y) * 0.5;\n\n                if (Array.isArray(cellContent)) {\n                    for (const obj of cellContent) {\n                        if (obj.onClick) {\n                            const absX1 = xx + obj.x;\n                            const absY1 = yy + obj.y;\n                            const absX2 = absX1 + obj.width;\n                            const absY2 = absY1 + obj.height;\n\n                            const hitTarget = {\n                                cellX: x,\n                                cellY: y,\n                                x: absX1,\n                                y: absY1,\n                                w: obj.width,\n                                h: obj.height,\n                                onClick: obj.onClick,\n                            };\n\n                            // add to hit map\n                            const x1key = Math.floor(absX1 / xBinSize);\n                            const x2key = Math.floor(absX2 / xBinSize);\n\n                            const y1key = Math.floor(absY1 / yBinSize);\n                            const y2key = Math.floor(absY2 / yBinSize);\n\n                            for (let xkey = x1key; xkey <= x2key; xkey++) {\n                                if (!hitM[xkey]) {\n                                    hitM[xkey] = {};\n                                }\n                                const xbin = hitM[xkey];\n                                for (let ykey = y1key; ykey <= y2key; ykey++) {\n                                    if (!xbin[ykey]) {\n                                        xbin[ykey] = [];\n                                    }\n                                    xbin[ykey].push(hitTarget);\n                                }\n                            }\n                        }\n                    }\n                }\n                xCoord += cellWidth(x);\n            }\n            yCoord += cellHeight(y);\n        }\n        return hitM;\n    }, [displayData, props.cellWidth, props.cellHeight, dataOffset.x, dataOffset.y]);\n\n    useEffect(() => {\n        const canvas = canvasRef.current;\n        const context = canvas.getContext('2d');\n        let animationFrameId = window.requestAnimationFrame(() => {\n            resizeCanvas(canvas);\n            context.clearRect(0, 0, context.canvas.width, context.canvas.height);\n            context.fillStyle = 'white';\n            context.fillRect(0, 0, context.canvas.width, context.canvas.height);\n\n            // apply cell fill color\n            let yCoord1 = columnHeaderHeight;\n            for (const y of visibleRows) {\n                let xCoord1 = rowHeaderWidth;\n                for (const x of visibleColumns) {\n                    const style = cellStyle(x, y);\n                    if (style.fillColor) {\n                        context.fillStyle = style.fillColor;\n                        context.fillRect(xCoord1, yCoord1, cellWidth(x), cellHeight(y));\n                    }\n                    xCoord1 += cellWidth(x);\n                }\n                yCoord1 += cellHeight(y);\n            }\n\n            let hideKnob = false;\n\n            let selx1 = selection.x1;\n            let selx2 = selection.x2;\n\n            if (selection.x1 > selection.x2) {\n                selx1 = selection.x2;\n                selx2 = selection.x1;\n            }\n\n            let sely1 = selection.y1;\n            let sely2 = selection.y2;\n\n            if (selection.y1 > selection.y2) {\n                sely1 = selection.y2;\n                sely2 = selection.y1;\n            }\n\n            const selectionActive = selx1 !== -1 && selx2 !== -1 && sely1 !== -1 && sely2 !== -1;\n\n            const p1 = cellToAbsCoordinate(selx1, sely1);\n            const p2 = cellToAbsCoordinate(selx2, sely2);\n            p2.x += cellWidth(selx2);\n            p2.y += cellHeight(sely2);\n\n            if (p1.x >= p2.x) {\n                // recalculate if the selection span covers both frozen and unfrozen columns\n                p2.x = p1.x;\n                let currentCol = selx1;\n                while (visibleColumns.includes(currentCol)) {\n                    p2.x += cellWidth(currentCol);\n                    currentCol++;\n                }\n                hideKnob = true;\n            }\n\n            if (p1.y >= p2.y) {\n                // recalculate if the selection span covers both frozen and unfrozen rows\n                p2.y = p1.y;\n                let currentRow = sely1;\n                while (visibleRows.includes(currentRow)) {\n                    p2.y += cellHeight(currentRow);\n                    currentRow++;\n                }\n                hideKnob = true;\n            }\n\n            // selection fill\n            if (selectionActive) {\n                context.fillStyle = selBackColor;\n                context.fillRect(p1.x, p1.y, p2.x - p1.x, p2.y - p1.y);\n            }\n\n            // row header background\n            context.fillStyle = rowHeaderBackgroundColor;\n            context.fillRect(0, 0, rowHeaderWidth, context.canvas.height);\n\n            // row header selection\n            if (selectionActive) {\n                context.fillStyle = rowHeaderSelectedBackgroundColor;\n                context.fillRect(0, p1.y, rowHeaderWidth, p2.y - p1.y);\n            }\n\n            // column header background\n            context.fillStyle = columnHeaderBackgroundColor;\n            context.fillRect(0, 0, context.canvas.width, columnHeaderHeight);\n\n            // column header selection\n            if (selectionActive) {\n                context.fillStyle = columnHeaderSelectedBackgroundColor;\n                context.fillRect(p1.x, 0, p2.x - p1.x, columnHeaderHeight);\n            }\n\n            // grid\n            context.strokeStyle = gridColor;\n            context.lineWidth = 1;\n            let startX = rowHeaderWidth;\n\n            for (const col of visibleColumns) {\n                context.beginPath();\n                context.moveTo(startX, 0);\n                context.lineTo(startX, context.canvas.height);\n                context.stroke();\n                startX += cellWidth(col);\n            }\n\n            let startY = columnHeaderHeight;\n            for (const row of visibleRows) {\n                context.beginPath();\n                context.moveTo(0, startY);\n                context.lineTo(context.canvas.width, startY);\n                context.stroke();\n                startY += cellHeight(row);\n            }\n\n            // row header text\n            startY = columnHeaderHeight;\n            context.textBaseline = 'middle';\n            context.textAlign = 'center';\n            context.font = defaultCellStyle.fontSize + 'px ' + defaultCellStyle.fontFamily;\n            context.fillStyle = rowHeaderTextColor;\n            for (const row of visibleRows) {\n                const xx = rowHeaderWidth * 0.5;\n                const yy = startY + cellHeight(row) * 0.5;\n                const cellContent = row + 1;\n                context.fillText(cellContent, xx, yy);\n                startY += cellHeight(row);\n            }\n\n            // column header text\n            startX = rowHeaderWidth;\n            context.textBaseline = 'middle';\n            context.textAlign = 'center';\n            for (const col of visibleColumns) {\n                const xx = startX + cellWidth(col) * 0.5;\n                const yy = columnHeaderHeight * 0.5;\n                const ch = columnHeaders(col);\n                let headerCellStyle = {};\n                let cellContent = null;\n                if (typeof ch === 'object' && ch !== null && ch.headerCellStyle) {\n                    headerCellStyle = ch.headerCellStyle;\n                }\n                if (typeof ch === 'object' && ch !== null) {\n                    cellContent = ch.cellContent;\n                } else {\n                    cellContent = ch;\n                }\n\n                headerCellStyle.color = headerCellStyle.color || columnHeaderTextColor;\n                headerCellStyle.fontSize = headerCellStyle.fontSize || defaultCellStyle.fontSize;\n                headerCellStyle.fontFamily = headerCellStyle.fontFamily || defaultCellStyle.fontFamily;\n                headerCellStyle.weight = headerCellStyle.weight || defaultCellStyle.weight;\n                context.font = headerCellStyle.weight + headerCellStyle.fontSize + 'px ' + headerCellStyle.fontFamily;\n                context.fillStyle = headerCellStyle.color;\n                if (cellContent === null || cellContent === undefined) {\n                    cellContent = col + 1;\n                }\n                context.fillText(cellContent, xx, yy);\n                startX += cellWidth(col);\n            }\n\n            // selection outline\n            if (selectionActive) {\n                context.strokeStyle = selBorderColor;\n                context.lineWidth = 1;\n                context.beginPath();\n                context.rect(p1.x, p1.y, p2.x - p1.x, p2.y - p1.y);\n                context.stroke();\n            }\n\n            // knob drag outline\n            if (knobDragInProgress) {\n                let kx1 = knobArea.x1;\n                let kx2 = knobArea.x2;\n                if (knobArea.x1 > knobArea.x2) {\n                    kx1 = knobArea.x2;\n                    kx2 = knobArea.x1;\n                }\n\n                let ky1 = knobArea.y1;\n                let ky2 = knobArea.y2;\n                if (knobArea.y1 > knobArea.y2) {\n                    ky1 = knobArea.y2;\n                    ky2 = knobArea.y1;\n                }\n                const knobPoint1 = cellToAbsCoordinate(kx1, ky1);\n                const knobPoint2 = cellToAbsCoordinate(kx2 + 1, ky2 + 1);\n                context.strokeStyle = knobAreaBorderColor;\n                context.setLineDash([3, 3]);\n                context.lineWidth = 1;\n                context.beginPath();\n                context.rect(knobPoint1.x, knobPoint1.y - 1, knobPoint2.x - knobPoint1.x, knobPoint2.y - knobPoint1.y);\n                context.stroke();\n                context.setLineDash([]);\n            }\n\n            // selection knob\n            if (selectionActive && !hideKnob) {\n                context.fillStyle = selBorderColor;\n                context.fillRect(p2.x - knobSize * 0.5, p2.y - knobSize * 0.5, knobSize, knobSize);\n            }\n\n            // content\n            context.textBaseline = 'middle';\n\n            // draw content\n            let yCoord = columnHeaderHeight;\n            for (const y of visibleRows) {\n                let xCoord = rowHeaderWidth;\n                const ch = cellHeight(y);\n                for (const x of visibleColumns) {\n                    const cellContent = displayData(x, y);\n                    const cw = cellWidth(x);\n                    if (cellContent !== null && cellContent !== undefined) {\n                        const style = cellStyle(x, y);\n                        drawCell(context, cellContent, style, defaultCellStyle, xCoord, yCoord, cw, ch);\n                    }\n                    xCoord += cw;\n                }\n                yCoord += ch;\n            }\n        });\n\n        return () => {\n            window.cancelAnimationFrame(animationFrameId);\n        };\n    }, [\n        props.displayData,\n        dataOffset.x,\n        dataOffset.y,\n        selection,\n        knobDragInProgress,\n        knobArea,\n        canvasWidth,\n        canvasHeight,\n        columnResize,\n        cellWidth,\n        cellHeight,\n    ]);\n\n    const setFocusToTextArea = () => {\n        if (copyPasteTextAreaRef.current) {\n            copyPasteTextAreaRef.current.focus({ preventScroll: true });\n            copyPasteTextAreaRef.current.select();\n        }\n    };\n\n    useEffect(() => {\n        if (!editMode) {\n            setCopyPasteText();\n            if (document.activeElement === copyPasteTextAreaRef.current) {\n                setFocusToTextArea();\n            } else {\n                const activeTagName = document.activeElement.tagName.toLowerCase();\n                if (\n                    !(\n                        (activeTagName === 'div' && document.activeElement.contentEditable === 'true') ||\n                        activeTagName === 'input' ||\n                        activeTagName === 'textarea' ||\n                        activeTagName === 'select'\n                    )\n                ) {\n                    setFocusToTextArea();\n                }\n            }\n        }\n    });\n\n    const onPaste = (e) => {\n        if (!copyPasteTextAreaRef) {\n            return;\n        }\n        if (e.target !== copyPasteTextAreaRef.current) {\n            return;\n        }\n        e.preventDefault();\n\n        const clipboardData = e.clipboardData || window.clipboardData;\n\n        const types = clipboardData.types;\n        if (types.includes('text/html')) {\n            const pastedHtml = clipboardData.getData('text/html');\n            parsePastedHtml(pastedHtml);\n        } else if (types.includes('text/plain')) {\n            const text = clipboardData.getData('text/plain');\n            parsePastedText(text);\n        }\n    };\n\n    useEffect(() => {\n        window.document.addEventListener('paste', onPaste);\n        return () => {\n            window.document.removeEventListener('paste', onPaste);\n        };\n    });\n\n    const findTable = (element) => {\n        for (const child of element.children) {\n            if (child.nodeName === 'TABLE') {\n                return child;\n            }\n            const maybeTable = findTable(child);\n            if (maybeTable) {\n                return maybeTable;\n            }\n        }\n    };\n\n    const parsePastedHtml = (html) => {\n        const div = document.createElement('div');\n        div.innerHTML = html.trim();\n        let pasteLocX = -1;\n        let pasteLocY = -1;\n        if (selection.x1 !== -1 && selection.x2 === -1) {\n            pasteLocX = selection.x1;\n        }\n        if (selection.y1 !== -1 && selection.y2 === -1) {\n            pasteLocY = selection.y1;\n        }\n        if (selection.x1 !== -1 && selection.x2 !== -1) {\n            pasteLocX = Math.min(selection.x1, selection.x2);\n        }\n        if (selection.y1 !== -1 && selection.y2 !== -1) {\n            pasteLocY = Math.min(selection.y1, selection.y2);\n        }\n        if (pasteLocX === -1 || pasteLocY === -1) {\n            return;\n        }\n\n        let x = pasteLocX;\n        let y = pasteLocY;\n        const changes = [];\n\n        const tableNode = findTable(div);\n        if (!tableNode) {\n            return;\n        }\n\n        for (const tableChild of tableNode.children) {\n            if (tableChild.nodeName === 'TBODY') {\n                for (const tr of tableChild.children) {\n                    x = pasteLocX;\n                    if (tr.nodeName === 'TR') {\n                        for (const td of tr.children) {\n                            if (td.nodeName === 'TD') {\n                                changes.push({ y: y, x: x, value: td.innerHTML });\n                                x++;\n                            }\n                        }\n                        y++;\n                    }\n                }\n            }\n        }\n\n        if (props.onChange) {\n            props.onChange(changes);\n        }\n        let pasteX2 = x - 1;\n        let pasteY2 = y - 1;\n        changeSelection(pasteLocX, pasteLocY, pasteX2, pasteY2, false);\n    };\n\n    const parsePastedText = (text) => {\n        let pasteLocX = -1;\n        let pasteLocY = -1;\n        if (selection.x1 !== -1 && selection.x2 === -1) {\n            pasteLocX = selection.x1;\n        }\n        if (selection.y1 !== -1 && selection.y2 === -1) {\n            pasteLocY = selection.y1;\n        }\n        if (selection.x1 !== -1 && selection.x2 !== -1) {\n            pasteLocX = Math.min(selection.x1, selection.x2);\n        }\n        if (selection.y1 !== -1 && selection.y2 !== -1) {\n            pasteLocY = Math.min(selection.y1, selection.y2);\n        }\n        if (pasteLocX === -1 || pasteLocY === -1) {\n            return;\n        }\n\n        const rows = text.split(/\\r?\\n/);\n        let pasteX2 = pasteLocX;\n        let pasteY2 = pasteLocY + rows.length - 1;\n        const changes = [];\n        for (let y = 0; y < rows.length; y++) {\n            const cols = rows[y].split('\\t');\n\n            if (pasteLocX + cols.length - 1 > pasteX2) {\n                pasteX2 = pasteLocX + cols.length - 1;\n            }\n            for (let x = 0; x < cols.length; x++) {\n                changes.push({ y: pasteLocY + y, x: pasteLocX + x, value: cols[x] });\n            }\n        }\n\n        if (props.onChange) {\n            props.onChange(changes);\n        }\n        changeSelection(pasteLocX, pasteLocY, pasteX2, pasteY2, false);\n    };\n\n    const setCopyPasteText = () => {\n        if (selection.x1 === -1 || selection.y1 === -1 || selection.x2 === -1 || selection.y2 === -1) {\n            return;\n        }\n\n        let dy1 = selection.y1;\n        let dy2 = selection.y2;\n        if (dy1 > dy2) {\n            dy1 = selection.y2;\n            dy2 = selection.y1;\n        }\n\n        let dx1 = selection.x1;\n        let dx2 = selection.x2;\n        if (dx1 > dx2) {\n            dx1 = selection.x2;\n            dx2 = selection.x1;\n        }\n\n        const rows = [];\n        for (let y = dy1; y <= dy2; y++) {\n            const row = [];\n            for (let x = dx1; x <= dx2; x++) {\n                const value = editData(x, y);\n                if (value !== null && value !== undefined) {\n                    row.push(value);\n                } else {\n                    row.push('');\n                }\n            }\n            rows.push(row.join('\\t'));\n        }\n        const cptext = rows.join('\\n');\n        if (copyPasteTextAreaRef.current) {\n            copyPasteTextAreaRef.current.value = cptext;\n        }\n    };\n\n    const commitEditingCell = () => {\n        if (props.onChange) {\n            props.onChange([{ x: editCell.x, y: editCell.y, value: editValue }]);\n        }\n\n        setEditCell({ x: -1, y: -1 });\n    };\n\n    const startEditingCell = (editCell) => {\n        if (cellReadOnly(editCell.x, editCell.y)) {\n            return;\n        }\n\n        const editDataValue = editData(editCell.x, editCell.y);\n        let val = '';\n        if (editDataValue !== null && editDataValue !== undefined) {\n            val = editDataValue;\n        }\n        setEditCell(editCell);\n        setEditValue(val);\n    };\n\n    const onScroll = (e) => {\n        const absX = e.target.scrollLeft;\n        const absY = e.target.scrollTop;\n\n        const cellX = Math.floor(absX / scrollSpeed);\n        const cellY = Math.floor(absY / scrollSpeed);\n        if (cellX !== dataOffset.x || cellY !== dataOffset.y) {\n            setDataOffset({ x: cellX, y: cellY });\n        }\n\n        let newMaxScroll = { ...maxScroll };\n        if (maxScroll.x / (absX + 0.5) < 1) {\n            newMaxScroll.x *= 1.5;\n        }\n        if (maxScroll.y / (absY + 0.5) < 1) {\n            newMaxScroll.y *= 1.5;\n        }\n        if (newMaxScroll.x !== maxScroll.x || maxScroll.y !== newMaxScroll.y) {\n            setMaxScroll({ ...newMaxScroll });\n        }\n    };\n\n    const onMouseLeave = (e) => {\n        window.document.body.style.cursor = 'auto';\n    };\n\n    const onMouseDown = (e) => {\n        if (e.button !== 0) {\n            return;\n        }\n        const rect = e.target.getBoundingClientRect();\n        const x = e.clientX - rect.left;\n        const y = e.clientY - rect.top;\n\n        if (x > canvasWidth || y > canvasHeight) {\n            return;\n        }\n\n        const hitTargetKeyX = Math.floor(x / xBinSize);\n        const hitTargetKeyY = Math.floor(y / yBinSize);\n\n        if (hitMap[hitTargetKeyX] && hitMap[hitTargetKeyX][hitTargetKeyY]) {\n            for (const hitTarget of hitMap[hitTargetKeyX][hitTargetKeyY]) {\n                if (\n                    hitTarget.x <= x &&\n                    x <= hitTarget.x + hitTarget.w &&\n                    hitTarget.y <= y &&\n                    y <= hitTarget.y + hitTarget.h\n                ) {\n                    setButtonClickMouseDownCoordinates({ x, y, hitTarget });\n                    return;\n                }\n            }\n        }\n\n        if (y < columnHeaderHeight) {\n            let xx = rowHeaderWidth;\n            for (const col of visibleColumns) {\n                if (Math.abs(xx - x) < resizeColumnRowMouseThreshold) {\n                    window.document.body.style.cursor = 'col-resize';\n                    setColumnResize({\n                        startX: xx,\n                        oldWidth: cellWidth(col - 1),\n                        colIdx: col - 1,\n                    });\n                    return;\n                }\n                xx += cellWidth(col);\n            }\n        }\n        if (x < rowHeaderWidth) {\n            let yy = columnHeaderHeight;\n            for (const row of visibleRows) {\n                if (Math.abs(yy - y) < resizeColumnRowMouseThreshold) {\n                    window.document.body.style.cursor = 'row-resize';\n                    setRowResize({\n                        startY: yy,\n                        oldHeight: cellHeight(row - 1),\n                        rowIdx: row - 1,\n                    });\n                    return;\n                }\n                yy += cellHeight(row);\n            }\n        }\n\n        // knob drag mode\n        if (Math.abs(x - knobCoordinates.x) < knobSize && Math.abs(y - knobCoordinates.y) < knobSize) {\n            setKnobDragInProgress(true);\n            setKnobArea({ x1: selection.x1, y1: selection.y1, x2: selection.x2, y2: selection.y2 });\n            return;\n        }\n\n        const sel2 = absCoordianteToCell(x, y);\n        const sel1 = shiftKeyDown ? { x: selection.x1, y: selection.y1 } : { ...sel2 };\n\n        if (editMode) {\n            commitEditingCell();\n        }\n\n        let scrollToP2 = true;\n\n        if (x < rowHeaderWidth) {\n            sel2.x = 100;\n            scrollToP2 = false;\n            setRowSelectionInProgress(true);\n        } else {\n            setRowSelectionInProgress(false);\n        }\n\n        if (y < columnHeaderHeight) {\n            sel2.y = 100;\n            scrollToP2 = false;\n            setColumnSelectionInProgress(true);\n        } else {\n            setColumnSelectionInProgress(false);\n        }\n\n        setSelectionInProgress(true);\n        changeSelection(sel1.x, sel1.y, sel2.x, sel2.y, scrollToP2);\n        setEditCell({ x: -1, y: -1 });\n    };\n\n    const onMouseUp = (e) => {\n        if (knobDragInProgress) {\n            let sx1 = selection.x1;\n            let sx2 = selection.x2;\n            if (selection.x1 > selection.x2) {\n                sx1 = selection.x2;\n                sx2 = selection.x1;\n            }\n            let sy1 = selection.y1;\n            let sy2 = selection.y2;\n            if (selection.y1 > selection.y2) {\n                sy1 = selection.y2;\n                sy2 = selection.y1;\n            }\n            let kx1 = knobArea.x1;\n            let kx2 = knobArea.x2;\n            if (knobArea.x1 > knobArea.x2) {\n                kx1 = knobArea.x2;\n                kx2 = knobArea.x1;\n            }\n            let ky1 = knobArea.y1;\n            let ky2 = knobArea.y2;\n            if (knobArea.y1 > knobArea.y2) {\n                ky1 = knobArea.y2;\n                ky2 = knobArea.y1;\n            }\n\n            let fx1 = kx1;\n            let fy1 = ky1;\n            let fx2 = kx2;\n            let fy2 = ky2;\n\n            const changes = [];\n\n            if (fx2 - fx1 === sx2 - sx1) {\n                // vertical\n                if (fy1 === sy1) {\n                    fy1 = sy2 + 1;\n                } else {\n                    fy2 = sy1 - 1;\n                }\n\n                let srcY = sy1;\n                for (let y = fy1; y <= fy2; y++) {\n                    for (let x = fx1; x <= fx2; x++) {\n                        const value = sourceData(x, srcY);\n                        changes.push({ x: x, y: y, value: value });\n                    }\n                    srcY = srcY + 1;\n                    if (srcY > sy2) {\n                        srcY = sy1;\n                    }\n                }\n            } else {\n                // horizontal\n                if (fx1 === sx1) {\n                    fx1 = sx2 + 1;\n                } else {\n                    fx2 = sx1 - 1;\n                }\n                let srcX = sx1;\n                for (let x = fx1; x <= fx2; x++) {\n                    for (let y = fy1; y <= fy2; y++) {\n                        const value = sourceData(srcX, y);\n                        changes.push({ x: x, y: y, value: value });\n                    }\n                    srcX = srcX + 1;\n                    if (srcX > sx2) {\n                        srcX = sx1;\n                    }\n                }\n            }\n\n            if (props.onChange) {\n                props.onChange(changes);\n            }\n\n            changeSelection(knobArea.x1, knobArea.y1, knobArea.x2, knobArea.y2);\n        }\n        setSelectionInProgress(false);\n        setRowSelectionInProgress(false);\n        setColumnSelectionInProgress(false);\n        setKnobDragInProgress(false);\n        setColumnResize(null);\n        setRowResize(null);\n\n        if (\n            buttonClickMouseDownCoordinates.x !== -1 &&\n            buttonClickMouseDownCoordinates.y !== -1 &&\n            buttonClickMouseDownCoordinates.hitTarget !== null\n        ) {\n            const rect = e.target.getBoundingClientRect();\n            const x = e.clientX - rect.left;\n            const y = e.clientY - rect.top;\n            const hitTarget = buttonClickMouseDownCoordinates.hitTarget;\n            if (\n                hitTarget.x <= x &&\n                x <= hitTarget.x + hitTarget.w &&\n                hitTarget.y <= y &&\n                y <= hitTarget.y + hitTarget.h\n            ) {\n                hitTarget.onClick();\n            }\n            setButtonClickMouseDownCoordinates({ x: -1, y: -1, hitTarget: null });\n        }\n    };\n\n    useEffect(() => {\n        window.addEventListener('mouseup', onMouseUp);\n        return () => {\n            window.removeEventListener('mouseup', onMouseUp);\n        };\n    });\n\n    const onMouseMove = (e) => {\n        const rect = e.target.getBoundingClientRect();\n        const x = e.clientX - rect.left;\n        const y = e.clientY - rect.top;\n\n        window.document.body.style.cursor = 'auto';\n\n        const hitTargetKeyX = Math.floor(x / xBinSize);\n        const hitTargetKeyY = Math.floor(y / yBinSize);\n\n        if (hitMap[hitTargetKeyX] && hitMap[hitTargetKeyX][hitTargetKeyY]) {\n            for (const hitTarget of hitMap[hitTargetKeyX][hitTargetKeyY]) {\n                if (\n                    hitTarget.x <= x &&\n                    x <= hitTarget.x + hitTarget.w &&\n                    hitTarget.y <= y &&\n                    y <= hitTarget.y + hitTarget.h\n                ) {\n                    window.document.body.style.cursor = 'pointer';\n                }\n            }\n        }\n\n        if (props.onCellWidthChange && y < columnHeaderHeight) {\n            let xx = rowHeaderWidth;\n            for (const col of visibleColumns) {\n                if (Math.abs(xx - x) < resizeColumnRowMouseThreshold) {\n                    window.document.body.style.cursor = 'col-resize';\n                    break;\n                }\n                xx += cellWidth(col);\n            }\n        }\n\n        if (props.onCellHeightChange && x < rowHeaderWidth) {\n            let yy = columnHeaderHeight;\n            for (const row of visibleRows) {\n                if (Math.abs(yy - y) < resizeColumnRowMouseThreshold) {\n                    window.document.body.style.cursor = 'row-resize';\n                    break;\n                }\n                yy += cellHeight(row);\n            }\n        }\n\n        if (Math.abs(x - knobCoordinates.x) < knobSize && Math.abs(y - knobCoordinates.y) < knobSize) {\n            window.document.body.style.cursor = 'crosshair';\n        }\n\n        if (columnResize) {\n            if (props.onCellWidthChange) {\n                const newWidth = Math.max(columnResize.oldWidth + x - columnResize.startX, minimumColumnWidth);\n                props.onCellWidthChange(columnResize.colIdx, newWidth);\n            }\n            return;\n        }\n\n        if (rowResize) {\n            if (props.onCellHeightChange) {\n                const newHeight = Math.max(rowResize.oldHeight + y - rowResize.startY, minimumRowHeight);\n                props.onCellHeightChange(rowResize.rowIdx, newHeight);\n            }\n            return;\n        }\n\n        if (selectionInProgress) {\n            const sel2 = absCoordianteToCell(x, y);\n            if (rowSelectionInProgress) {\n                changeSelection(selection.x1, selection.y1, selection.x2, sel2.y, false);\n            } else if (columnSelectionInProgress) {\n                changeSelection(selection.x1, selection.y1, sel2.x, selection.y2, false);\n            } else {\n                changeSelection(selection.x1, selection.y1, sel2.x, sel2.y);\n            }\n        }\n\n        if (knobDragInProgress) {\n            window.document.body.style.cursor = 'crosshair';\n            const cell = absCoordianteToCell(x, y);\n\n            let x1 = selection.x1;\n            let y1 = selection.y1;\n            let x2 = selection.x2;\n            let y2 = selection.y2;\n            if (x1 > x2) {\n                x1 = selection.x2;\n                x2 = selection.x1;\n            }\n            if (y1 > y2) {\n                y1 = selection.y2;\n                y2 = selection.y1;\n            }\n\n            // check if vertical or horizontal\n            if (Math.abs(cell.x - (x1 + x2) * 0.5) < Math.abs(cell.y - (y1 + y2) * 0.5)) {\n                if (cell.y < y1) {\n                    y1 = cell.y;\n                } else {\n                    y2 = cell.y;\n                }\n            } else {\n                if (cell.x < x1) {\n                    x1 = cell.x;\n                } else {\n                    x2 = cell.x;\n                }\n            }\n            setKnobArea({ x1: x1, y1: y1, x2: x2, y2: y2 });\n        }\n    };\n\n    const onDoubleClick = (e) => {\n        const rect = e.target.getBoundingClientRect();\n        const x = e.clientX - rect.left;\n        const y = e.clientY - rect.top;\n        const editCell = absCoordianteToCell(x, y);\n        setArrowKeyCommitMode(false);\n        startEditingCell(editCell);\n    };\n\n    const onKeyDown = (e) => {\n        if (e.key === 'Escape') {\n            setEditCell({ x: -1, y: -1 });\n            return;\n        }\n        if (e.key === 'Enter') {\n            commitEditingCell();\n            changeSelection(selection.x1, selection.y1 + 1, selection.x1, selection.y1 + 1);\n        }\n        if (e.key === 'Tab') {\n            e.preventDefault();\n            commitEditingCell();\n            changeSelection(selection.x1 + 1, selection.y1, selection.x1 + 1, selection.y1);\n        }\n        if (arrowKeyCommitMode && ['ArrowRight', 'ArrowLeft', 'ArrowUp', 'ArrowDown'].includes(e.key)) {\n            e.preventDefault();\n            commitEditingCell();\n            let x1 = selection.x1;\n            let y1 = selection.y1;\n            let x2 = selection.x1;\n            let y2 = selection.y1;\n            if (e.key === 'ArrowRight') {\n                x1 = selection.x1 + 1;\n                x2 = selection.x1 + 1;\n            } else if (e.key === 'ArrowLeft') {\n                x1 = selection.x1 - 1;\n                x2 = selection.x1 - 1;\n            } else if (e.key === 'ArrowUp') {\n                y1 = selection.y1 - 1;\n                y2 = selection.y1 - 1;\n            } else if (e.key === 'ArrowDown') {\n                y1 = selection.y1 + 1;\n                y2 = selection.y1 + 1;\n            }\n            changeSelection(x1, y1, x2, y2);\n        }\n    };\n\n    const onGridKeyDown = (e) => {\n        if (editMode && arrowKeyCommitMode && ['ArrowRight', 'ArrowLeft', 'ArrowUp', 'ArrowDown'].includes(e.key)) {\n            commitEditingCell();\n            return;\n        }\n\n        if (e.key === 'Shift') {\n            setShiftKeyDown(true);\n            return;\n        }\n\n        if ((e.metaKey || e.ctrlKey) && String.fromCharCode(e.which).toLowerCase() === 'v') {\n            return;\n        }\n\n        // copy\n        if ((e.metaKey || e.ctrlKey) && String.fromCharCode(e.which).toLowerCase() === 'c') {\n            return;\n        }\n\n        if (e.key === 'Backspace' || e.key === 'Delete') {\n            let x1 = selection.x1;\n            let y1 = selection.y1;\n            let x2 = selection.x2;\n            let y2 = selection.y2;\n            if (x1 > x2) {\n                x1 = selection.x2;\n                x2 = selection.x1;\n            }\n            if (y1 > y2) {\n                y1 = selection.y2;\n                y2 = selection.y1;\n            }\n            const changes = [];\n            for (let y = y1; y <= y2; y++) {\n                for (let x = x1; x <= x2; x++) {\n                    changes.push({ x: x, y: y, value: null });\n                }\n            }\n            if (props.onChange) {\n                props.onChange(changes);\n            }\n            return;\n        }\n\n        // nothing selected\n        if (selection.x1 === -1 || selection.x2 === -1 || selection.y1 === -1 || selection.y2 === -1) {\n            return;\n        }\n\n        if (\n            (e.keyCode >= 48 && e.keyCode <= 57) ||\n            (e.keyCode >= 96 && e.keyCode <= 105) ||\n            (e.keyCode >= 65 && e.keyCode <= 90) ||\n            e.key === 'Enter' ||\n            e.key === '-' ||\n            e.key === '.' ||\n            e.key === ','\n        ) {\n            if (cellReadOnly(selection.x1, selection.y1)) {\n                e.preventDefault(); // so we dont get keystrokes inside the text area\n                return;\n            }\n\n            startEditingCell({ x: selection.x1, y: selection.y1 });\n            setArrowKeyCommitMode(e.key !== 'Enter');\n            return;\n        }\n\n        if (['ArrowRight', 'ArrowLeft', 'ArrowUp', 'ArrowDown'].includes(e.key)) {\n            let sel1 = { x: selection.x1, y: selection.y1 };\n            let sel2 = { x: selection.x2, y: selection.y2 };\n\n            if (e.key === 'ArrowRight' || e.key === 'Tab') {\n                sel2.x += 1;\n            } else if (e.key === 'ArrowLeft') {\n                sel2.x -= 1;\n            } else if (e.key === 'ArrowUp') {\n                sel2.y -= 1;\n            } else if (e.key === 'ArrowDown') {\n                sel2.y += 1;\n            }\n            if (sel2.x < 0) {\n                sel2.x = 0;\n            }\n            if (sel2.y < 0) {\n                sel2.y = 0;\n            }\n            if (!e.shiftKey) {\n                sel1 = { ...sel2 };\n            }\n            changeSelection(sel1.x, sel1.y, sel2.x, sel2.y);\n            return;\n        }\n        e.preventDefault();\n    };\n\n    const onGridKeyUp = (e) => {\n        setShiftKeyDown(e.shiftKey);\n    };\n\n    const onContextMenu = (e) => {\n        if (!props.onRightClick) {\n            return;\n        }\n        const rect = e.target.getBoundingClientRect();\n        const x = e.clientX - rect.left;\n        const y = e.clientY - rect.top;\n        const cell = absCoordianteToCell(x, y);\n        e.cellX = cell.x;\n        e.cellY = cell.y;\n\n        if (y > columnHeaderHeight && x > rowHeaderWidth) {\n            onMouseMove(e);\n            props.onRightClick(e);\n        }\n    };\n\n    const editMode = editCell.x !== -1 && editCell.y !== -1;\n    let editTextPosition = { x: 0, y: 0 };\n    let editTextWidth = 0;\n    let editTextHeight = 0;\n    let editTextTextAlign = 'right';\n    if (editMode) {\n        editTextPosition = cellToAbsCoordinate(editCell.x, editCell.y);\n        const style = cellStyle(editCell.x, editCell.y);\n        // add 1 so it doesnt cover the selection border\n        editTextPosition.x += 1;\n        editTextPosition.y += 1;\n        editTextWidth = cellWidth(editCell.x) - 2;\n        editTextHeight = cellHeight(editCell.y) - 2;\n        editTextTextAlign = style.textAlign || defaultCellStyle.textAlign;\n    }\n\n    return (\n        <div style={{ position: 'relative', height: '100%' }}>\n            <canvas\n                style={{\n                    width: 'calc(100% - 14px)',\n                    height: 'calc(100% - 15px)',\n                    outline: '1px solid #ddd', // find another better solution ?\n                }}\n                ref={canvasRef}\n            />\n            <div\n                ref={overlayRef}\n                onDoubleClick={onDoubleClick}\n                onMouseDown={onMouseDown}\n                onMouseMove={onMouseMove}\n                onMouseLeave={onMouseLeave}\n                onContextMenu={onContextMenu}\n                onScroll={onScroll}\n                className={styles.sheetscroll}\n                style={{\n                    position: 'absolute',\n                    width: '100%',\n                    height: '100%',\n                    top: 0,\n                    left: 0,\n                    overflow: 'scroll',\n                    borderBottom: '1px solid #ddd',\n                }}\n            >\n                <div\n                    style={{\n                        position: 'absolute',\n                        left: 0,\n                        top: 0,\n                        width: 1,\n                        height: maxScroll.y + 2000,\n                        backgroundColor: 'rgba(0,0,0,0.0)',\n                    }}\n                ></div>\n                <div\n                    style={{\n                        position: 'absolute',\n                        left: 0,\n                        top: 0,\n                        width: maxScroll.x + 5000,\n                        height: 1,\n                        backgroundColor: 'rgba(0,0,0,0.0)',\n                    }}\n                ></div>\n            </div>\n            <textarea\n                style={{ position: 'absolute', top: 0, left: 0, width: 1, height: 1, opacity: 0.01 }}\n                ref={copyPasteTextAreaRef}\n                onFocus={(e) => e.target.select()}\n                autoFocus\n                tabIndex=\"0\"\n                onKeyDown={onGridKeyDown}\n                onKeyUp={onGridKeyUp}\n            ></textarea>\n\n            {editMode && (\n                <input\n                    type=\"text\"\n                    onFocus={(e) => e.target.select()}\n                    autoFocus\n                    onKeyDown={onKeyDown}\n                    value={editValue}\n                    onChange={(e) => setEditValue(e.target.value)}\n                    style={{\n                        position: 'absolute',\n                        top: editTextPosition.y,\n                        left: editTextPosition.x,\n                        width: editTextWidth,\n                        height: editTextHeight,\n                        outline: 'none',\n                        border: 'none',\n                        textAlign: editTextTextAlign,\n                        color: 'black',\n                        fontSize: defaultCellStyle.fontSize,\n                        fontFamily: 'sans-serif',\n                    }}\n                />\n            )}\n        </div>\n    );\n}\n\nexport default Sheet;\n","import React from 'react'\n\nimport Sheet from 'sheet-happens'\nimport 'sheet-happens/dist/index.css'\n\nconst App = () => {\n  return <Sheet />\n}\n\nexport default App\n","import './index.css'\n\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\n\nReactDOM.render(<App />, document.getElementById('root'))\n"],"sourceRoot":""}