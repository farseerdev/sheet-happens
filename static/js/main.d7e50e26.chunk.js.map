{"version":3,"sources":["assets/logo.svg","assets/git.svg","components/Menu.js","../../src/constants.ts","../../src/util.ts","../../src/coordinate.ts","../../src/props.ts","../../src/mouse.ts","../../src/clipboard.ts","../../src/layout.ts","../../src/style.ts","../../src/render.ts","../../src/sheet.tsx","../../src/scroll.ts","components/SheetBox.js","components/Header.js","components/TitleSeparator.js","components/Wrap.js","components/Code.js","components/Footer.js","App.js","index.js"],"names":["module","exports","Menu","scrollTo","elId","element","document","getElementById","headerOffset","offsetPosition","window","pageYOffset","getBoundingClientRect","top","behavior","className","src","Logo","alt","onClick","INITIAL_MAX_SCROLL","ORIGIN","ONE_ONE","NO_CELL","NO_SELECTION","NO_SELECTIONS","NO_CLICKABLES","NO_STYLE","MAX_XY","COLORS","SIZES","DEFAULT_CELL_STYLE","textAlign","fontSize","marginRight","marginLeft","color","fontFamily","weight","fillColor","backgroundColor","DEFAULT_COLUMN_HEADER_STYLE","HEADER_ACTIVE_STYLE","HEADER_SELECTED_STYLE","ARROW_KEYS","clamp","x","Math","isInRange","min","isInRangeLeft","isInRangeRight","isInRangeCenter","addXY","a","b","subXY","maxXY","getDirectionStep","direction","isSameXY","isMaybeRowSelection","selection","left","right","isMaybeColumnSelection","bottom","isRowSelection","isColumnSelection","isEmptySelection","isPointInsideSelection","normalizeSelection","point","y","createRowOrColumnProp","Array","rowOrColIndex","rowColProp","createCellProp","cellProp","findApproxMaxEditDataIndex","editData","howManyEmpty","growthIncrement","growthIncrementFactor","allEmpty","yy","data","xx","findInDisplayData","p","step","cell","max","Infinity","start","first","displayData","firstFilled","cellX","cellY","parseKnobOperation","knobArea","kx1","ky1","kx2","ky2","sx1","sy1","sx2","sy2","fx1","fy1","fx2","fy2","changes","srcY","value","sourceData","source","srcX","formatSelectionAsTSV","minX","minY","maxX","maxY","rows","row","formatTSV","parsePastedHtml","div","html","tableNode","findTable","child","maybeTable","tableChild","tr","td","str","parsePastedText","text","cols","makeCellLayout","freezeX","freeze","freezeY","indentX","indent","indentY","offsetX","offset","offsetY","getBaseOriginFor","index","columnToPixel","column","anchor","base","relative","columns","size","rowToPixel","columnToAbsolute","anchorX","rowToAbsolute","anchorY","pixelToIndex","pixel","getStart","layout","lookupIndex","pixelToColumn","pixelX","pixelToRow","pixelY","absoluteToIndex","absoluteToColumn","absoluteToRow","getVisibleIndices","view","n","indices","s","d","length","i","cellToPixel","cellToAbsolute","pixelToCell","absoluteToCell","getVisibleCells","viewX","viewY","getIndentX","getIndentY","getVersion","makeLayoutCache","offsets","makeIntMap","sizes","version","getSize","sizer","getOffset","j","getEnd","last","end","mid","setSizer","clearAfter","initialSize","allocate","newUsed","Uint8Array","newValues","Uint32Array","copy","used","values","from","to","truncate","l","set","grow","ensure","get","has","tail","applyAlignment","alignment","style","cellSize","imageWidth","renderCell","clickables","cellContent","finalStyle","context","yCoord","cellHeight","xCoord","cellWidth","obj","w","h","finalX","measure","rect","resolveSelection","cellLayout","rowSelectionActive","columnSelectionActive","resolveFrozenSelection","frozenX","frozenY","hideKnob","edge","resizeCanvas","canvas","width","height","devicePixelRatio","ratio","newCanvasWidth","newCanvasHeight","excelHeaderString","num","t","String","forwardRef","canvasRef","useRef","overlayRef","useState","maxScroll","setMaxScroll","dataOffset","setDataOffset","setSelection","setKnobArea","dragOffset","setDragOffset","dropTarget","setDropTarget","editCell","setEditCell","editValue","setEditValue","arrowKeyCommitMode","setArrowKeyCommitMode","useResizeObserver","ref","canvasWidth","canvasHeight","useMemo","props","columnHeaders","columnHeaderStyle","canSizeColumn","canSizeRow","canOrderColumn","canOrderRow","cellReadOnly","editKeys","cellStyle","sheetStyle","freezeColumns","freezeRows","hideColumnHeaders","hideRowHeaders","hideGridlines","hideScrollBars","columnHeaderHeight","rowHeaderWidth","resolveSheetStyle","secondarySelections","maxScrollX","maxScrollY","editCellX","editCellY","editMode","columnLayout","rowLayout","useImperativeHandle","visibleCells","useLayoutEffect","changeSelection","newSelection","scrollToAnchor","a1","a2","b1","b2","isSameSelection","overlay","current","newX","newY","newOffset","scroll","callback","setTimeout","scrollX","scrollY","scrollToCell","commitEditingCell","startEditingCell","editDataValue","val","hitmapRef","textAreaRef","textArea","activeTagName","preventScroll","useClipboardCopy","useEffect","onPaste","e","clipboardData","types","pastedHtml","parsed","onChange","onSelectionChange","useClipboardPaste","onScroll","useCallback","xy","onOffsetChange","growX","growY","onMaxScrollChange","useScroll","hitTarget","setHitTarget","columnResize","setColumnResize","rowResize","setRowResize","columnDrag","setColumnDrag","rowDrag","setRowDrag","draggingKnob","setDraggingKnob","draggingSelection","setDraggingSelection","draggingRowSelection","setDraggingRowSelection","draggingColumnSelection","setDraggingColumnSelection","knobPosition","isCellSelection","refState","getMousePosition","getScrollPosition","target","scrollLeft","scrollTop","getMouseHit","hitmap","object","onPointerLeave","onPointerDown","selectedColumns","selectedRows","onDragOffsetChange","asGroup","knobX","knobY","onKnobAreaChange","head","onCommit","scrollToHead","onPointerUp","onDropTargetChange","order","onColumnOrderChange","onInvalidateColumn","onRowOrderChange","onInvalidateRow","onPointerMove","currentScroll","newWidth","onCellWidthChange","newHeight","onCellHeightChange","headX","headY","xCellDiff","yCellDiff","insideSelection","shift","onDoubleClick","onEdit","onContextMenu","event","onRightClick","mouseHandlers","useMouse","animationFrameId","selectionActive","selected","gridRight","gridBottom","drawGridLineX","drawGridLineY","content","isActive","selectedStyle","activeStyle","secondarySelection","shiftX","shiftY","renderSheet","editKey","lastEditKey","setLastEditKey","editTextPosition","editTextWidth","editTextHeight","editTextTextAlign","textX","textY","inputProps","autoFocus","onKeyDown","position","padding","outline","border","input","overlayDivClassName","styles","overlayDivStyles","overflow","borderBottom","canvasStyles","opacity","autoComplete","autoCorrect","autoCapitalize","spellCheck","onFocus","tabIndex","x1","y1","x2","y2","type","initialDataBig","r","col","push","initialDataBasic","initialDataFormatting","random","triangleDown","Image","useWidthHeightControl","initialWidths","initialHeights","getColumnOrder","getRowOrder","setCellWidth","setCellHeight","cw","idx","ch","useOrderControl","initialColumns","initialRows","columnOrder","setColumnOrder","rowOrder","setRowOrder","co","reduce","splice","map","ro","SheetBoxHeader","setData","onSelectionChanged","newData","change","cx","cy","readOnly","cacheLayout","SheetBoxBasic","JSON","parse","stringify","faCheck","SheetBoxStyle","colors","items","horizontalAlign","console","log","undefined","incrementCell","SheetBoxFormatting","toFixed","Number","SheetBoxVeryBigData","loadingStatus","setLoadingStatus","href","preventDefault","fetch","then","response","json","dataset","toString","padStart","g","customInputOptions","customInputOptions2","customInputData","SheetBoxCustomInput","inputComponent","CustomInput","boxShadow","opt","CustomOption","key","clickHandler","hover","setHover","onMouseEnter","onMouseLeave","cursor","SheetBoxSourceDisplayData","Header","copySuccess","setCopySuccess","id","select","execCommand","focus","rel","GitIcon","TitleSeparator","title","Wrap","children","xcode","hljs","background","maxWidth","borderRadius","SourceDisplayDataCode","xcode2","language","InitSheetCode","InitSheetWithDataCode","EditDataCode","CellStyleSizeCode","Footer","Emphased","App","overflowX","ReactDOM","render"],"mappings":"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","file":"static/js/main.d7e50e26.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/logo.aef13910.svg\";","module.exports = __webpack_public_path__ + \"static/media/git.f818b886.svg\";","import React from 'react';\nimport Logo from '../assets/logo.svg';\n\nfunction Menu() {\n    const scrollTo = (elId) => {\n        var element = document.getElementById(elId);\n        var headerOffset = elId === 'home' ? 0 : 86;\n        var elementPosition = window.pageYOffset + element.getBoundingClientRect().top;\n        var offsetPosition = elementPosition - headerOffset;\n\n        window.scrollTo({\n             top: offsetPosition,\n             behavior: \"smooth\"\n        });\n    }\n\n    return (\n        <div className=\"container blue-bg menu\">\n            <div className=\"content flex-row\">\n                <div className=\"logo-box\">\n                    <img src={Logo} alt=\"Logo\" />\n                    <h2 className=\"page-title\">sheet - happens</h2>\n                </div>\n                <div className=\"nav\">\n                    <div className=\"nav-item\" onClick={() => scrollTo('home')} >home</div>\n                    <div className=\"nav-item\" onClick={() => scrollTo('usage')} >usage</div>\n                    <div className=\"nav-item\" onClick={() => scrollTo('features')} >features</div>\n                    <div className=\"nav-item\" onClick={() => scrollTo('documentation')} >documentation</div>\n                </div>\n            </div>\n        </div>\n    );\n}\n\nexport default Menu;\n","import { XY, Rectangle, Selection, Clickable, Direction, Style } from './types';\n\nexport const INITIAL_MAX_SCROLL: XY = [ 2000, 1000 ];\n\nexport const ORIGIN: XY = [ 0, 0 ];\nexport const ONE_ONE: XY = [ 1, 1 ];\n\nexport const NO_CELL: XY = [ -1, -1 ];\nexport const NO_SELECTION: Rectangle = [NO_CELL, NO_CELL];\nexport const NO_SELECTIONS: Selection[] = [];\nexport const NO_CLICKABLES: Clickable[] = [];\nexport const NO_STYLE = {};\n\nexport const MAX_SEARCHABLE_INDEX = 65536;\nexport const MAX_XY: XY = [ MAX_SEARCHABLE_INDEX, MAX_SEARCHABLE_INDEX ];\n\nexport const COLORS = {\n    selectionBorder: '#1a66ff',\n    selectionBackground: '#e8f0ff',\n\n    gridLine: '#0000001f',\n\n    dragGhost: '#1a66ff30',\n    dropTarget: '#1a66ff',\n    knobAreaBorder: '#707070',\n\n    headerBackground: '#f6f9fc',\n    headerText: '#666666',\n    headerActive: '#e8f0ff',\n    headerActiveText: '#1a66ff',\n\n    headerSelected: '#1a66ff',\n    headerSelectedText: '#ffffff',\n};\n\nexport const SIZES = {\n    knobArea: 6,\n    headerWidth: 50,\n    headerHeight: 22,\n    minimumWidth: 50,\n    minimumHeight: 22,\n    resizeZone: 4,\n    scrollZone: 50,\n    scrollSpeed: 30,\n};\n\nexport const DEFAULT_CELL_STYLE: Required<Style> = {\n    textAlign: 'left',\n    fontSize: 12,\n    marginRight: 5,\n    marginLeft: 5,\n    color: '#000',\n    fontFamily: 'sans-serif',\n    weight: '',\n    fillColor: '',\n    backgroundColor: '',\n};\n\nexport const DEFAULT_COLUMN_HEADER_STYLE: Required<Style> = {\n    textAlign: 'center',\n    fontSize: 12,\n    marginRight: 5,\n    marginLeft: 5,\n    color: '#000',\n    fontFamily: 'sans-serif',\n    weight: '',\n    fillColor: '',\n    backgroundColor: '',\n};\n\nexport const HEADER_ACTIVE_STYLE = {\n    color: COLORS.headerActiveText,\n};\n\nexport const HEADER_SELECTED_STYLE = {\n    backgroundColor: COLORS.headerSelected,\n    color: COLORS.headerSelectedText,\n};\n\nexport const ARROW_KEYS: Record<string, Direction> = {\n    'ArrowRight': 'right',\n    'ArrowLeft': 'left',\n    'ArrowUp': 'up',\n    'ArrowDown': 'down',\n};\n","export const tail = <T,>(list: T[]): T => list[list.length - 1];\n\nexport const clamp = (x: number, min: number, max: number) => Math.max(Math.min(max, x), min);\n\nexport const seq = (n: number, s: number = 0, d: number = 1): number[] => Array.from({ length: n }).map((_, i: number) => s + d * i);\n\nexport const isInRange = (x: number, min: number, max: number) => min <= x && x <= max;\nexport const isInRangeLeft = (x: number, min: number, max: number) => min <= x && x < max;\nexport const isInRangeRight = (x: number, min: number, max: number) => min < x && x <= max;\nexport const isInRangeCenter = (x: number, min: number, max: number) => min < x && x < max;\n\n","import { XY, Rectangle } from './types';\nimport { clamp } from './util';\n\nexport const addXY = (a: XY, b: XY): XY => [a[0] + b[0], a[1] + b[1]];\nexport const subXY = (a: XY, b: XY): XY => [a[0] - b[0], a[1] - b[1]];\nexport const mulXY = (a: XY, b: XY): XY => [a[0] * b[0], a[1] * b[1]];\nexport const maxXY = (a: XY, b: XY): XY => [Math.max(a[0], b[0]), Math.max(a[1], b[1])];\nexport const minXY = (a: XY, b: XY): XY => [Math.min(a[0], b[0]), Math.min(a[1], b[1])];\nexport const clampXY = (p: XY, min: XY, max: XY = [Infinity, Infinity]): XY => [clamp(p[0], min[0], max[0]), clamp(p[1], min[1], max[1])];\n\nexport const getDirectionStep = (direction: string): XY => {\n    if (direction === 'left') return [-1, 0];\n    if (direction === 'right') return [1, 0];\n    if (direction === 'up') return [0, -1];\n    if (direction === 'down') return [0, 1];\n    return [0, 0];\n};\n\nexport const isSameXY = (a: XY, b: XY) => a[0] === b[0] && a[1] === b[1];\n\nexport const isSameSelection = (a: Rectangle, b: Rectangle) => {\n    const [a1, a2] = a;\n    const [b1, b2] = b;\n    return isSameXY(a1, b1) && isSameXY(a2, b2);\n};\n\n// Selection is infinite horizontally\nexport const isMaybeRowSelection = (selection: Rectangle) => {\n    const [[left], [right]] = selection;\n    return (left === -1 && right === -1);\n};\n\n// Selection is infinite vertically\nexport const isMaybeColumnSelection = (selection: Rectangle) => {\n    const [[, top], [, bottom]] = selection;\n    return (top === -1 && bottom === -1);\n};\n\n// Selection is ONLY infinite horizontally\nexport const isRowSelection = (selection: Rectangle) => {\n    const [[left, top], [right, bottom]] = selection;\n    return (left === -1 && right === -1) && (top !== -1 && bottom !== -1);\n};\n\n// Selection is ONLY infinite vertically\nexport const isColumnSelection = (selection: Rectangle) => {\n    const [[left, top], [right, bottom]] = selection;\n    return (top === -1 && bottom === -1) && (left !== -1 && right !== -1);\n};\n\n// Selection is not infinite\nexport const isCellSelection = (selection: Rectangle) => {\n    const [[left, top], [right, bottom]] = selection;\n    return (left !== -1 && right !== -1) && (top !== -1 && bottom !== -1);\n};\n\n// Selection is null\nexport const isEmptySelection = (selection: Rectangle) => {\n    const [[left, top], [right, bottom]] = selection;\n    return (left === -1 && right === -1) && (top === -1 && bottom === -1);\n};\n\n// Test cell inside selection (inclusive edges)\nexport const isPointInsideSelection = (selection: Rectangle, point: XY) => {\n    const [[left, top], [right, bottom]] = normalizeSelection(selection);\n    const [x, y] = point;\n    return (x >= left && x <= right) && (y >= top && y <= bottom);\n};\n\n// Normalize rectangle to min/max pair\nexport const normalizeSelection = (selection: Rectangle): Rectangle => {\n    let [[left, top], [right, bottom]] = selection;\n    if (left > right) {\n        [left, right] = [right, left];\n    }\n    if (top > bottom) {\n        [top, bottom] = [bottom, top];\n    }\n\n    return [[left, top], [right, bottom]];\n};\n","import { Direction, XY, CellContentType, CellProperty, CellPropertyFunction, PropTypes, RowOrColumnProperty, RowOrColumnPropertyFunction } from './types';\nimport { MAX_SEARCHABLE_INDEX, MAX_XY, ORIGIN } from './constants';\nimport { clampXY, addXY, subXY, maxXY, getDirectionStep } from './coordinate';\n\n// Inject row/column props from an array, function, constant or default value\nexport const createRowOrColumnProp = <T extends PropTypes>(\n    rowColProp: RowOrColumnProperty<T> | undefined,\n    defaultValue: T\n): RowOrColumnPropertyFunction<T> => {\n    if (Array.isArray(rowColProp)) {\n        return (rowOrColIndex: number) => {\n            if (rowOrColIndex >= 0 && rowOrColIndex < rowColProp.length) {\n                return rowColProp[rowOrColIndex];\n            } else {\n                return defaultValue;\n            }\n        };\n    } else if (typeof rowColProp === 'function') {\n        return rowColProp;\n    } else if (rowColProp !== null && rowColProp !== undefined) {\n        return () => rowColProp;\n    } else {\n        return () => defaultValue;\n    }\n}\n\n// Inject cell props from a nested array, function, constant or default value\nexport const createCellProp = <T extends PropTypes>(\n    cellProp: CellProperty<T> | undefined,\n    defaultValue: T\n): CellPropertyFunction<T> => {\n    if (Array.isArray(cellProp)) {\n        return (x: number, y: number) => {\n            if (y >= 0 && y < cellProp.length) {\n                if (x >= 0 && x < cellProp[y].length) {\n                    return cellProp[y][x];\n                } else {\n                    return defaultValue;\n                }\n            } else {\n                return defaultValue;\n            }\n        };\n    } else if (typeof cellProp === 'function') {\n        return cellProp;\n    } else if (cellProp !== null && cellProp !== undefined) {\n        return () => cellProp;\n    } else {\n        return () => defaultValue;\n    }\n}\n\nexport const findApproxMaxEditDataIndex = (editData: CellPropertyFunction<string>): XY => {\n    let x = 0;\n    let y = 0;\n    let howManyEmpty = 0;\n    let growthIncrement = 10;\n    let growthIncrementFactor = 1.5;\n\n    // x\n    while (howManyEmpty < 4) {\n        let allEmpty = true;\n        for (let yy = 0; yy < 10; yy++) {\n            const data = editData(x, yy);\n            if (data !== null && data !== undefined && data !== '') {\n                allEmpty = false;\n                break;\n            }\n        }\n        if (allEmpty) {\n            howManyEmpty += 1;\n        }\n        x += growthIncrement;\n        if (x > MAX_SEARCHABLE_INDEX) {\n            break;\n        }\n        growthIncrement = Math.floor(growthIncrement * growthIncrementFactor);\n    }\n\n    howManyEmpty = 0;\n    growthIncrement = 10;\n    growthIncrementFactor = 1.5;\n\n    // y\n    while (howManyEmpty < 4) {\n        let allEmpty = true;\n        for (let xx = 0; xx < 10; xx++) {\n            const data = editData(xx, y);\n            if (data !== null && data !== undefined && data !== '') {\n                allEmpty = false;\n                break;\n            }\n        }\n        if (allEmpty) {\n            howManyEmpty += 1;\n        }\n        y += growthIncrement;\n        if (y > MAX_SEARCHABLE_INDEX) {\n            break;\n        }\n        growthIncrement = Math.floor(growthIncrement * growthIncrementFactor);\n    }\n    return [x, y];\n}\n\nexport const findInDisplayData = (\n    displayData: CellPropertyFunction<CellContentType>,\n    start: XY,\n    direction: Direction,\n): XY => {\n    const step = getDirectionStep(direction);\n\n    let cell = clampXY(start, ORIGIN, MAX_XY);\n    const first = displayData(...addXY(cell, step));\n    const firstFilled = first !== '' && first !== null && first !== undefined;\n\n    if (!firstFilled) {\n        cell = addXY(cell, step);\n    }\n\n    let [cellX, cellY] = cell;\n    while (cellX <= MAX_SEARCHABLE_INDEX && cellY <= MAX_SEARCHABLE_INDEX && cellX >= 0 && cellY >= 0) {\n        const data = displayData(cellX, cellY);\n\n        // if first cell is filled, find the last filled cell, so first look for first unfilled\n        if (firstFilled && (data === '' || data === null || data === undefined)) {\n            return subXY(cell, step);\n        }\n        // if first cell is not filled, just find the first filled\n        if (!firstFilled && data !== '' && data !== null && data !== undefined) {\n            return cell;\n        }\n\n        [cellX, cellY] = cell = addXY(cell, step);\n    }\n\n    return maxXY(cell, [0, 0]);\n}\n","import { CellLayout, CellPropertyFunction, Change, Clickable, Rectangle, RowOrColumnPropertyFunction, SheetMouseEvent, SheetStyle, VisibleLayout, XY } from './types';\nimport { MouseEvent, PointerEvent, RefObject, useCallback, useMemo, useRef, useState } from 'react';\nimport { normalizeSelection, isColumnSelection, isRowSelection, isCellSelection, isMaybeRowSelection, isPointInsideSelection, addXY, subXY, maxXY } from './coordinate';\nimport { ONE_ONE, ORIGIN, SIZES } from './constants';\nimport { findApproxMaxEditDataIndex } from './props';\nimport { isInRange } from './util';\n\ntype DragOp = {\n    anchor: number,\n    scroll: number,\n    size: number,\n    indices: number[],\n};\n\nexport const useMouse = (\n    hitmapRef: RefObject<Clickable[]>,\n    selection: Rectangle,\n    knobArea: Rectangle | null,\n    editMode: boolean,\n    editData: CellPropertyFunction<string>,\n    sourceData: CellPropertyFunction<string | number | null>,\n\n    canSizeColumn: RowOrColumnPropertyFunction<boolean | null>,\n    canSizeRow: RowOrColumnPropertyFunction<boolean | null>,\n    canOrderColumn: RowOrColumnPropertyFunction<boolean | null>,\n    canOrderRow: RowOrColumnPropertyFunction<boolean | null>,\n\n    cellLayout: CellLayout,\n    visibleCells: VisibleLayout,\n    sheetStyle: SheetStyle,\n\n    onEdit?: (cell: XY) => void,\n    onCommit?: () => void,\n    onKnobAreaChange?: (knobArea: Rectangle | null) => void,\n    onDragOffsetChange?: (dragOffset: XY | null) => void,\n    onDropTargetChange?: (selection: Rectangle | null) => void,\n    onSelectionChange?: (selection: Rectangle, scrollToHead?: boolean) => void,\n\n    onInvalidateColumn?: (column: number) => void,\n    onInvalidateRow?: (row: number) => void,\n\n    onChange?: (changes: Change[]) => void,\n    onColumnOrderChange?: (indices: number[], order: number) => void,\n    onRowOrderChange?: (indices: number[], order: number) => void,\n    onCellWidthChange?: (indices: number[], value: number) => void,\n    onCellHeightChange?: (indices: number[], value: number) => void,\n    onRightClick?: (e: SheetMouseEvent) => void,\n\n    dontCommitEditOnSelectionChange?: boolean,\n) => {\n    const [hitTarget, setHitTarget] = useState<Clickable | null>(null);\n\n    const [columnResize, setColumnResize] = useState<DragOp | null>(null);\n    const [rowResize, setRowResize] = useState<DragOp | null>(null);\n    const [columnDrag, setColumnDrag] = useState<DragOp | null>(null);\n    const [rowDrag, setRowDrag] = useState<DragOp | null>(null);\n\n    const [draggingKnob, setDraggingKnob] = useState(false);\n    const [draggingSelection, setDraggingSelection] = useState(false);\n    const [draggingRowSelection, setDraggingRowSelection] = useState(false);\n    const [draggingColumnSelection, setDraggingColumnSelection] = useState(false);\n\n    const {hideRowHeaders, hideColumnHeaders} = sheetStyle;\n    const {cellToPixel, getVersion} = cellLayout;\n    const version = getVersion();\n\n    const knobPosition = useMemo((): XY | null => {\n        const [, [maxX, maxY]] = normalizeSelection(selection);\n        if (isRowSelection(selection)) {\n            return subXY(addXY(cellToPixel([0, maxY], [0, 1]), [SIZES.knobArea * 0.5, 0]), ONE_ONE);\n        }\n        if (isColumnSelection(selection)) {\n            return subXY(addXY(cellToPixel([maxX, 0], [1, 0]), [0, SIZES.knobArea * 0.5]), ONE_ONE);\n        }\n        if (isCellSelection(selection)) {\n            return subXY(cellToPixel([maxX, maxY], ONE_ONE), ONE_ONE);\n        }\n        return null;\n    }, [selection, cellToPixel, version]);\n\n    // Pass dragging state into handlers via ref so they don't need to rebind during resizes/drags\n    const refState = {\n        selection,\n        knobArea,\n        editMode,\n        editData,\n        sourceData,\n        cellLayout,\n        visibleCells,\n\n        knobPosition,\n        columnResize,\n        rowResize,\n        columnDrag,\n        rowDrag,\n\n        draggingKnob,\n        draggingSelection,\n        draggingRowSelection,\n        draggingColumnSelection,\n    };\n    const ref = useRef(refState);\n    ref.current = refState;\n\n    // Hit-testing for rendered objects\n    const getMousePosition = useCallback((e: PointerEvent<any> | MouseEvent<any>) => {\n        if (!e.target || !(e.target instanceof Element)) {\n            return null;\n        }\n\n        const rect = e.target.getBoundingClientRect();\n        const xy: XY = [\n            e.clientX - rect.left,\n            e.clientY - rect.top,\n        ];\n        return xy;\n    }, []);\n\n    const getScrollPosition = useCallback((e: PointerEvent<any> | MouseEvent<any>) => {\n        if (!e.target || !(e.target instanceof Element)) {\n            return [0, 0];\n        }\n\n        const {scrollLeft, scrollTop} = e.target as any;\n        const xy: XY = [scrollLeft, scrollTop];\n\n        return xy;\n    }, []);\n\n    const getMouseHit = useCallback((xy: XY) => {\n        const {current: hitmap} = hitmapRef;\n        if (!hitmap) return null;\n\n        for (const object of hitmap) {\n            const {rect} = object;\n            if (isPointInsideSelection(rect, xy)) {\n                return object;\n            }\n        }\n\n        return null;\n    }, [hitmapRef]);\n\n    const onPointerLeave = useCallback(() => {\n        window.document.body.style.cursor = 'auto';\n    }, []);\n\n    const onPointerDown = useCallback((e: PointerEvent<HTMLDivElement>) => {\n        const {\n            current: {\n                selection,\n                cellLayout: {columnToPixel, rowToPixel, pixelToCell, getIndentX, getIndentY},\n                visibleCells: {columns, rows},\n                knobPosition,\n            },\n        } = ref;\n\n        if (e.button !== 0) return;\n\n        (e.target as Element)?.setPointerCapture?.(e.pointerId);\n\n        const xy = getMousePosition(e);\n        if (!xy) return;\n\n        const [x, y] = xy;\n        const hitTarget = getMouseHit(xy);\n        if (hitTarget) {\n            setHitTarget(hitTarget);\n            return;\n        }\n\n        const [[minX, minY], [maxX, maxY]] = normalizeSelection(selection);\n\n        const selectedColumns = [];\n        const selectedRows = [];\n        for (let i = minX; i <= maxX; i++) selectedColumns.push(i);\n        for (let i = minY; i <= maxY; i++) selectedRows.push(i);\n\n        // Column header\n        if (!hideColumnHeaders && y < getIndentY()) {\n            // Grab selected columns in column selection\n            if (onColumnOrderChange) {\n                // Trim off start/end so resize works there\n                const start = columnToPixel(minX) + SIZES.resizeZone;\n                const end = columnToPixel(maxX, 1) - SIZES.resizeZone;\n                if (isInRange(x, start, end)) {\n\n                    for (const index of columns) {\n                        const start = columnToPixel(index, 0);\n                        const end = columnToPixel(index, 1);\n\n                        if (\n                            isColumnSelection(selection) &&\n                            isInRange(x, start, end) &&\n                            isInRange(index, minX, maxX) &&\n                            canOrderColumn(index)\n                        ) {\n                            window.document.body.style.cursor = 'grabbing';\n\n                            const indices = selectedColumns;\n                            const size = columnToPixel(maxX, 1) - columnToPixel(minX);\n                            const [scroll] = getScrollPosition(e);\n\n                            setColumnDrag({\n                                anchor: x,\n                                scroll,\n                                size,\n                                indices,\n                            });\n                            onDragOffsetChange?.([0, 0]);\n                            return;\n                        }\n                    }\n                }\n            }\n\n            // Resize columns\n            if (onCellWidthChange) {\n                for (const index of columns) {\n                    const edge = columnToPixel(index, 1);\n\n                    if ((Math.abs(edge - x) < SIZES.resizeZone) && canSizeColumn(index)) {\n                        window.document.body.style.cursor = 'col-resize';\n\n                        const asGroup = isColumnSelection(selection) && maxX === index;\n                        const indices = asGroup\n                            ? selectedColumns\n                            : [index];\n\n                        const size = asGroup\n                            ? columnToPixel(maxX, 1) - columnToPixel(minX)\n                            : columnToPixel(index, 1) - columnToPixel(index);\n                        const [scroll] = getScrollPosition(e);\n\n                        setColumnResize({\n                            anchor: x,\n                            scroll,\n                            size,\n                            indices,\n                        });\n                        return;\n                    }\n                }\n            }\n        }\n\n        if (!hideRowHeaders && x < getIndentX()) {\n            // Grab selected rows in row selection\n            if (onRowOrderChange) {\n                // Trim off start/end so resize works there\n                const start = rowToPixel(minY) + SIZES.resizeZone;\n                const end = rowToPixel(maxY, 1) - SIZES.resizeZone;\n                if (isInRange(y, start, end)) {\n\n                    for (const index of rows) {\n                        const start = rowToPixel(index, 0);\n                        const end = rowToPixel(index, 1);\n\n                        if (\n                            isRowSelection(selection) &&\n                            isInRange(y, start, end) &&\n                            isInRange(index, minY, maxY) &&\n                            canOrderRow(index)\n                        ) {\n                            window.document.body.style.cursor = 'grabbing';\n\n                            const indices = selectedRows;\n                            const size = rowToPixel(maxY, 1) - rowToPixel(minY);\n                            const [, scroll] = getScrollPosition(e);\n\n                            setRowDrag({\n                                anchor: y,\n                                scroll,\n                                size,\n                                indices,\n                            });\n                            onDragOffsetChange?.([0, 0]);\n                            return;\n                        }\n                    }\n                }\n            }\n\n            // Resize rows\n            if (onCellHeightChange) {\n                for (const index of rows) {\n                    const edge = rowToPixel(index, 1);\n\n                    if ((Math.abs(edge - y) < SIZES.resizeZone) && canSizeRow(index)) {\n                        window.document.body.style.cursor = 'row-resize';\n\n                        const asGroup = isRowSelection(selection) && maxY === index;\n                        const indices = asGroup\n                            ? selectedRows\n                            : [index];\n\n                        const size = asGroup\n                            ? rowToPixel(maxY, 1) - rowToPixel(minY)\n                            : rowToPixel(index, 1) - rowToPixel(index);\n                        const [, scroll] = getScrollPosition(e);\n\n                        setRowResize({\n                            anchor: y,\n                            scroll,\n                            size,\n                            indices,\n                        });\n                        return;\n                    }\n                }\n            }\n        }\n\n        // Knob drag mode\n        if (knobPosition) {\n            const [knobX, knobY] = knobPosition;\n            if (Math.abs(x - knobX) < SIZES.knobArea && Math.abs(y - knobY) < SIZES.knobArea) {\n                setDraggingKnob(true);\n                onKnobAreaChange?.(selection);\n                return;\n            }\n        }\n\n        // Normal cell click\n        const head = pixelToCell(xy);\n        const anchor: XY = e.shiftKey ? [...selection[0]] : head;\n\n        if (editMode) {\n            if (!dontCommitEditOnSelectionChange) {\n                onCommit?.();\n            }\n        }\n\n        let scrollToHead = true;\n\n        if (!hideRowHeaders && x < getIndentX()) {\n            scrollToHead = false;\n            setDraggingRowSelection(true);\n            anchor[0] = -1;\n            head[0] = -1;\n        }\n\n        if (!hideColumnHeaders && y < getIndentY()) {\n            scrollToHead = false;\n            setDraggingColumnSelection(true);\n            anchor[1] = -1;\n            head[1] = -1;\n        }\n\n        setDraggingSelection(true);\n        onSelectionChange?.([anchor, head], scrollToHead);\n    }, [\n        getMousePosition,\n        getScrollPosition,\n        getMouseHit,\n        onColumnOrderChange,\n        onRowOrderChange,\n        onCellWidthChange,\n        onCellHeightChange,\n        onKnobAreaChange,\n        onSelectionChange,\n        onCommit,\n        canSizeColumn,\n        canSizeRow,\n        canOrderColumn,\n        canOrderRow,\n    ]);\n\n    const onPointerUp = useCallback((e: PointerEvent<HTMLDivElement>) => {\n        const {\n            current: {\n                knobArea,\n                selection,\n                sourceData,\n                editData,\n\n                columnDrag,\n                rowDrag,\n\n                draggingKnob,\n\n                cellLayout: {pixelToColumn, pixelToRow, getIndentX, getIndentY},\n            },\n        } = ref;\n\n        if (knobArea && draggingKnob) {\n            const changes = parseKnobOperation(knobArea, selection, sourceData, editData);\n\n            onChange?.(changes);\n            onSelectionChange?.(knobArea);\n            onKnobAreaChange?.(null);\n        }\n\n        const xy = getMousePosition(e);\n        if (xy && (columnDrag || rowDrag)) {\n            window.document.body.style.cursor = 'auto';\n            onDragOffsetChange?.(null);\n            onDropTargetChange?.(null);\n\n            const [x, y] = xy;\n            const [[minX, minY], [maxX, maxY]] = normalizeSelection(selection);\n\n            const cellX = pixelToColumn(Math.max(x, getIndentX()), 0.5);\n            const cellY = pixelToRow(Math.max(y, getIndentY()), 0.5);\n\n            if (columnDrag) {\n                const {indices} = columnDrag;\n\n                const insideSelection = cellX >= minX && cellX <= maxX + 1;\n                if (!insideSelection) {\n                    const order = cellX > minX ? cellX - indices.length : cellX;\n                    onSelectionChange?.([[order, minY], [order + maxX - minX, maxY]]);\n                    onColumnOrderChange?.(indices, order);\n                    onInvalidateColumn?.(Math.min(minX, order));\n                }\n            }\n            if (rowDrag) {\n                const {indices} = rowDrag;\n\n                const insideSelection = cellY >= minY && cellY <= maxY + 1;\n                if (!insideSelection) {\n                    const order = cellY > minY ? cellY - indices.length : cellY;\n                    onSelectionChange?.([[minX, order], [maxX, order + maxY - minY]]);\n                    onRowOrderChange?.(indices, order);\n                    onInvalidateRow?.(Math.min(minY, order));\n                }\n            }\n        }\n\n        setDraggingSelection(false);\n        setDraggingRowSelection(false);\n        setDraggingColumnSelection(false);\n        setDraggingKnob(false);\n        setColumnResize(null);\n        setColumnDrag(null);\n        setRowResize(null);\n        setRowDrag(null);\n\n        if (!xy || !hitTarget) return;\n        setHitTarget(null);\n\n        if (hitTarget === getMouseHit(xy)) {\n            const {obj} = hitTarget;\n            obj.onClick?.(e);\n        }\n\n    }, [\n        getMousePosition,\n        getMouseHit,\n        onChange,\n        onSelectionChange,\n        onKnobAreaChange,\n        onDropTargetChange,\n        onColumnOrderChange,\n        onRowOrderChange,\n    ]);\n\n    const onPointerMove = useCallback((e: PointerEvent<HTMLDivElement>) => {\n        const {\n            current: {\n                selection,\n                visibleCells,\n\n                knobPosition,\n                columnResize,\n                columnDrag,\n                rowResize,\n                rowDrag,\n\n                draggingKnob,\n                draggingSelection,\n                draggingColumnSelection,\n                draggingRowSelection,\n\n                cellLayout: {columnToPixel, rowToPixel, pixelToCell, pixelToColumn, pixelToRow, getIndentX, getIndentY},\n            },\n        } = ref;\n\n        const xy = getMousePosition(e);\n        if (!xy) return;\n\n        window.document.body.style.cursor = 'auto';\n\n        const hitTarget = getMouseHit(xy);\n        if (hitTarget) {\n            window.document.body.style.cursor = 'pointer';\n        }\n        else if (columnDrag || rowDrag) {\n            window.document.body.style.cursor = 'grabbing';\n        }\n        else if (columnResize) {\n            window.document.body.style.cursor = 'col-resize';\n            e.preventDefault();\n        }\n        else if (rowResize) {\n            window.document.body.style.cursor = 'row-resize';\n            e.preventDefault();\n        }\n        else if (draggingRowSelection || draggingColumnSelection) {\n            e.preventDefault();\n        }\n\n        const {columns, rows} = visibleCells;\n        const [x, y] = xy;\n        const [[minX, minY], [maxX, maxY]] = normalizeSelection(selection);\n\n        const isDragging = columnResize || columnDrag || rowResize || rowDrag || draggingRowSelection || draggingColumnSelection;\n\n        if (!isDragging) {\n            if (!hideColumnHeaders && y < getIndentY()) {\n                if (onColumnOrderChange) {\n                    // Trim off start/end so resize works there\n                    const start = columnToPixel(minX) + SIZES.resizeZone;\n                    const end = columnToPixel(maxX, 1) - SIZES.resizeZone;\n                    if (isInRange(x, start, end)) {\n\n                        for (const index of columns) {\n                            const start = columnToPixel(index);\n                            const end = columnToPixel(index, 1);\n\n                            if (\n                                !draggingColumnSelection &&\n                                isColumnSelection(selection) &&\n                                isInRange(x, start, end) &&\n                                isInRange(index, minX, maxX) &&\n                                canOrderColumn(index)\n                            ) {\n                                window.document.body.style.cursor = 'grab';\n                                return;\n                            }\n                        }\n                    }\n                }\n                if (onCellWidthChange) {\n                    for (const index of columns) {\n                        const edge = columnToPixel(index, 1);\n                        if ((Math.abs(edge - x) < SIZES.resizeZone) && canSizeColumn(index)) {\n                            window.document.body.style.cursor = 'col-resize';\n                            return;\n                        }\n                    }\n                }\n            }\n\n            if (!hideRowHeaders && x < getIndentX()) {\n                if (onRowOrderChange) {\n                    // Trim off start/end so resize works there\n                    const start = rowToPixel(minY) + SIZES.resizeZone;\n                    const end = rowToPixel(maxY, 1) - SIZES.resizeZone;\n                    if (isInRange(y, start, end)) {\n\n                        for (const index of rows) {\n                            const start = rowToPixel(index);\n                            const end = rowToPixel(index, 1);\n\n                            if (\n                                !draggingRowSelection &&\n                                isRowSelection(selection) &&\n                                isInRange(y, start, end) &&\n                                isInRange(index, minY, maxY) &&\n                                canOrderRow(index)\n                            ) {\n                                window.document.body.style.cursor = 'grab';\n                                return;\n                            }\n                        }\n                    }\n                }\n                if (onCellHeightChange) {\n                    for (const index of rows) {\n                        const edge = rowToPixel(index, 1);\n                        if ((Math.abs(edge - y) < SIZES.resizeZone) && canSizeRow(index)) {\n                            window.document.body.style.cursor = 'row-resize';\n                            return;\n                        }\n                    }\n                }\n            }\n\n            if (knobPosition) {\n                const [knobX, knobY] = knobPosition;\n                if (Math.abs(x - knobX) < SIZES.knobArea && Math.abs(y - knobY) < SIZES.knobArea) {\n                    window.document.body.style.cursor = 'crosshair';\n                    return;\n                }\n            }\n        }\n\n        if (columnResize) {\n            if (onCellWidthChange) {\n                const {size, anchor, scroll, indices} = columnResize;\n                const [currentScroll] = getScrollPosition(e);\n                const newWidth = Math.max(size + x - anchor + scroll - currentScroll, SIZES.minimumWidth * indices.length);\n                onInvalidateColumn?.(indices[0] - 1);\n                onCellWidthChange(indices, newWidth / indices.length);\n            }\n            return;\n        }\n\n        if (rowResize) {\n            if (onCellHeightChange) {\n                const {size, anchor, scroll, indices} = rowResize;\n                const [, currentScroll] = getScrollPosition(e);\n                const newHeight = Math.max(size + y - anchor + scroll - currentScroll, SIZES.minimumHeight * indices.length);\n                onInvalidateRow?.(indices[0] - 1);\n                onCellHeightChange(indices, newHeight / indices.length);\n            }\n            return;\n        }\n\n        if (draggingSelection) {\n            const [anchor] = selection;\n            const head = pixelToCell(xy);\n\n            const [anchorX, anchorY] = anchor;\n            const [headX, headY] = head;\n\n            if (draggingRowSelection) {\n                onSelectionChange?.([[-1, anchorY], [-1, Math.max(0, headY)]], false);\n            } else if (draggingColumnSelection) {\n                onSelectionChange?.([[anchorX, -1], [Math.max(0, headX), -1]], false);\n            } else {\n                onSelectionChange?.([\n                    maxXY(anchor, ORIGIN),\n                    maxXY(head, ORIGIN),\n                ], false);\n            }\n        }\n\n        if (draggingKnob) {\n            window.document.body.style.cursor = 'crosshair';\n\n            const [cellX, cellY] = pixelToCell(xy);\n            let [[minX, minY], [maxX, maxY]] = normalizeSelection(selection);\n\n            // check if vertical or horizontal\n            let xCellDiff = Math.min(cellX - minX, maxX - cellX, 0); // zero or less\n            let yCellDiff = Math.min(cellY - minY, maxY - cellY, 0); // zero or less\n\n            if (isMaybeRowSelection(selection) || xCellDiff > yCellDiff) {\n                if (cellY < minY) {\n                    minY = cellY;\n                } else if (cellY > maxY) {\n                    maxY = cellY;\n                }\n            } else {\n                if (cellX < minX) {\n                    minX = cellX;\n                } else if (cellX > maxX) {\n                    maxX = cellX;\n                }\n            }\n\n            onKnobAreaChange?.([[minX, minY], [maxX, maxY]]);\n        }\n\n        if (columnDrag || rowDrag) {\n            const [x, y] = xy;\n            if (columnDrag) {\n                const cellX = pixelToColumn(Math.max(x, getIndentX()), 0.5);\n                const insideSelection = cellX >= minX && cellX <= maxX + 1;\n\n                const {anchor, scroll} = columnDrag;\n                const shift = x - anchor;\n                const [currentScroll] = getScrollPosition(e);\n\n                onDragOffsetChange?.([shift + currentScroll - scroll, 0]);\n                onDropTargetChange?.(insideSelection ? null : [[cellX, -1], [cellX, -1]]);\n            }\n            if (rowDrag) {\n                const cellY = pixelToRow(Math.max(y, getIndentY()), 0.5);\n                const insideSelection = cellY >= minY && cellY <= maxY + 1;\n\n                const {anchor, scroll} = rowDrag;\n                const shift = y - anchor;\n                const [, currentScroll] = getScrollPosition(e);\n\n                onDragOffsetChange?.([0, shift + currentScroll - scroll]);\n                onDropTargetChange?.(insideSelection ? null : [[-1, cellY], [-1, cellY]]);\n            }\n        }\n    }, [\n        getMousePosition,\n        getScrollPosition,\n        getMouseHit,\n        onCellWidthChange,\n        onCellHeightChange,\n    ]);\n\n    const onDoubleClick = useCallback((e: MouseEvent) => {\n        const {\n            current: {\n                cellLayout: {pixelToCell},\n            },\n        } = ref;\n\n        e.preventDefault();\n        if (e.shiftKey) return;\n\n        const xy = getMousePosition(e);\n        if (!xy) return;\n\n        const hitTarget = getMouseHit(xy);\n        if (hitTarget) {\n            window.document.body.style.cursor = 'pointer';\n            return;\n        }\n\n        const editCell = pixelToCell(xy);\n        if (editMode) onCommit?.();\n        onEdit?.(editCell);\n    }, [getMousePosition, getMouseHit, onCommit, onEdit]);\n\n    const onContextMenu = useCallback((e: MouseEvent) => {\n        const {\n            current: {\n                cellLayout: {pixelToCell, getIndentX, getIndentY},\n            },\n        } = ref;\n\n        const xy = getMousePosition(e);\n        if (!xy) return;\n\n        const [x, y] = xy;\n        if (x <= getIndentX() || y <= getIndentY()) {\n            return;\n        }\n\n        // If click is not inside of selection, select the right clicked cell\n        const cell = pixelToCell(xy);\n        if (!isPointInsideSelection(selection, cell)) {\n            onSelectionChange?.([cell, cell]);\n        }\n\n        onPointerMove(e as any);\n\n        const [cellX, cellY] = cell;\n        const event: SheetMouseEvent = {\n            ...e,\n            cellX,\n            cellY,\n        };\n        onRightClick?.(event);\n    }, [getMousePosition, onSelectionChange, onPointerMove, onRightClick]);\n\n    const mouseHandlers = {\n        onPointerLeave,\n        onPointerDown,\n        onPointerMove,\n        onPointerUp,\n        onDoubleClick,\n        onContextMenu,\n    };\n\n    return {knobPosition, mouseHandlers};\n};\n\nconst parseKnobOperation = (\n    knobArea: Rectangle,\n    selection: Rectangle,\n    sourceData: CellPropertyFunction<string | number | null>,\n    editData: CellPropertyFunction<string>,\n): Change[] => {\n    const [[kx1, ky1], [kx2, ky2]] = normalizeSelection(knobArea);\n    const [[sx1, sy1], [sx2, sy2]] = normalizeSelection(selection);\n\n    let fx1 = kx1;\n    let fy1 = ky1;\n    let fx2 = kx2;\n    let fy2 = ky2;\n\n    const changes: Change[] = [];\n\n    // TODO: this should be made less cryptic, using logical selection ops/fns\n\n    if (fx2 - fx1 === sx2 - sx1) {\n        // vertical\n        if (fy1 === sy1) {\n            fy1 = sy2 + 1;\n        } else {\n            fy2 = sy1 - 1;\n        }\n        if (fx1 === -1 && fx2 === -1) {\n            const [maxX] = findApproxMaxEditDataIndex(editData);\n            fx1 = 0;\n            fx2 = maxX;\n        }\n        let srcY = sy1;\n        for (let y = fy1; y <= fy2; y++) {\n            for (let x = fx1; x <= fx2; x++) {\n                const value = sourceData(x, srcY);\n                changes.push({ x: x, y: y, value: value, source: { x: x, y: srcY } });\n            }\n            srcY = srcY + 1;\n            if (srcY > sy2) {\n                srcY = sy1;\n            }\n        }\n    } else {\n        // horizontal\n        if (fx1 === sx1) {\n            fx1 = sx2 + 1;\n        } else {\n            fx2 = sx1 - 1;\n        }\n        if (fy1 === -1 && fy2 === -1) {\n            const [, maxY] = findApproxMaxEditDataIndex(editData);\n            fy1 = 0;\n            fy2 = maxY;\n        }\n        let srcX = sx1;\n        for (let x = fx1; x <= fx2; x++) {\n            for (let y = fy1; y <= fy2; y++) {\n                const value = sourceData(srcX, y);\n                changes.push({ x: x, y: y, value: value, source: { x: srcX, y: y } });\n            }\n            srcX = srcX + 1;\n            if (srcX > sx2) {\n                srcX = sx1;\n            }\n        }\n    }\n\n    return changes;\n}","import { CellPropertyFunction, Change, ParsedChange, Rectangle } from './types';\nimport { RefObject, useLayoutEffect, useEffect } from 'react';\nimport { findApproxMaxEditDataIndex } from './props';\nimport { normalizeSelection, isMaybeRowSelection, isMaybeColumnSelection, isEmptySelection } from './coordinate';\n\nexport const useClipboardCopy = (\n    textAreaRef: RefObject<HTMLTextAreaElement>,\n    selection: Rectangle,\n    editMode: boolean,\n    editData: CellPropertyFunction<string>,\n) => {\n    useLayoutEffect(() => {\n        const {current: textArea} = textAreaRef;\n        if (!textArea) return;\n\n        if (editMode) return;\n        if (isEmptySelection(selection)) return;\n\n        textArea.value = formatSelectionAsTSV(selection, editData);\n    }, [selection, editMode, editData, textAreaRef]);\n\n    useLayoutEffect(() => {\n        const {current: textArea} = textAreaRef;\n        if (!textArea) return;\n\n        const focus = () => {\n            textArea.focus({ preventScroll: true });\n            textArea.select();\n        };\n\n        if (editMode) return;\n        if (document.activeElement === textArea) return;\n\n        const activeTagName = (document as any).activeElement.tagName.toLowerCase();\n        if (\n            !(\n                (activeTagName === 'div' && (document as any).activeElement.contentEditable === 'true') ||\n                activeTagName === 'input' ||\n                activeTagName === 'textarea' ||\n                activeTagName === 'select'\n            )\n        ) {\n            focus();\n        }\n    });\n}\n\nexport const useClipboardPaste = (\n    textAreaRef: RefObject<HTMLTextAreaElement>,\n    selection: Rectangle,\n    onSelectionChange?: (selection: Rectangle) => void,\n    onChange?: (changes: Array<Change>) => void,\n) => {\n    useEffect(() => {\n        const onPaste = (e: any) => {\n            const {current: textArea} = textAreaRef;\n            if (!textArea) return;\n\n            if (e.target !== textArea) return;\n            e.preventDefault();\n\n            const clipboardData = e.clipboardData || (window as any).clipboardData;\n            const types = clipboardData.types;\n\n            let parsed;\n            if (types.includes('text/html')) {\n                const pastedHtml = clipboardData.getData('text/html');\n                parsed = parsePastedHtml(selection, pastedHtml);\n            } else if (types.includes('text/plain')) {\n                const text = clipboardData.getData('text/plain');\n                parsed = parsePastedText(selection, text);\n            }\n            if (!parsed) return;\n\n            const {selection: s, changes} = parsed;\n            onChange?.(changes);\n            onSelectionChange?.(s);\n        };\n\n        window.document.addEventListener('paste', onPaste);\n        return () => {\n            window.document.removeEventListener('paste', onPaste);\n        };\n    }, [textAreaRef, selection]);\n}\n\nconst formatTSV = (rows: string[][]) => rows.map(row => row.join('\\t')).join('\\n');\n\nconst formatSelectionAsTSV = (\n    selection: Rectangle,\n    editData: CellPropertyFunction<string>,\n) => {\n    if (isEmptySelection(selection)) return '';\n\n    let [[minX, minY], [maxX, maxY]] = normalizeSelection(selection);\n    if (isMaybeRowSelection(selection)) {\n        const [cellX] = findApproxMaxEditDataIndex(editData);\n        minX = 0;\n        maxX = cellX;\n    }\n    if (isMaybeColumnSelection(selection)) {\n        const [, cellY] = findApproxMaxEditDataIndex(editData);\n        minY = 0;\n        maxY = cellY;\n    }\n\n    const rows: string[][] = [];\n\n    for (let y = minY; y <= maxY; y++) {\n        const row: string[] = [];\n\n        for (let x = minX; x <= maxX; x++) {\n            const value = editData(x, y);\n            if (value !== null && value !== undefined) {\n                row.push(value != null ? value : '');\n            }\n        }\n\n        rows.push(row);\n    }\n\n    return formatTSV(rows);\n}\n\nconst findTable = (element: any): any => {\n    for (const child of element.children) {\n        if (child.nodeName === 'TABLE') {\n            return child;\n        }\n        const maybeTable = findTable(child);\n        if (maybeTable) {\n            return maybeTable;\n        }\n    }\n};\n\nconst parsePastedHtml = (selection: Rectangle, html: string): ParsedChange | null => {\n    const div = document.createElement('div');\n    div.innerHTML = html.trim();\n\n    const [[minX, minY]] = normalizeSelection(selection);\n    let left = isMaybeRowSelection(selection) ? 0 : minX;\n    let top = isMaybeColumnSelection(selection) ? 0 : minY;\n\n    const changes = [];\n\n    const tableNode = findTable(div);\n    if (!tableNode) {\n        return null;\n    }\n\n    let right = left;\n    let bottom = top;\n\n    let y = top;\n    for (const tableChild of tableNode.children) {\n        if (tableChild.nodeName === 'TBODY') {\n            for (const tr of tableChild.children) {\n                let x = left;\n                if (tr.nodeName === 'TR') {\n                    for (const td of tr.children) {\n                        if (td.nodeName === 'TD') {\n                            let str: string = '';\n                            if (td.children.length !== 0 && td.children[0].nodeName === 'P') {\n                                const p = td.children[0];\n                                if (p.children.length !== 0 && p.children[0].nodeName === 'FONT') {\n                                    str = p.children[0].textContent.trim();\n                                } else {\n                                    str = p.textContent.trim();\n                                }\n                            } else {\n                                str = td.textContent.trim();\n                            }\n                            str = str.replaceAll('\\n', '');\n                            str = str.replaceAll(/\\s\\s+/g, ' ');\n                            changes.push({ x, y, value: str });\n                            x++;\n                        }\n                    }\n                    y++;\n                }\n                right = Math.max(right, x);\n            }\n        }\n    }\n    bottom = y;\n\n    return {\n        selection: [[left, top], [right, bottom]],\n        changes,\n    };\n};\n\nconst parsePastedText = (selection: Rectangle, text: string): ParsedChange => {\n    const [[minX, minY]] = normalizeSelection(selection);\n    let left = isMaybeRowSelection(selection) ? 0 : minX;\n    let top = isMaybeColumnSelection(selection) ? 0 : minY;\n\n    const rows = text.split(/\\r?\\n/);\n    let right = left;\n    let bottom = top + rows.length - 1;\n\n    const changes = [];\n    for (let y = 0; y < rows.length; y++) {\n        const cols = rows[y].split('\\t');\n        right = Math.max(right, left + cols.length - 1);\n\n        for (let x = 0; x < cols.length; x++) {\n            changes.push({ x: left + x, y: top + y, value: cols[x] });\n        }\n    }\n\n    return {\n        selection: [[left, top], [right, bottom]],\n        changes,\n    };\n};\n","import { XY, CellLayout, VisibleLayout, LayoutCache } from './types';\nimport { seq } from './util';\nimport { ORIGIN } from './constants';\n\nconst INITIAL_SIZE = 256;\n\n// Local cell layout (virtualized with frozen columns/rows)\n//\n// - converts cell indices to (x, y) canvas pixels for any cell, including off-screen\n// - maps (x, y) canvas pixels back to cell index for any visible cell\n// - can also generate absolute, unscrolled offsets relative to (0,0) to drive scrolling\n// - generates list of visible cols/rows in view\n//\n// Note that adjacent column indices are not necessarily adjacent, i.e. end of [i] != start of [i + 1].\nexport const makeCellLayout = (\n    freeze: XY,\n    indent: XY,\n    offset: XY,\n\n    columns: LayoutCache,\n    rows: LayoutCache,\n): CellLayout => {\n    const [freezeX, freezeY] = freeze;\n    const [indentX, indentY] = indent;\n    const [offsetX, offsetY] = offset;\n\n    const getIndentX = () => indentX;\n    const getIndentY = () => indentY;\n\n    // Origin for cell, frozen or relative\n    const getBaseOriginFor = (index: number, freeze: number, offset: number) => {\n        return index < freeze ? 0 : offset;\n    };\n    \n    // Get visible pixel x of cell\n    const columnToPixel = (column: number, anchor: number = 0): number => {\n        const base = getBaseOriginFor(column, freezeX, offsetX);\n        const relative = columns.getStart(column) - columns.getStart(base);\n        const size = column < 0 ? indentX : columns.getSize(column);\n\n        return column < 0 ? 0 : indentX + relative + anchor * size;\n    };\n\n    // Get visible pixel y of cell\n    const rowToPixel = (row: number, anchor: number = 0): number => {\n        const base = getBaseOriginFor(row, freezeY, offsetY);\n        const relative = rows.getStart(row) - rows.getStart(base);\n        const size = row < 0 ? indentY : rows.getSize(row);\n\n        return row < 0 ? 0 : indentY + relative + anchor * size;\n    };\n\n    // Get visible pixel position of cell, offset with anchor [0..1, 0..1]\n    const cellToPixel = (cell: XY, anchor: XY = ORIGIN): XY => {\n        const [cellX, cellY] = cell;\n        const [anchorX, anchorY] = anchor;\n        return [\n            columnToPixel(cellX, anchorX),\n            rowToPixel(cellY, anchorY),\n        ];\n    };\n\n    // Get absolute / unscrolled pixel x of cell\n    const columnToAbsolute = (column: number, anchorX: number = 0): number => {\n        const relative = columns.getStart(column);\n        const size = column < 0 ? 0 : columns.getSize(column);\n\n        return relative + anchorX * size;\n    };\n\n    // Get absolute / unscrolled pixel y of cell\n    const rowToAbsolute = (row: number, anchorY: number = 0): number => {\n        const relative = rows.getStart(row);\n        const size = row < 0 ? 0 : rows.getSize(row);\n\n        return relative + anchorY * size;\n    };\n\n    // Get absolute / unscrolled pixel position of cell, offset with anchor [0..1, 0..1]\n    const cellToAbsolute = (cell: XY, anchor: XY = ORIGIN): XY => {\n        const [cellX, cellY] = cell;\n        const [anchorX, anchorY] = anchor;\n        return [\n            columnToAbsolute(cellX, anchorX),\n            rowToAbsolute(cellY, anchorY),\n        ];\n    };\n\n    // Lookup pixel X or Y in cell layout\n    const pixelToIndex = (pixel: number, anchor: number, indent: number, freeze: number, offset: number, layout: LayoutCache) => {\n        const relative = pixel - indent;\n        if (relative < 0) return -1;\n\n        const {getStart, lookupIndex} = layout;\n        const frozen = getStart(freeze);\n        if (relative < frozen) {\n            return lookupIndex(relative, anchor);\n        }\n        else {\n            const base = getStart(offset);\n            return lookupIndex(base + relative, anchor);\n        }\n    };\n\n    // Lookup pixel X or Y in cell layout (helpers)\n    const pixelToColumn = (pixelX: number, anchorX: number = 0) => pixelToIndex(pixelX, anchorX, indentX, freezeX, offsetX, columns);\n    const pixelToRow = (pixelY: number, anchorY: number = 0) => pixelToIndex(pixelY, anchorY, indentY, freezeY, offsetY, rows);\n\n    // Lookup pixel XY in cell layout\n    const pixelToCell = (pixel: XY, anchor: XY = ORIGIN): XY => {\n        const [pixelX, pixelY] = pixel;\n        const [anchorX, anchorY] = anchor;\n        return [\n            pixelToColumn(pixelX, anchorX),\n            pixelToRow(pixelY, anchorY),\n        ];\n    };\n\n    // Lookup absolute / unscrolled pixel X or Y in cell layout\n    const absoluteToIndex = (pixel: number, anchor: number, layout: LayoutCache) => {\n        if (pixel < 0) return -1;\n\n        const {lookupIndex} = layout;\n        return lookupIndex(pixel, anchor);\n    };\n\n    // Lookup absolute / unscrolled X or Y in cell layout (helpers)\n    const absoluteToColumn = (pixelX: number, anchorX: number = 0) => absoluteToIndex(pixelX, anchorX, columns);\n    const absoluteToRow = (pixelY: number, anchorY: number = 0) => absoluteToIndex(pixelY, anchorY, rows);\n\n    // Lookup absolute / unscrolled XY in cell layout\n    const absoluteToCell = (pixel: XY, anchor: XY = ORIGIN): XY => {\n        const [pixelX, pixelY] = pixel;\n        const [anchorX, anchorY] = anchor;\n        return [\n            absoluteToColumn(pixelX, anchorX),\n            absoluteToRow(pixelY, anchorY),\n        ];\n    };\n\n    // Get visible range of columns or rows\n    const getVisibleIndices = (view: number, indent: number, freeze: number, offset: number, layout: LayoutCache) => {\n        const indices = [...seq(freeze)];\n\n        const {getStart} = layout;\n        const relative = view - indent + getStart(offset);\n        for (let i = offset + freeze; getStart(i) <= relative; ++i) {\n            indices.push(i);\n        }\n\n        return indices;\n    };\n\n    // Get visible range for an XY viewport\n    const getVisibleCells = (view: XY): VisibleLayout => {\n        const [viewX, viewY] = view;\n        return {\n            columns: getVisibleIndices(viewX, indentX, freezeX, offsetX, columns),\n            rows: getVisibleIndices(viewY, indentY, freezeY, offsetY, rows),\n        };\n    };\n\n    const getVersion = () => columns.getVersion() + rows.getVersion();\n\n    return {\n        columnToPixel,\n        rowToPixel,\n        cellToPixel,\n\n        columnToAbsolute,\n        rowToAbsolute,\n        cellToAbsolute,\n\n        pixelToColumn,\n        pixelToRow,\n        pixelToCell,\n\n        absoluteToColumn,\n        absoluteToRow,\n        absoluteToCell,\n\n        getVisibleCells,\n        getIndentX,\n        getIndentY,\n\n        getVersion,\n    };\n}\n\n// Offset cache in 1 dimension.\n//\n// Allows O(1) queries of distance between any two points, once warmed up.\n// Can do reverse lookup back to index with binary search, once warmed up.\n//\n// - caches sizer(i), each is only called once\n// - offset[0] = 0\n// - adds up offset[i] = sizer(0) + sizer(1) + ... + sizer(i - 1)\n// - cache can be truncated during resizing ops at split\n// - to replace sizer function, cache must be destroyed\nexport const makeLayoutCache = (\n    sizer: (index: number) => number,\n): LayoutCache => {\n    const offsets = makeIntMap(INITIAL_SIZE);\n    const sizes = makeIntMap(INITIAL_SIZE);\n\n    let version = 0;\n    offsets.set(0, 0);\n\n    // Cache size lookup directly\n    const getSize = (i: number): number => {\n        if (i < 0) return 0;\n        if (sizes.has(i)) return sizes.get(i)!;\n\n        const size = sizer(i) || 0;\n        sizes.set(i, size);\n        return size;\n    };\n\n    // Cache offset sum recursively\n    const getOffset = (i: number): number => {\n        if (i < 0) return 0;\n        if (offsets.has(i)) return offsets.get(i)!;\n\n        let j = (offsets.tail() || 0);\n\n        // Use a while loop to avoid stack overflow\n        while (j < i) {\n            const size = getSize(j);\n            const offset = (offsets.get(j) || 0) + size;\n            offsets.set(++j, offset);\n        }\n\n        return offsets.get(i)!;\n    };\n\n    // Boundary points\n    const getStart = (i: number) => getOffset(i);\n    const getEnd = (i: number) => getOffset(i + 1);\n\n    // Reverse lookup from offset to index\n    const lookupIndex = (x: number, anchor: number = 0) => {\n        // Get end of offsets array\n        let last = offsets.tail() || 0;\n\n        // Extend cache if value exceeds current end\n        while (getOffset(last) < x && getSize(last)) last += 64;\n\n        // Do binary search for exact position\n        let start = 0;\n        let end = last;\n        while (start < end) {\n            let mid = start + Math.floor((end - start) / 2) + 1;\n            let value = getOffset(mid) - (anchor ? anchor * getSize(mid - 1) : 0);\n            if (value <= x) start = mid;\n            else end = mid - 1;\n        }\n\n        return start;\n    };\n\n    const clearAfter = (index: number) => {\n        index = Math.max(0, index);\n        offsets.truncate(index);\n        sizes.truncate(index);\n        version++;\n    };\n\n    const setSizer = (s: (index: number) => number) => {\n        sizer = s;\n    };\n    const getVersion = () => version;\n\n    return {getSize, getStart, getEnd, getVersion, lookupIndex, setSizer, clearAfter};\n};\n\n// Fast map<integer, integer> that is mostly filled in from start to end.\n// Elements are only removed by truncating all indices > n.\nconst makeIntMap = (initialSize: number = 128) => {\n    let used: Uint8Array;\n    let values: Uint32Array;\n    let last = 0;\n\n    const GROW = 1.2; // 20% growth at a time\n\n    const allocate = (size: number) => {\n        let newUsed = new Uint8Array(size);\n        let newValues = new Uint32Array(size);\n        if (used) copy(used, newUsed);\n        if (values) copy(values, newValues);\n        used = newUsed;\n        values = newValues;\n    };\n    allocate(initialSize);\n\n    const copy = (from: Uint8Array | Uint32Array, to: Uint8Array | Uint32Array) => {\n        let n = Math.min(from.length, to.length);\n        for (let i = 0; i < n; ++i) {\n            to[i] = from[i];\n        }\n    };\n\n    const ensure = (size: number) => {\n        const l = values.length;\n        const grow = Math.round(l * GROW);\n        if (l < size) allocate(Math.max(grow, size));\n    };\n\n    const truncate = (size: number) => {\n        const l = values.length;\n\n        // Do nothing if smaller\n        if (l < size) return;\n\n        // If more than 20% bigger, shrink to exact size\n        const shrink = Math.round(size * GROW);\n        if (l > shrink) allocate(size);\n        // Else zero out tail\n        else for (let i = size; i < l; ++i) used[i] = 0;\n\n        // Track last filled element\n        last = Math.min(last, size);\n        while (last > 0 && !used[last]) last--;\n    };\n\n    const getTail = () => used[last] ? last : null;\n\n    const setValue = (i: number, value: number) => {\n        ensure(i + 1);\n        values[i] = value;\n        used[i] = 1;\n        last = Math.max(last, i);\n    };\n\n    const getValue = (i: number) => used[i] ? values[i] : null;\n    const hasValue = (i: number) => !!used[i];\n\n    return {truncate, set: setValue, get: getValue, has: hasValue, tail: getTail};\n};\n","import { InternalSheetStyle, SheetStyle, Style } from './types';\nimport { SIZES } from './constants';\n\nexport const resolveSheetStyle = (sheetStyle?: SheetStyle): InternalSheetStyle => {\n    return {\n        freezeColumns: sheetStyle?.freezeColumns || 0,\n        freezeRows: sheetStyle?.freezeRows || 0,\n        hideColumnHeaders: sheetStyle?.hideColumnHeaders || false,\n        hideRowHeaders: sheetStyle?.hideRowHeaders || false,\n        hideGridlines: sheetStyle?.hideGridlines || false,\n        hideScrollBars: sheetStyle?.hideScrollBars || false,\n        columnHeaderHeight: sheetStyle?.hideColumnHeaders ? 1 : SIZES.headerHeight,\n        rowHeaderWidth: sheetStyle?.hideRowHeaders ? 1 : SIZES.headerWidth,\n    };\n};\n\nexport const resolveCellStyle = (optionalStyle: Style, defaultStyle: Required<Style>): Required<Style> => {\n    return {\n        ...defaultStyle,\n        ...optionalStyle,\n    };\n};\n\nexport const applyAlignment = (\n    start: number,\n    cellSize: number,\n    style: Required<Style>,\n    imageWidth: number,\n    alignment: 'left' | 'center' | 'right' = style.textAlign,\n): number => {\n    if (alignment === 'left') {\n        return start + style.marginLeft;\n    } else if (alignment === 'center') {\n        return start + cellSize * 0.5 - imageWidth / 2;\n    } else if (alignment === 'right') {\n        return start + (cellSize - style.marginRight - imageWidth);\n    }\n    return start;\n};\n","import { CellLayout, CellPropertyFunction, RowOrColumnPropertyFunction, InternalSheetStyle, Rectangle, Selection, Clickable, Style, CellContentType, VisibleLayout, XY } from './types';\nimport { applyAlignment, resolveCellStyle } from './style';\nimport { normalizeSelection, isEmptySelection, isRowSelection, isColumnSelection } from './coordinate';\nimport { isInRange, isInRangeLeft, isInRangeRight, isInRangeCenter } from './util';\nimport { COLORS, SIZES, DEFAULT_CELL_STYLE, DEFAULT_COLUMN_HEADER_STYLE, HEADER_SELECTED_STYLE, HEADER_ACTIVE_STYLE, NO_STYLE, ONE_ONE } from './constants';\n\nexport const renderSheet = (\n    context: CanvasRenderingContext2D,\n    cellLayout: CellLayout,\n    visibleCells: VisibleLayout,\n\n    sheetStyle: InternalSheetStyle,\n    cellStyle: CellPropertyFunction<Style>,\n\n    selection: Rectangle,\n    secondarySelections: Selection[],\n\n    knobPosition: XY | null,\n    knobArea: Rectangle | null,\n    dragOffset: XY | null,\n    dropTarget: Rectangle | null,\n\n    columnHeaders: RowOrColumnPropertyFunction<CellContentType>,\n    columnHeaderStyle: RowOrColumnPropertyFunction<Style>,\n    displayData: CellPropertyFunction<CellContentType>,\n\n    dataOffset: XY,\n): Clickable[] => {\n    const {canvas} = context;\n    const {width, height} = canvas;\n    const {\n        hideGridlines,\n        hideRowHeaders,\n        hideColumnHeaders,\n        rowHeaderWidth,\n        columnHeaderHeight,\n        freezeColumns,\n        freezeRows,\n    } = sheetStyle;\n    const {columns, rows} = visibleCells;\n    const {\n        columnToPixel,\n        rowToPixel,\n    } = cellLayout;\n\n    const clickables: Clickable[] = [];\n\n    const freeze: XY = [freezeColumns, freezeRows];\n    const indent: XY = [rowHeaderWidth, columnHeaderHeight];\n\n    resizeCanvas(canvas);\n    context.clearRect(0, 0, width, height);\n    context.fillStyle = 'white';\n    context.fillRect(0, 0, width, height);\n\n    // Cell fill\n    for (const y of rows) {\n        for (const x of columns) {\n            const left = columnToPixel(x);\n            const right = columnToPixel(x, 1);\n            const top = rowToPixel(y);\n            const bottom = rowToPixel(y, 1);\n\n            const {fillColor} = cellStyle(x, y);\n            if (fillColor) {\n                context.fillStyle = fillColor;\n                context.fillRect(left, top, right - left, bottom - top);\n            }\n        }\n    }\n\n    const selectionActive = !isEmptySelection(selection);\n    const rowSelectionActive = isRowSelection(selection);\n    const columnSelectionActive = isColumnSelection(selection);\n\n    // Get selection range\n    const [selected, hideKnob] = resolveFrozenSelection(\n        selection,\n        cellLayout,\n        freeze,\n        indent,\n        dataOffset,\n    );\n\n    // Selection fill\n    if (selectionActive) {\n        const [[left, top], [right, bottom]] = selected;\n        context.fillStyle = COLORS.selectionBackground;\n        context.fillRect(left, top, right - left, bottom - top);\n    }\n\n    if (!hideRowHeaders) {\n        // Row header background\n        context.fillStyle = COLORS.headerBackground;\n        context.fillRect(0, 0, rowHeaderWidth, context.canvas.height);\n\n        // Row header selection shadow\n        if (selectionActive && !columnSelectionActive) {\n            const [[, top], [, bottom]] = selected;\n            context.fillStyle = COLORS.headerActive;\n            context.fillRect(0, top, rowHeaderWidth, bottom - top);\n        }\n    }\n\n    if (!hideColumnHeaders) {\n        // Column header background\n        context.fillStyle = COLORS.headerBackground;\n        context.fillRect(0, 0, context.canvas.width, columnHeaderHeight);\n\n        // Column header selection shadow\n        if (selectionActive && !rowSelectionActive) {\n            const [[left], [right]] = selected;\n            context.fillStyle = COLORS.headerActive;\n            context.fillRect(left, 0, right - left, columnHeaderHeight);\n        }\n    }\n\n    // Grid\n    context.strokeStyle = COLORS.gridLine;\n    context.lineWidth = 1;\n\n    const gridRight = hideGridlines ? rowHeaderWidth : context.canvas.width;\n    const gridBottom = hideGridlines ? columnHeaderHeight : context.canvas.height;\n\n    const drawGridLineX = (x: number, height: number) => {\n        context.beginPath();\n        context.moveTo(x - .5, 0);\n        context.lineTo(x - .5, height);\n        context.stroke();\n    };\n\n    const drawGridLineY = (y: number, width: number) => {\n        context.beginPath();\n        context.moveTo(0, y - .5);\n        context.lineTo(width, y - .5);\n        context.stroke();\n    };\n\n    drawGridLineX(rowHeaderWidth, context.canvas.height);\n    drawGridLineY(columnHeaderHeight, context.canvas.width);\n\n    for (const column of columns) {\n        const right = columnToPixel(column, 1);\n        drawGridLineX(right, gridBottom);\n    }\n\n    for (const row of rows) {\n        const bottom = rowToPixel(row, 1);\n        drawGridLineY(bottom, gridRight);\n    }\n\n    const [[minX, minY], [maxX, maxY]] = normalizeSelection(selection);\n\n    // Row header text\n    if (!hideRowHeaders) {\n        context.textBaseline = 'middle';\n        context.textAlign = 'center';\n        context.font = DEFAULT_CELL_STYLE.fontSize + 'px ' + DEFAULT_CELL_STYLE.fontFamily;\n        context.fillStyle = COLORS.headerText;\n\n        for (const row of rows) {\n            const content = `${row + 1}`;\n\n            // Row selection mode\n            // (this is separate from the header selection shadow because we only want to highlight visible headers)\n            const isActive = isInRange(row, minY, maxY);\n            const isSelected = (rowSelectionActive && !columnSelectionActive) && isActive;\n            const style = isSelected ? HEADER_SELECTED_STYLE : isActive ? HEADER_ACTIVE_STYLE : NO_STYLE;\n\n            const top = rowToPixel(row);\n            const bottom = rowToPixel(row, 1);\n\n            clickables.push(...renderCell(\n                context,\n                content,\n                style,\n                DEFAULT_COLUMN_HEADER_STYLE,\n                0,\n                top,\n                rowHeaderWidth,\n                bottom - top,\n            ));\n        }\n    }\n\n    // Column header text\n    if (!hideColumnHeaders) {\n        context.textBaseline = 'middle';\n        context.textAlign = 'center';\n\n        for (const column of columns) {\n            const content = columnHeaders(column) ?? excelHeaderString(column + 1);\n\n            // Column selection mode\n            // (this is separate from the header selection shadow because we only want to highlight visible headers)\n            const isActive = isInRange(column, minX, maxX);\n            const selectedStyle = (columnSelectionActive && !rowSelectionActive) && isActive\n                ? HEADER_SELECTED_STYLE : NO_STYLE;\n            const activeStyle = isActive ? HEADER_ACTIVE_STYLE : NO_STYLE;\n            const style = {\n                ...columnHeaderStyle(column),\n                ...activeStyle,\n                ...selectedStyle,\n            };\n\n            const left = columnToPixel(column);\n            const right = columnToPixel(column, 1);\n\n            clickables.push(...renderCell(\n                context,\n                content,\n                style,\n                DEFAULT_COLUMN_HEADER_STYLE,\n                left,\n                0,\n                right - left,\n                columnHeaderHeight\n            ));\n        }\n    }\n\n    // Selection outline\n    if (selectionActive) {\n        context.strokeStyle = COLORS.selectionBorder;\n        context.lineWidth = 2;\n\n        const [[left, top], [right, bottom]] = selected;\n        context.strokeRect(\n            left,\n            top,\n            right - left - 1,\n            bottom - top - 1,\n        );\n    }\n\n    for (const secondarySelection of secondarySelections) {\n        const selection = secondarySelection.span;\n        if (isEmptySelection(selection)) continue;\n\n        const [selected] = resolveFrozenSelection(\n            selection,\n            cellLayout,\n            freeze,\n            indent,\n            dataOffset,\n        );\n        const [[left, top], [right, bottom]] = selected;\n\n        context.strokeStyle = secondarySelection.color;\n        context.lineWidth = 1;\n        context.beginPath();\n        context.strokeRect(left - 1, top - 1, right - left + 1, bottom - top + 1);\n    }\n\n    // Knob drag outline\n    if (knobArea) {\n        let [[minX, minY], [maxX, maxY]] = normalizeSelection(knobArea);\n        const left = columnToPixel(minX);\n        const top = rowToPixel(minY);\n        const right = columnToPixel(maxX, 1);\n        const bottom = rowToPixel(maxY, 1);\n\n        context.strokeStyle = COLORS.knobAreaBorder;\n        context.setLineDash([3, 3]);\n        context.lineWidth = 1;\n\n        context.strokeRect(left - 1, top - 1, right - left + 1, bottom - top + 1);\n        context.setLineDash([]);\n    }\n\n    // Selection knob\n    if (knobPosition && !hideKnob) {\n        const [knobX, knobY] = knobPosition;\n        context.fillStyle = COLORS.selectionBorder;\n        context.fillRect(knobX - SIZES.knobArea * 0.5, knobY - SIZES.knobArea * 0.5, SIZES.knobArea, SIZES.knobArea);\n    }\n\n    // Drag ghost (pixels)\n    if (dragOffset) {\n        const [shiftX, shiftY] = dragOffset;\n        const [[left, top], [right, bottom]] = resolveSelection(selection, cellLayout);\n\n        context.fillStyle = COLORS.dragGhost;\n        context.fillRect(left + shiftX, top + shiftY, right - left, bottom - top);\n    }\n\n    // Drop target\n    if (dropTarget) {\n        let [[left, top], [right, bottom]] = resolveSelection(dropTarget, cellLayout);\n\n        context.strokeStyle = COLORS.dropTarget;\n        context.lineWidth = 2;\n\n        if (isColumnSelection(dropTarget)) {\n            right = left;\n        }\n        if (isRowSelection(dropTarget)) {\n            bottom = top;\n        }\n        context.strokeRect(left - 1, top - 1, right - left, bottom - top);\n    }\n\n    // Cell contents\n    context.textBaseline = 'middle';\n\n    for (const y of rows) {\n        for (const x of columns) {\n            const left = columnToPixel(x);\n            const right = columnToPixel(x, 1);\n            const top = rowToPixel(y);\n            const bottom = rowToPixel(y, 1);\n\n            const cellContent = displayData(x, y);\n            if (cellContent !== null && cellContent !== undefined) {\n                const style = cellStyle(x, y);\n                clickables.push(...renderCell(context, cellContent, style, DEFAULT_CELL_STYLE, left, top, right - left, bottom - top));\n            }\n        }\n    }\n\n    return clickables;\n};\n\nexport const renderCell = (\n    context: CanvasRenderingContext2D,\n    cellContent: CellContentType,\n    style: Style,\n    defaultCellStyle: Required<Style>,\n    xCoord: number,\n    yCoord: number,\n    cellWidth: number,\n    cellHeight: number\n): Clickable[] => {\n    const clickables: Clickable[] = [];\n\n    if (cellContent === null) {\n        return clickables;\n    }\n\n    const finalStyle = resolveCellStyle(style, defaultCellStyle);\n    context.fillStyle = finalStyle.color;\n    context.font = finalStyle.weight + ' ' + finalStyle.fontSize + 'px ' + finalStyle.fontFamily;\n    context.textAlign = finalStyle.textAlign;\n\n    const yy = Math.floor(yCoord + cellHeight * 0.5);\n\n    context.save();\n    context.beginPath();\n    context.rect(xCoord, yCoord, cellWidth, cellHeight);\n    context.clip();\n\n    if (finalStyle.backgroundColor !== '') {\n        context.fillStyle = finalStyle.backgroundColor;\n        context.fillRect(xCoord, yCoord, cellWidth, cellHeight);\n        context.fillStyle = finalStyle.color;\n    }\n\n    if (typeof cellContent === 'string' || typeof cellContent === 'number') {\n        const xx = applyAlignment(xCoord, cellWidth, finalStyle, 0);\n        const text = '' + cellContent;\n        context.fillText(text, xx, yy);\n    } else if (typeof cellContent === 'object') {\n        for (const obj of cellContent.items) {\n            let x = 0;\n            let y = 0;\n            let w = 0;\n            let h = 0;\n\n            if (obj.content instanceof HTMLImageElement) {\n                w = obj.width || cellWidth;\n                h = obj.height || cellHeight;\n\n                const finalX = applyAlignment(xCoord, cellWidth, finalStyle, w, obj.horizontalAlign);\n                x = finalX + obj.x;\n                y = yy + obj.y;\n\n                context.drawImage(obj.content, x, y, w, h);\n            } else if (typeof obj.content === 'string' || typeof obj.content === 'number') {\n                if (obj.horizontalAlign) {\n                    context.textAlign = obj.horizontalAlign;\n                }\n                const finalX = applyAlignment(xCoord, cellWidth, finalStyle, 0, obj.horizontalAlign);\n                const text = '' + obj.content;\n\n                const left = finalX + obj.x;\n                const top = yy + obj.y;\n                context.fillText(text, left, top);\n\n                const measure = context.measureText(text);\n                x = left - measure.actualBoundingBoxLeft;\n                y = top - measure.actualBoundingBoxAscent;\n                w = left + measure.actualBoundingBoxRight - x;\n                h = top + measure.actualBoundingBoxDescent - y;\n            }\n            if (obj.onClick) {\n                clickables.push({\n                    rect: [[x, y], [x + w, y + h]],\n                    obj,\n                });\n            }\n        }\n    }\n    context.restore();\n\n    return clickables;\n};\n\n// Resolve selection into a consistent rectangle, without dealing with frozen rows/columns\nconst resolveSelection = (\n    selection: Rectangle,\n    cellLayout: CellLayout,\n) => {\n    const {cellToPixel} = cellLayout;\n\n    const rowSelectionActive = isRowSelection(selection);\n    const columnSelectionActive = isColumnSelection(selection);\n\n    // Get selection range\n    const [min, max] = normalizeSelection(selection);\n\n    // Direct projection to visible grid\n    let [left, top] = cellToPixel(min);\n    let [right, bottom] = cellToPixel(max, ONE_ONE);\n\n    // Extend full row/column selection infinitely right/down\n    if (rowSelectionActive) {\n        right = 1e5;\n    }\n    if (columnSelectionActive) {\n        bottom = 1e5;\n    }\n\n    return [[left, top], [right, bottom]];\n};\n\n// Resolve selection into a consistent rectangle, handling edge cases around frozen rows/columns.\nconst resolveFrozenSelection = (\n    selection: Rectangle,\n    cellLayout: CellLayout,\n\n    freeze: XY,\n    indent: XY,\n    offset: XY,\n) => {\n    const {cellToPixel, columnToAbsolute, rowToAbsolute} = cellLayout;\n\n    const rowSelectionActive = isRowSelection(selection);\n    const columnSelectionActive = isColumnSelection(selection);\n\n    const [freezeX, freezeY] = freeze;\n    const [indentX, indentY] = indent;\n    const [offsetX, offsetY] = offset;\n\n    // Get selection range\n    const [min, max] = normalizeSelection(selection);\n    const [minX, minY] = min;\n    const [maxX, maxY] = max;\n\n    // Direct projection to visible grid\n    let [left, top] = cellToPixel(min);\n    let [right, bottom] = cellToPixel(max, ONE_ONE);\n\n    // Get frozen edge\n    const frozenX = columnToAbsolute(freezeX);\n    const frozenY = rowToAbsolute(freezeY);\n\n    let hideKnob = false;\n\n    // If the selection crosses the frozen edge, it needs to always cover the entire frozen area.\n    if (isInRangeCenter(freezeX, minX, maxX + 1)) {\n        const edge = indentX + frozenX;\n        if (right <= edge) {\n            right = edge;\n            hideKnob = true;\n        }\n    }\n    if (isInRangeCenter(freezeY, minY, maxY + 1)) {\n        const edge = indentY + frozenY;\n        if (bottom <= edge) {\n            bottom = edge;\n            hideKnob = true;\n        }\n    }\n\n    // If the selection starts/ends under the frozen area, treat as off-screen\n    if (isInRangeLeft(minX, freezeX, offsetX + freezeX)) {\n        left = -1e5;\n        if (isInRangeRight(maxX + 1, freezeX, offsetX + freezeX)) {\n            right = indentX;\n            hideKnob = true;\n        }\n    }\n    if (isInRangeLeft(minY, freezeY, offsetY + freezeY)) {\n        top = -1e5;\n        if (isInRangeRight(maxY + 1, freezeY, offsetY + freezeY)) {\n            bottom = indentY;\n            hideKnob = true;\n        }\n    }\n\n    if (rowSelectionActive && offsetX > 0) {\n        hideKnob = true;\n    }\n    if (columnSelectionActive && offsetY > 0) {\n        hideKnob = true;\n    }\n\n    // Extend full row/column selection infinitely right/down\n    if (rowSelectionActive) {\n        right = 1e5;\n    }\n    if (columnSelectionActive) {\n        bottom = 1e5;\n    }\n\n    return [\n        [[left, top], [right, bottom]],\n        hideKnob,\n    ] as [Rectangle, boolean];\n};\n\nconst resizeCanvas = (canvas: HTMLCanvasElement) => {\n    const { width, height } = canvas.getBoundingClientRect();\n    let { devicePixelRatio: ratio = 1 } = window;\n    if (ratio < 1) {\n        ratio = 1;\n    }\n    const newCanvasWidth = Math.round(width * ratio);\n    const newCanvasHeight = Math.round(height * ratio);\n\n    if (canvas.width !== newCanvasWidth || canvas.height !== newCanvasHeight) {\n        const context = canvas.getContext('2d');\n        if (context) {\n            canvas.width = newCanvasWidth;\n            canvas.height = newCanvasHeight;\n            context.scale(ratio, ratio);\n        }\n        return true;\n    }\n\n    return false;\n};\n\nconst excelHeaderString = (num: number) => {\n    let s = '';\n    let t = 0;\n    while (num > 0) {\n        t = (num - 1) % 26;\n        s = String.fromCharCode(65 + t) + s;\n        num = ((num - t) / 26) | 0;\n    }\n    return s || '';\n};\n","import styles from './styles.module.css';\nimport React, {\n    forwardRef,\n    useRef,\n    useImperativeHandle,\n    useLayoutEffect,\n    useState,\n    useMemo,\n    KeyboardEvent,\n    KeyboardEventHandler,\n    ReactElement,\n} from 'react';\nimport useResizeObserver from 'use-resize-observer';\n\nimport {\n    XY,\n    Rectangle,\n    CellLayout,\n    CellProperty,\n    CellContentType,\n    RowOrColumnProperty,\n    Selection,\n    Clickable,\n    Change,\n    SheetPointerEvent,\n    InternalSheetStyle,\n    InputStyle,\n    SheetStyle,\n    Style,\n} from './types';\n\nimport {\n    ARROW_KEYS,\n\tMAX_SEARCHABLE_INDEX,\n\tDEFAULT_CELL_STYLE,\n\tINITIAL_MAX_SCROLL,\n\tNO_CELL,\n    NO_CLICKABLES,\n\tNO_SELECTION,\n    NO_SELECTIONS,\n\tORIGIN,\n    ONE_ONE,\n} from './constants';\nimport {\n    normalizeSelection,\n    isSameSelection,\n    isRowSelection,\n    isColumnSelection,\n    isEmptySelection,\n    getDirectionStep,\n    maxXY,\n    addXY,\n} from './coordinate';\nimport { useMouse } from './mouse';\nimport { useScroll, scrollToCell } from './scroll';\nimport { useClipboardCopy, useClipboardPaste } from './clipboard';\nimport { makeLayoutCache, makeCellLayout } from './layout';\nimport { createCellProp, createRowOrColumnProp, findInDisplayData } from './props';\nimport { renderSheet } from './render';\nimport { resolveSheetStyle } from './style';\n\nexport type SheetInputProps = {\n    value: string,\n    autoFocus: boolean,\n    onKeyDown: KeyboardEventHandler<HTMLElement>,\n    onChange: (value: string) => void,\n    style: InputStyle,\n};\n\nexport type SheetProps = {\n    cellWidth?: RowOrColumnProperty<number>;\n    cellHeight?: RowOrColumnProperty<number>;\n    columnHeaders?: RowOrColumnProperty<CellContentType>;\n    columnHeaderStyle?: RowOrColumnProperty<Style>;\n    cellStyle?: CellProperty<Style>;\n    readOnly?: CellProperty<boolean>;\n    canSizeColumn?: RowOrColumnProperty<boolean>;\n    canSizeRow?: RowOrColumnProperty<boolean>;\n    canOrderColumn?: RowOrColumnProperty<boolean>;\n    canOrderRow?: RowOrColumnProperty<boolean>;\n    sourceData?: CellProperty<string | number | null>;\n    displayData?: CellProperty<CellContentType>;\n    editData?: CellProperty<string>;\n    editKeys?: CellProperty<string>;\n    sheetStyle?: SheetStyle;\n    secondarySelections?: Selection[];\n\n    cacheLayout?: boolean,\n    dontCommitEditOnSelectionChange?: boolean;\n\n    inputComponent?: (\n        x: number,\n        y: number,\n        props: SheetInputProps,\n        commitEditingCell?: () => void\n    ) => ReactElement | undefined;\n\n    onSelectionChanged?: (minX: number, minY: number, maxX: number, maxY: number) => void;\n    onRightClick?: (e: SheetPointerEvent) => void;\n    onChange?: (changes: Array<Change>) => void;\n    onColumnOrderChange?: (indices: number[], order: number) => void;\n    onRowOrderChange?: (indices: number[], order: number) => void;\n    onCellWidthChange?: (indices: number[], value: number) => void;\n    onCellHeightChange?: (indices: number[], value: number) => void;\n    onScrollChange?: (visibleRows: number[], visibleColumns: number[]) => void;\n};\n\nexport type SheetRef = CellLayout;\n\nconst Sheet = forwardRef<SheetRef, SheetProps>((props, ref) => {\n    const canvasRef = useRef<HTMLCanvasElement>(null);\n    const overlayRef = useRef<HTMLDivElement>(null);\n\n    const [maxScroll, setMaxScroll] = useState<XY>(INITIAL_MAX_SCROLL);\n    const [dataOffset, setDataOffset] = useState<XY>(ORIGIN);\n    // TODO: smooth scrolling\n    // const [pixelOffset, setPixelOffset] = useState<XY>(ORIGIN);\n\n    const [selection, setSelection] = useState<Rectangle>(NO_SELECTION);\n    const [knobArea, setKnobArea] = useState<Rectangle | null>(null);\n    const [dragOffset, setDragOffset] = useState<XY | null>(null);\n    const [dropTarget, setDropTarget] = useState<Rectangle | null>(null);\n    const [editCell, setEditCell] = useState<XY>(NO_CELL);\n\n    const [editValue, setEditValue] = useState<string | number>('');\n    const [arrowKeyCommitMode, setArrowKeyCommitMode] = useState(false);\n\n    const { width: canvasWidth = 3000, height: canvasHeight = 3000 } = useResizeObserver({ ref: canvasRef });\n\n    //    const freezeColumns = props.freezeColumns || 0;\n    //    const freezeRows = props.freezeRows || 0;\n\n    const cellWidth = useMemo(() => createRowOrColumnProp(props.cellWidth, 100), [props.cellWidth]);\n    const cellHeight = useMemo(() => createRowOrColumnProp(props.cellHeight, 22), [props.cellHeight]);\n    const columnHeaders = useMemo(() => createRowOrColumnProp(props.columnHeaders, null), [\n        props.columnHeaders,\n    ]);\n    const columnHeaderStyle = useMemo(() => createRowOrColumnProp(props.columnHeaderStyle, {}), [\n        props.columnHeaderStyle,\n    ]);\n\n    const canSizeColumn = useMemo(() => createRowOrColumnProp(props.canSizeColumn, true), [props.canSizeColumn]);\n    const canSizeRow = useMemo(() => createRowOrColumnProp(props.canSizeRow, true), [props.canSizeRow]);\n    const canOrderColumn = useMemo(() => createRowOrColumnProp(props.canOrderColumn, true), [props.canOrderColumn]);\n    const canOrderRow = useMemo(() => createRowOrColumnProp(props.canOrderRow, true), [props.canOrderRow]);\n\n    const cellReadOnly = useMemo(() => createCellProp(props.readOnly, false), [props.readOnly]);\n\n    const sourceData = useMemo(() => createCellProp(props.sourceData, null), [props.sourceData]);\n    const displayData = useMemo(() => createCellProp(props.displayData, ''), [props.displayData]);\n    const editData = useMemo(() => createCellProp(props.editData, ''), [props.editData]);\n    const editKeys = useMemo(() => createCellProp(props.editKeys, ''), [props.editKeys]);\n    const cellStyle = useMemo(() => createCellProp(props.cellStyle, DEFAULT_CELL_STYLE), [props.cellStyle]);\n\n    const sheetStyle: InternalSheetStyle = useMemo(() => resolveSheetStyle(props.sheetStyle), [props.sheetStyle]);\n    const secondarySelections = props.secondarySelections ?? NO_SELECTIONS;\n\n    const [maxScrollX, maxScrollY] = maxScroll;\n\n    const [editCellX, editCellY] = editCell;\n    const editMode = editCellX !== -1 && editCellY !== -1;\n\n    // Global layout for unscrolled/unfrozen grid\n    // Cached either per width/height pair, or permanently with invalidation on resize/reorder.\n    const columnLayout = useMemo(() => makeLayoutCache(cellWidth), [props.cacheLayout ? null : cellWidth]);\n    const rowLayout = useMemo(() => makeLayoutCache(cellHeight), [props.cacheLayout ? null : cellHeight]);\n    useMemo(() => {\n        if (!props.cacheLayout) return;\n        columnLayout.setSizer(cellWidth);\n        rowLayout.setSizer(cellHeight);\n    }, [props.cacheLayout, cellWidth, cellHeight])\n\n    // Virtual layout for indented/scrolled/frozen grid\n    const {freezeColumns, freezeRows, rowHeaderWidth, columnHeaderHeight} = sheetStyle;\n    const cellLayout = useMemo(\n        () => makeCellLayout(\n            [freezeColumns, freezeRows],\n            [rowHeaderWidth, columnHeaderHeight],\n            dataOffset,\n            columnLayout,\n            rowLayout,\n        ),\n        [freezeColumns, freezeRows, rowHeaderWidth, columnHeaderHeight, dataOffset, columnLayout, rowLayout]\n    );\n\n    // External component API\n    useImperativeHandle(ref, () => cellLayout, [cellLayout]);\n\n    // Build range of visible cells\n    const {getVisibleCells, cellToPixel, getVersion} = cellLayout;\n    const visibleCells = useMemo(\n        () => getVisibleCells([canvasWidth, canvasHeight]),\n        // Need to invalidate view if cached layout version changed\n        // eslint-disable-next-line\n        [getVisibleCells, canvasWidth, canvasHeight, getVersion()]\n    );\n\n    // Notify of viewport change\n    useLayoutEffect(() => {\n        if (props.onScrollChange) {\n            props.onScrollChange([...visibleCells.rows], [...visibleCells.columns]);\n        }\n    }, [visibleCells, props.onScrollChange]);\n\n    // Set selection with scrolling\n    const changeSelection = (newSelection: Rectangle, scrollToAnchor = true) => {\n        if (!isSameSelection(selection, newSelection)) {\n            setSelection(newSelection);\n        }\n\n        const {current: overlay} = overlayRef;\n        if (!overlay) return;\n\n        if (scrollToAnchor) {\n            const [anchor] = newSelection;\n            scrollToCell(\n                overlay,\n                anchor,\n                [canvasWidth, canvasHeight],\n                [freezeColumns, freezeRows],\n                dataOffset,\n                maxScroll,\n                cellLayout,\n                (dataOffset: XY, maxScroll: XY) => {\n                    setDataOffset(dataOffset);\n                    setMaxScroll(maxScroll);\n                },\n            );\n        }\n\n        if (props.onSelectionChanged) {\n            const [[minX, minY], [maxX, maxY]] = normalizeSelection(newSelection);\n            props.onSelectionChanged(minX, minY, maxX, maxY);\n        }\n    };\n\n    const commitEditingCell = (value?: string) => {\n        if (props.onChange) {\n            const [cellX, cellY] = editCell;\n            props.onChange([{ x: cellX, y: cellY, value: value !== undefined ? value : editValue }]);\n        }\n        setEditCell(NO_CELL);\n    };\n\n    const startEditingCell = (editCell: XY, arrowKeyCommitMode = false) => {\n        const [cellX, cellY] = editCell;\n        if (cellReadOnly(cellX, cellY)) {\n            return;\n        }\n\n        const editDataValue = editData(cellX, cellY);\n        let val = '';\n        if (editDataValue !== null && editDataValue !== undefined) {\n            val = editDataValue;\n        }\n        setEditCell(editCell);\n        setEditValue(val);\n        setArrowKeyCommitMode(arrowKeyCommitMode);\n    };\n\n    // Output from rendered layout is used to drive events on user content\n    const hitmapRef = useRef<Clickable[]>(NO_CLICKABLES);\n\n    // Textarea is used to hold text to copy, and receives pastes\n    const textAreaRef = useRef<HTMLTextAreaElement>(null);\n    useClipboardCopy(textAreaRef, selection, editMode, editData);\n    useClipboardPaste(textAreaRef, selection, changeSelection, props.onChange);\n\n    const onScroll = useScroll(dataOffset, maxScroll, cellLayout, setDataOffset, setMaxScroll);\n\n    const {mouseHandlers, knobPosition} = useMouse(\n        hitmapRef,\n        selection,\n        knobArea,\n        editMode,\n        editData,\n        sourceData,\n        canSizeColumn,\n        canSizeRow,\n        canOrderColumn,\n        canOrderRow,\n        cellLayout,\n        visibleCells,\n        sheetStyle,\n\n        startEditingCell,\n        commitEditingCell,\n        setKnobArea,\n        setDragOffset,\n        setDropTarget,\n        changeSelection,\n\n        props.cacheLayout ? columnLayout.clearAfter : undefined,\n        props.cacheLayout ? rowLayout.clearAfter : undefined,\n\n        props.onChange,\n        props.onColumnOrderChange,\n        props.onRowOrderChange,\n        props.onCellWidthChange,\n        props.onCellHeightChange,\n        props.onRightClick,\n        props.dontCommitEditOnSelectionChange,\n    );\n\n    useLayoutEffect(() => {\n        const {current: canvas} = canvasRef;\n        if (!canvas) {\n            return;\n        }\n\n        const context = canvas.getContext('2d');\n        if (!context) {\n            return;\n        }\n\n        const animationFrameId = window.requestAnimationFrame(() => {\n            hitmapRef.current = renderSheet(\n                context,\n                cellLayout,\n                visibleCells,\n                sheetStyle,\n                cellStyle,\n                selection,\n                secondarySelections,\n                knobPosition,\n                knobArea,\n                dragOffset,\n                dropTarget,\n                columnHeaders,\n                columnHeaderStyle,\n                displayData,\n\n                dataOffset,\n            );\n        });\n\n        return () => {\n            window.cancelAnimationFrame(animationFrameId);\n        };\n    }, [\n        cellLayout,\n        visibleCells,\n        sheetStyle,\n        cellStyle,\n        selection,\n        secondarySelections,\n\n        knobPosition,\n        knobArea,\n        dragOffset,\n        dropTarget,\n\n        columnHeaders,\n        columnHeaderStyle,\n        displayData,\n\n        dataOffset,\n    ]);\n\n    const onKeyDown = (e: KeyboardEvent) => {\n        if (e.key === 'Escape') {\n            setEditCell(NO_CELL);\n            return;\n        }\n\n        const direction = \n            e.key === 'Enter' ? 'down' : \n            e.key === 'Tab' ? 'right' : \n            arrowKeyCommitMode ? ARROW_KEYS[e.key] : \n            null;\n\n        if (direction) {\n            e.preventDefault();\n            const step = getDirectionStep(direction);\n            const head = maxXY(addXY(editCell, step), ORIGIN);\n            commitEditingCell();\n            changeSelection([head, head]);\n        }\n    };\n\n    const onGridKeyDown = (e: KeyboardEvent) => {\n        if (editMode && arrowKeyCommitMode && (e.key in ARROW_KEYS)) {\n            commitEditingCell();\n            return;\n        }\n\n        if ((e.metaKey || e.ctrlKey) && String.fromCharCode(e.which).toLowerCase() === 'v') {\n            return;\n        }\n\n        // copy\n        if ((e.metaKey || e.ctrlKey) && String.fromCharCode(e.which).toLowerCase() === 'c') {\n            const {current: textArea} = textAreaRef;\n            textArea?.select();\n            return;\n        }\n\n        if (e.key === 'Backspace' || e.key === 'Delete') {\n            let [[x1, y1], [x2, y2]] = normalizeSelection(selection);\n            if (isRowSelection(selection)) {\n                x1 = 0;\n                x2 = MAX_SEARCHABLE_INDEX;\n            }\n            if (isColumnSelection(selection)) {\n                y1 = 0;\n                y2 = MAX_SEARCHABLE_INDEX;\n            }\n\n            const changes: Change[] = [];\n            for (let y = y1; y <= y2; y++) {\n                for (let x = x1; x <= x2; x++) {\n                    changes.push({ x: x, y: y, value: null });\n                }\n            }\n            if (props.onChange) {\n                props.onChange(changes);\n            }\n            return;\n        }\n\n        // nothing selected\n        if (isEmptySelection(selection)) {\n            return;\n        }\n\n        if (\n            (e.keyCode >= 48 && e.keyCode <= 57) ||\n            (e.keyCode >= 96 && e.keyCode <= 105) ||\n            (e.keyCode >= 65 && e.keyCode <= 90) ||\n            e.key === 'Enter' ||\n            e.key === '-' ||\n            e.key === '.' ||\n            e.key === ','\n        ) {\n            const [cell] = selection;\n            const [cellX, cellY] = cell;\n            if (cellReadOnly(cellX, cellY)) {\n                e.preventDefault(); // so we dont get keystrokes inside the text area\n                return;\n            }\n\n            startEditingCell(cell, e.key !== 'Enter');\n            return;\n        }\n\n        if (e.key in ARROW_KEYS) {\n            let [anchor, head] = selection;\n\n            const direction = ARROW_KEYS[e.key];\n            const step = getDirectionStep(direction);\n\n            if (e.metaKey || e.ctrlKey) {\n                head = findInDisplayData(displayData, head, direction);\n            }\n            else {\n                head = maxXY(addXY(head, step), ORIGIN);\n            }\n            if (!e.shiftKey) {\n                anchor = head;\n            }\n            changeSelection([anchor, head]);\n            return;\n        }\n\n        e.preventDefault();\n    };\n\n    const editKey = editKeys ? editKeys(...editCell) : '';\n    const [lastEditKey, setLastEditKey] = useState(editKey);\n    if (editMode && lastEditKey !== editKey) {\n        setLastEditKey(editKey);\n        setEditCell(NO_CELL);\n    }\n\n    let editTextPosition = ORIGIN;\n    let editTextWidth = 0;\n    let editTextHeight = 0;\n    let editTextTextAlign: 'right' | 'left' | 'center' = 'right';\n    if (editMode) {\n        const style = cellStyle(...editCell);\n        editTextPosition = cellToPixel(editCell);\n        editTextPosition = addXY(editTextPosition, ONE_ONE);\n        editTextWidth = cellWidth(editCellX) - 3;\n        editTextHeight = cellHeight(editCellY) - 3;\n        editTextTextAlign = style.textAlign || DEFAULT_CELL_STYLE.textAlign || 'left';\n    }\n\n    const [textX, textY] = editTextPosition;\n    const inputProps = {\n        value: editValue,\n        autoFocus: true,\n        onKeyDown: onKeyDown,\n        style: {\n            position: 'absolute',\n            left: textX,\n            top: textY,\n            padding: '0px 4px',\n            width: editTextWidth,\n            height: editTextHeight,\n            outline: 'none',\n            border: 'none',\n            textAlign: editTextTextAlign,\n            color: 'black',\n            fontSize: DEFAULT_CELL_STYLE.fontSize,\n            fontFamily: 'sans-serif',\n        } as InputStyle,\n    };\n\n    const input = props.inputComponent?.(\n        editCellX,\n        editCellY,\n        { ...inputProps, onChange: setEditValue } as SheetInputProps,\n        commitEditingCell\n    );\n\n    let overlayDivClassName = styles.sheetscroll;\n    const overlayDivStyles: React.CSSProperties = {\n        position: 'absolute',\n        width: '100%',\n        height: '100%',\n        top: 0,\n        left: 0,\n        overflow: 'scroll',\n        borderBottom: '1px solid #ddd',\n    };\n    const canvasStyles: React.CSSProperties = {\n        width: 'calc(100% - 14px)',\n        height: 'calc(100% - 15px)',\n        outline: '1px solid #ddd', // find another better solution ?\n    };\n\n    if (sheetStyle.hideScrollBars) {\n        delete canvasStyles['outline'];\n        delete overlayDivStyles['borderBottom'];\n        overlayDivClassName = '';\n        canvasStyles.width = 'calc(100%)';\n    }\n\n    return (\n        <div style={{ position: 'relative', height: '100%', overflow: 'hidden' }}>\n            <canvas style={canvasStyles} ref={canvasRef} />\n            <div\n                ref={overlayRef}\n                {...mouseHandlers}\n                onScroll={onScroll}\n                className={overlayDivClassName}\n                style={overlayDivStyles}\n            >\n                <div\n                    style={{\n                        position: 'absolute',\n                        left: 0,\n                        top: 0,\n                        width: 1,\n                        height: maxScrollY + 2000,\n                        backgroundColor: 'rgba(0,0,0,0.0)',\n                    }}\n                ></div>\n                <div\n                    style={{\n                        position: 'absolute',\n                        left: 0,\n                        top: 0,\n                        width: maxScrollX + 5000,\n                        height: 1,\n                        backgroundColor: 'rgba(0,0,0,0.0)',\n                    }}\n                ></div>\n            </div>\n            <textarea\n                style={{ position: 'absolute', top: 0, left: 0, width: 1, height: 1, opacity: 0.01 }}\n                ref={textAreaRef}\n                autoComplete=\"off\"\n                autoCorrect=\"off\"\n                autoCapitalize=\"off\"\n                spellCheck=\"false\"\n                onFocus={(e) => e.target.select()}\n                tabIndex={0}\n                onKeyDown={onGridKeyDown}\n            ></textarea>\n            {editMode &&\n                (input !== undefined ? (\n                    input\n                ) : (\n                    <input\n                        {...inputProps}\n                        type=\"text\"\n                        onFocus={(e) => e.target.select()}\n                        onChange={(e) => setEditValue(e.target.value)}\n                    />\n                ))}\n        </div>\n    );\n});\n\nexport default Sheet;\n","import { UIEvent, useCallback } from 'react';\nimport { XY, CellLayout } from './types';\nimport { isSameXY, maxXY, mulXY } from './coordinate';\nimport { ONE_ONE } from './constants';\n\nexport const useScroll = (\n    offset: XY,\n    maxScroll: XY,\n    cellLayout: CellLayout,\n    onOffsetChange?: (offset: XY) => void,\n    onMaxScrollChange?: (maxScroll: XY) => void,\n) => {\n    return useCallback((e: UIEvent) => {\n        if (!e.target || !(e.target instanceof Element)) {\n            return;\n        }\n\n        const xy: XY = [\n            e.target.scrollLeft,\n            e.target.scrollTop,\n        ];\n\n        const {absoluteToCell} = cellLayout;\n        const cell = absoluteToCell(xy);\n        if (!isSameXY(cell, offset)) {\n            onOffsetChange?.(cell);\n        }\n\n        // TODO: smooth scrolling\n        // const pixel = subXY(cellToAbsolute(cell), xy);\n        //if (!isSameXY(pixel, pixelOffset)) {\n        //     setPixelOffset(pixel);\n        //}\n\n        const [x, y] = xy;\n        const [maxScrollX, maxScrollY] = maxScroll;\n        const growX = (maxScrollX < x + 1) ? 1.5 : 1;\n        const growY = (maxScrollY < y + 1) ? 1.5 : 1;\n        if (growX > 1 || growY > 1) {\n            onMaxScrollChange?.(mulXY(maxScroll, [growX, growY]));\n        }\n    }, [cellLayout, onOffsetChange, onMaxScrollChange]);\n};\n\nexport const scrollToCell = (\n    element: HTMLDivElement,\n    cell: XY,\n    view: XY,\n    freeze: XY,\n    offset: XY,\n    maxScroll: XY,\n    cellLayout: CellLayout,\n    callback: (offset: XY, maxScroll: XY) => void,\n) => {\n    const [x, y] = cell;\n    const [w, h] = view;\n    const [offsetX, offsetY] = offset;\n\n    const {cellToAbsolute, cellToPixel, columnToPixel, rowToPixel} = cellLayout;\n    const [frozenX, frozenY] = cellToAbsolute(freeze);\n    const [left, top] = cellToPixel(cell);\n    const [right, bottom] = cellToPixel(cell, ONE_ONE);\n\n    let [newX, newY] = offset;\n\n    // If moving left/up, scroll to head\n    if (left <= frozenX) {\n        newX = x;\n    }\n    if (top <= frozenY) {\n        newY = y;\n    }\n\n    // If moving right/down, scroll cell by cell until right/bottom of cell is visible\n    if (right > w) {\n        let edge = right - w + columnToPixel(newX);\n        while (columnToPixel(++newX) < edge) {};\n    }\n    if (bottom > h) {\n        let edge = bottom - h + rowToPixel(newY);\n        while (rowToPixel(++newY) < edge) {};\n    }\n\n    // Don't scroll on infinite axis\n    const newOffset: XY = [\n        newX >= 0 ? newX : offsetX,\n        newY >= 0 ? newY : offsetY,\n    ];\n\n    if (!isSameXY(newOffset, offset)) {\n        const scroll = cellToAbsolute(newOffset);\n\n        callback(newOffset, maxXY(maxScroll, scroll));\n        setTimeout(() => {\n            const [scrollX, scrollY] = scroll;\n            element.scrollLeft = scrollX;\n            element.scrollTop = scrollY;\n        });\n    }\n};\n","import React, { useState } from 'react';\nimport Sheet from 'sheet-happens';\nimport 'sheet-happens/dist/index.css';\n\nconst initialDataBig = [];\nfor (let row = 0; row < 1000; row++) {\n    const r = [];\n    for (let col = 0; col < 100; col++) {\n        r.push(`Row: ${row}, Col: ${col}`);\n    }\n    initialDataBig.push(r);\n}\n\nconst initialDataBasic = [\n    ['First', 'Second', 'Third', 'Fourth', 'Fifth', 'Sixth'],\n    [1, 2, 3, 4, 5, 6],\n    [1, 2, 3, 4, 5, 6],\n    [1, 2, 3, 4, 5, 6],\n    [1, 2, 3, 4, 5, 6],\n    [1, 2, 3, 4, 5, 6],\n    [1, 2, 3, 4, 5, 6],\n    [1, 2, 3, 4, 5, 6],\n    [1, 2, 3, 4, 5, 6],\n];\n\nconst initialDataFormatting = [];\nfor (let row = 0; row < 1000; row++) {\n    const r = [];\n    for (let col = 0; col < 100; col++) {\n        r.push(Math.random() * 1000000);\n    }\n    initialDataFormatting.push(r);\n}\n\nconst triangleDown = new Image();\ntriangleDown.src =\n    'data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgd2lkdGg9IjEwMCIgaGVpZ2h0PSIxMDAiDQoJIHZpZXdCb3g9IjAgMCAxMDAgMTAwIiBvdmVyZmxvdz0idmlzaWJsZSIgPg0KPHBvbHlnb24gcG9pbnRzPSIwLDAgMTAwLDAgNTAsMTAwIiBzdHlsZT0iZmlsbDojOTk5OTk5OyIvPg0KPC9zdmc+DQo=';\ntriangleDown.width = 10;\ntriangleDown.height = 10;\n\nexport const DEFAULT_CELL_WIDTH = 100;\nexport const DEFAULT_CELL_HEIGHT = 22;\n\nexport function useWidthHeightControl(\n    initialWidths = [],\n    initialHeights = [],\n    getColumnOrder = (i: number) => i,\n    getRowOrder = (i: number) => i,\n) {\n    const [cellWidth, setCellWidth] = useState(initialWidths);\n    const [cellHeight, setCellHeight] = useState(initialHeights);\n\n    const onCellWidthChange = (indices, newWidth) => {\n        const cw = [...cellWidth];\n        for (const order of indices) {\n            const idx = getColumnOrder(order);\n            if (idx > cw.length) {\n                for (let i = cw.length; i <= idx; i++) {\n                    cw.push(DEFAULT_CELL_WIDTH);\n                }\n            }\n            cw[idx] = newWidth;\n        }\n        setCellWidth(cw);\n    };\n\n    const onCellHeightChange = (indices, newHeight) => {\n        const ch = [...cellHeight];\n        for (const order of indices) {\n            const idx = getRowOrder(order);\n            if (idx > ch.length) {\n                for (let i = ch.length; i <= idx; i++) {\n                    ch.push(DEFAULT_CELL_HEIGHT);\n                }\n            }\n            ch[idx] = newHeight;\n        }\n        setCellHeight(ch);\n    };\n\n    const cw = (x: number) => cellWidth[getColumnOrder(x)] ?? DEFAULT_CELL_WIDTH;\n    const ch = (y: number) => cellHeight[getRowOrder(y)] ?? DEFAULT_CELL_HEIGHT;\n\n    return { onCellWidthChange, onCellHeightChange, cellWidth: cw, cellHeight: ch };\n}\n\nexport function useOrderControl(initialColumns = [], initialRows = []) {\n    const [columnOrder, setColumnOrder] = useState(initialColumns);\n    const [rowOrder, setRowOrder] = useState(initialRows);\n\n    const getColumnOrder = (x: number) => columnOrder[x] ?? x;\n    const getRowOrder = (y: number) => rowOrder[y] ?? y;\n\n    const onColumnOrderChange = (indices: number[], order: number) => {\n        const co = [...columnOrder];\n\n        const min = indices[0];\n        const n = Math.max(order + indices.length, indices.reduce((a, b) => Math.max(a, b)));\n        while (co.length < n) co.push(co.length);\n\n        co.splice(min, indices.length);\n        co.splice(order, 0, ...indices.map(i => getColumnOrder(i)));\n        setColumnOrder(co);\n    };\n\n    const onRowOrderChange = (indices: number[], order: number) => {\n        const ro = [...rowOrder];\n\n        const min = indices[0];\n        const n = Math.max(order + indices.length, indices.reduce((a, b) => Math.max(a, b)));\n        while (ro.length < n) ro.push(ro.length);\n\n        ro.splice(min, indices.length);\n        ro.splice(order, 0, ...indices.map(i => getRowOrder(i)));\n        setRowOrder(ro);\n    };\n\n    return { getColumnOrder, getRowOrder, onColumnOrderChange, onRowOrderChange };\n}\n\nexport function SheetBoxHeader() {\n    const [data, setData] = useState(initialDataBig);\n\n    const { onColumnOrderChange, onRowOrderChange, getColumnOrder, getRowOrder } = useOrderControl();\n    const { onCellWidthChange, onCellHeightChange, cellWidth, cellHeight } = useWidthHeightControl([], [], getColumnOrder, getRowOrder);\n\n    const onSelectionChanged = (x1, y1, x2, y2) => {};\n    const onRightClick = () => {};\n    const columnHeaders = ['A', 'B', 'C'];\n    const cellStyle = (x, y) => {\n        return {};\n    };\n\n    const editData = (x, y) => {\n        return data?.[getRowOrder(y)]?.[getColumnOrder(x)];\n    };\n    const displayData = (x, y) => {\n        return data?.[getRowOrder(y)]?.[getColumnOrder(x)];\n    };\n    const sourceData = (x, y) => {\n        return data?.[getRowOrder(y)]?.[getColumnOrder(x)];\n    };\n    const editKeys = (x, y) => {\n        return `${x},${y}`;\n    };\n\n    const onChange = (changes) => {\n        const newData = [...data];\n        for (const change of changes) {\n            const cx = getColumnOrder(change.x);\n            const cy = getRowOrder(change.y);\n            if (!newData[cy]) {\n                newData[cy] = [];\n            }\n            newData[cy][cx] = change.value;\n        }\n        setData(newData);\n    };\n\n    const isReadOnly = (x, y) => {\n        return false;\n    };\n\n    return (\n        <div className=\"sheet-box\">\n            <Sheet\n                onSelectionChanged={onSelectionChanged}\n                onRightClick={onRightClick}\n                columnHeaders={columnHeaders}\n                cellStyle={cellStyle}\n                editData={editData}\n                displayData={displayData}\n                sourceData={sourceData}\n                cellWidth={cellWidth}\n                cellHeight={cellHeight}\n                onChange={onChange}\n                readOnly={isReadOnly}\n                onCellWidthChange={onCellWidthChange}\n                onCellHeightChange={onCellHeightChange}\n                onColumnOrderChange={onColumnOrderChange}\n                onRowOrderChange={onRowOrderChange}\n                editKeys={editKeys}\n                cacheLayout\n            />\n        </div>\n    );\n}\n\nexport function SheetBoxBasic() {\n    const [data, setData] = useState(JSON.parse(JSON.stringify(initialDataBasic)));\n    const { onColumnOrderChange, onRowOrderChange, getColumnOrder, getRowOrder } = useOrderControl();\n    const { onCellWidthChange, onCellHeightChange, cellWidth, cellHeight } = useWidthHeightControl([], [], getColumnOrder, getRowOrder);\n\n    const onSelectionChanged = (x1, y1, x2, y2) => {};\n    const onRightClick = () => {};\n    const columnHeaders = ['A', 'B', 'C'];\n    const cellStyle = (x, y) => {\n        return {};\n    };\n\n    const editData = (x, y) => {\n        return data?.[getRowOrder(y)]?.[getColumnOrder(x)];\n    };\n    const displayData = (x, y) => {\n        return data?.[getRowOrder(y)]?.[getColumnOrder(x)];\n    };\n    const sourceData = (x, y) => {\n        return data?.[getRowOrder(y)]?.[getColumnOrder(x)];\n    };\n\n    const onChange = (changes) => {\n        const newData = [...data];\n        for (const change of changes) {\n            const cx = getColumnOrder(change.x);\n            const cy = getRowOrder(change.y);\n            if (!newData[cy]) {\n                newData[cy] = [];\n            }\n            newData[cy][cx] = change.value;\n        }\n        setData(newData);\n    };\n\n    const isReadOnly = (x, y) => {\n        return false;\n    };\n\n    return (\n        <div className=\"sheet-box\">\n            <Sheet\n                onSelectionChanged={onSelectionChanged}\n                onRightClick={onRightClick}\n                columnHeaders={columnHeaders}\n                cellStyle={cellStyle}\n                editData={editData}\n                displayData={displayData}\n                sourceData={sourceData}\n                cellWidth={cellWidth}\n                cellHeight={cellHeight}\n                onChange={onChange}\n                readOnly={isReadOnly}\n                onCellWidthChange={onCellWidthChange}\n                onCellHeightChange={onCellHeightChange}\n                onColumnOrderChange={onColumnOrderChange}\n                onRowOrderChange={onRowOrderChange}\n                cacheLayout\n            />\n        </div>\n    );\n}\n\nconst faCheck = new Image();\nfaCheck.src =\n    'data:image/svg+xml;base64,PHN2ZyBhcmlhLWhpZGRlbj0idHJ1ZSIgZm9jdXNhYmxlPSJmYWxzZSIgZGF0YS1wcmVmaXg9ImZhcyIgZGF0YS1pY29uPSJjaGVjay1jaXJjbGUiIGNsYXNzPSJzdmctaW5saW5lLS1mYSBmYS1jaGVjay1jaXJjbGUgZmEtdy0xNiIgcm9sZT0iaW1nIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1MTIgNTEyIj48cGF0aCBmaWxsPSIjMGFkNjZiIiBkPSJNNTA0IDI1NmMwIDEzNi45NjctMTExLjAzMyAyNDgtMjQ4IDI0OFM4IDM5Mi45NjcgOCAyNTYgMTE5LjAzMyA4IDI1NiA4czI0OCAxMTEuMDMzIDI0OCAyNDh6TTIyNy4zMTQgMzg3LjMxNGwxODQtMTg0YzYuMjQ4LTYuMjQ4IDYuMjQ4LTE2LjM3OSAwLTIyLjYyN2wtMjIuNjI3LTIyLjYyN2MtNi4yNDgtNi4yNDktMTYuMzc5LTYuMjQ5LTIyLjYyOCAwTDIxNiAzMDguMTE4bC03MC4wNTktNzAuMDU5Yy02LjI0OC02LjI0OC0xNi4zNzktNi4yNDgtMjIuNjI4IDBsLTIyLjYyNyAyMi42MjdjLTYuMjQ4IDYuMjQ4LTYuMjQ4IDE2LjM3OSAwIDIyLjYyN2wxMDQgMTA0YzYuMjQ5IDYuMjQ5IDE2LjM3OSA2LjI0OSAyMi42MjguMDAxeiI+PC9wYXRoPjwvc3ZnPg==';\nfaCheck.width = 16;\nfaCheck.height = 16;\n\nexport function SheetBoxStyle() {\n    const [data, setData] = useState(JSON.parse(JSON.stringify(initialDataBasic)));\n    const { onCellWidthChange, onCellHeightChange, cellWidth, cellHeight } = useWidthHeightControl();\n\n    const onSelectionChanged = (x1, y1, x2, y2) => {};\n    const onRightClick = () => {};\n    const columnHeaders = (index) => {\n        if (index === 0) {\n            return {\n                items: [\n                    {\n                        content: 'A',\n                        x: 0,\n                        y: 0,\n                        horizontalAlign: 'center',\n                    },\n                    {\n                        content: triangleDown,\n                        x: 0,\n                        y: -6,\n                        width: 12,\n                        height: 12,\n                        horizontalAlign: 'right',\n                        onClick: () => {\n                            console.log('click');\n                        },\n                    },\n                ],\n            };\n        } else {\n            return null;\n        }\n    };\n    const colors = ['#f00', '#0f0', '#00f', '#000'];\n    const alignment = ['left', 'right', 'center'];\n    const weight = ['normal', 'bold', 'lighter'];\n    const marginRight = [0, 0, 0, 0, 20];\n    const cellStyle = (x, y) => {\n        if (x === 0 || y === 0) {\n            return {\n                fillColor: '#6DA2FB22',\n                marginRight: 10,\n            };\n        }\n        return {\n            color: colors[y % 4],\n            textAlign: alignment[x % 3],\n            marginRight: marginRight[x % 5],\n            weight: weight[y % 3],\n        };\n    };\n    const editData = (x, y) => {\n        return data?.[y]?.[x];\n    };\n    const incrementCell = (x, y) => {\n        const newData = [...data];\n        if (newData[y] && newData[y][x] !== undefined) {\n            newData[y][x] += 1;\n        }\n        setData(newData);\n    };\n    const displayData = (x, y) => {\n        if (x === 0 && y > 0 && y < 9) {\n            return {\n                items: [\n                    {\n                        content: faCheck,\n                        x: 0,\n                        y: -8,\n                        width: 16,\n                        height: 16,\n                        horizontalAlign: 'right',\n                        onClick: () => {\n                            incrementCell(x, y);\n                        },\n                    },\n                    {\n                        content: data?.[y]?.[x],\n                        x: 0,\n                        y: 0,\n                        horizontalAlign: 'left',\n                    },\n                ],\n            };\n        }\n        return data?.[y]?.[x];\n    };\n    const sourceData = (x, y) => {\n        return data?.[y]?.[x];\n    };\n    const onChange = (changes) => {\n        const newData = [...data];\n        for (const change of changes) {\n            if (!newData[change.y]) {\n                newData[change.y] = [];\n            }\n            newData[change.y][change.x] = change.value;\n        }\n        setData(newData);\n    };\n\n    const isReadOnly = (x, y) => {\n        return false;\n    };\n\n    return (\n        <div className=\"sheet-box\">\n            <Sheet\n                onSelectionChanged={onSelectionChanged}\n                onRightClick={onRightClick}\n                columnHeaders={columnHeaders}\n                cellStyle={cellStyle}\n                editData={editData}\n                displayData={displayData}\n                sourceData={sourceData}\n                cellWidth={cellWidth}\n                cellHeight={cellHeight}\n                onChange={onChange}\n                readOnly={isReadOnly}\n                onCellWidthChange={onCellWidthChange}\n                onCellHeightChange={onCellHeightChange}\n                sheetStyle={{\n                    freezeColumns: 1,\n                    freezeRows: 1,\n                }}\n                cacheLayout\n            />\n        </div>\n    );\n}\n\nexport function SheetBoxFormatting() {\n    const [data, setData] = useState(initialDataFormatting);\n    const { onCellWidthChange, onCellHeightChange, cellWidth, cellHeight } = useWidthHeightControl();\n\n    const cellStyle = (x, y) => {\n        return {};\n    };\n    const editData = (x, y) => {\n        return data?.[y]?.[x];\n    };\n    const displayData = (x, y) => {\n        return data?.[y]?.[x]?.toFixed?.(2);\n    };\n    const sourceData = (x, y) => {\n        return data?.[y]?.[x];\n    };\n\n    const onChange = (changes) => {\n        const newData = [...data];\n        for (const change of changes) {\n            if (!newData[change.y]) {\n                newData[change.y] = [];\n            }\n            newData[change.y][change.x] = Number(change.value);\n        }\n        setData(newData);\n    };\n\n    const isReadOnly = (x, y) => {\n        return false;\n    };\n\n    return (\n        <div className=\"sheet-box\">\n            <Sheet\n                cellStyle={cellStyle}\n                editData={editData}\n                displayData={displayData}\n                sourceData={sourceData}\n                cellWidth={cellWidth}\n                cellHeight={cellHeight}\n                onChange={onChange}\n                readOnly={isReadOnly}\n                onCellWidthChange={onCellWidthChange}\n                onCellHeightChange={onCellHeightChange}\n                cacheLayout\n            />\n        </div>\n    );\n}\n\nexport function SheetBoxVeryBigData() {\n    const [loadingStatus, setLoadingStatus] = useState('initial');\n    const [data, setData] = useState([]);\n    const { onCellWidthChange, onCellHeightChange, cellWidth, cellHeight } = useWidthHeightControl();\n\n    const loadClick = (e) => {\n        e.preventDefault();\n        setLoadingStatus('loading');\n        fetch('./out.json')\n            .then((response) => {\n                return response.json();\n            })\n            .then((dataset) => {\n                setData(dataset);\n                setLoadingStatus('done');\n            });\n    };\n\n    const cellStyle = (x, y) => {\n        if (y === 0) {\n            return {\n                weight: 'bold',\n                fontSize: 14,\n            };\n        }\n        if (x === 4) {\n            return {\n                textAlign: 'right',\n            };\n        } else if (x === 1) {\n            return {\n                weight: 'bold',\n                color: '#3b85ff',\n            };\n        } else if (x === 2) {\n            return {\n                color: '#fc3bff',\n            };\n        }\n        return {};\n    };\n    const editData = (x, y) => {\n        return data?.[y]?.[x];\n    };\n    const displayData = (x, y) => {\n        if (x === 4 && y > 0) {\n            if (data && data[y] && data[y][x]) {\n                return Number(data[y][x]).toFixed(2);\n            } else {\n                return '';\n            }\n        }\n        return data?.[y]?.[x];\n    };\n    const sourceData = (x, y) => {\n        return data?.[y]?.[x];\n    };\n\n    const onChange = (changes) => {\n        const newData = [...data];\n        for (const change of changes) {\n            if (!newData[change.y]) {\n                newData[change.y] = [];\n            }\n            newData[change.y][change.x] = change.value;\n        }\n        setData(newData);\n    };\n\n    const isReadOnly = (x, y) => {\n        return false;\n    };\n\n    const headerStyle = (index) => {\n        const r = ((index * 2421) % 255).toString(16).padStart(2, '0');\n        const g = ((index * 3215) % 255).toString(16).padStart(2, '0');\n        const b = ((index * 1243) % 255).toString(16).padStart(2, '0');\n        const color = `#${r}${g}${b}55`;\n        return {\n            backgroundColor: color,\n        };\n    };\n\n    const columnHeaders = (index) => {\n        return '' + index;\n    };\n\n    return (\n        <>\n            {loadingStatus === 'initial' ?\n                (\n                    // eslint-disable-next-line jsx-a11y/anchor-is-valid\n                    <a href=\"#\" onClick={loadClick}>\n                        Load global database of power plants\n                    </a>\n                ) : loadingStatus === 'loading' ? (\n                    'Loading...'\n                ) : null\n            }\n            <div className=\"sheet-box\">\n                <Sheet\n                    cellStyle={cellStyle}\n                    editData={editData}\n                    displayData={displayData}\n                    sourceData={sourceData}\n                    cellWidth={cellWidth}\n                    cellHeight={cellHeight}\n                    onChange={onChange}\n                    readOnly={isReadOnly}\n                    onCellWidthChange={onCellWidthChange}\n                    onCellHeightChange={onCellHeightChange}\n                    columnHeaderStyle={headerStyle}\n                    columnHeaders={columnHeaders}\n                    sheetStyle={{\n                        freezeColumns: 0,\n                        freezeRows: 1,\n                    }}\n                    cacheLayout\n                />\n            </div>\n        </>\n    );\n}\n\nconst customInputOptions = ['First', 'Second', 'Third', 'Fourth', 'Fifth'];\nconst customInputOptions2 = ['Sixth', 'Seventh', 'Eighth', 'Ninth', 'Tenth'];\nconst customInputData = [\n    customInputOptions,\n    customInputOptions2,\n    customInputOptions,\n    customInputOptions2,\n    customInputOptions,\n    customInputOptions2,\n    customInputOptions,\n];\n\nexport function SheetBoxCustomInput() {\n    const [data, setData] = useState(JSON.parse(JSON.stringify(customInputData)));\n    const { onCellWidthChange, onCellHeightChange, cellWidth, cellHeight } = useWidthHeightControl();\n\n    const onSelectionChanged = (x1, y1, x2, y2) => {};\n    const onRightClick = () => {};\n    const columnHeaders = ['A', 'B', 'C'];\n    const cellStyle = (x, y) => {\n        return {};\n    };\n    const editData = (x, y) => {\n        return data?.[y]?.[x];\n    };\n    const displayData = (x, y) => {\n        return data?.[y]?.[x];\n    };\n    const sourceData = (x, y) => {\n        return data?.[y]?.[x];\n    };\n\n    const onChange = (changes) => {\n        const newData = [...data];\n        for (const change of changes) {\n            if (!newData[change.y]) {\n                newData[change.y] = [];\n            }\n            newData[change.y][change.x] = change.value;\n        }\n        setData(newData);\n    };\n\n    const isReadOnly = (x, y) => {\n        return false;\n    };\n\n    return (\n        <div className=\"sheet-box\">\n            <Sheet\n                onSelectionChanged={onSelectionChanged}\n                onRightClick={onRightClick}\n                columnHeaders={columnHeaders}\n                cellStyle={cellStyle}\n                editData={editData}\n                displayData={displayData}\n                sourceData={sourceData}\n                cellWidth={cellWidth}\n                cellHeight={cellHeight}\n                onChange={onChange}\n                readOnly={isReadOnly}\n                onCellWidthChange={onCellWidthChange}\n                onCellHeightChange={onCellHeightChange}\n                inputComponent={CustomInput}\n                cacheLayout\n            />\n        </div>\n    );\n}\n\nfunction CustomInput(x, y, inputProps, commitEditingCell) {\n    const clickHandler = (value) => {\n        commitEditingCell(value);\n    };\n\n    return (\n        <div style={{ ...inputProps.style, backgroundColor: '#fff' }}>\n            <div style={{ border: '1px solid #ddd', boxShadow: '3px 5px 5px #ddd' }}>\n                {(y % 2 ? customInputOptions2 : customInputOptions).map((opt) => {\n                    return (\n                        <CustomOption\n                            key={opt}\n                            opt={opt}\n                            value={inputProps.value}\n                            clickHandler={() => clickHandler(opt)}\n                        />\n                    );\n                })}\n            </div>\n        </div>\n    );\n}\n\nfunction CustomOption({ opt, value, clickHandler }) {\n    const [hover, setHover] = useState(false);\n\n    return (\n        <div\n            onMouseEnter={() => {\n                setHover(true);\n            }}\n            onMouseLeave={() => {\n                setHover(false);\n            }}\n            style={{\n                backgroundColor: value === opt || hover ? '#f6f6f6' : '#fff',\n                padding: '5px 10px',\n                cursor: 'pointer',\n            }}\n            value={opt}\n            onClick={() => clickHandler(opt)}\n        >\n            {opt}\n        </div>\n    );\n}\n\nexport function SheetBoxSourceDisplayData() {\n    const [data] = useState([\n        [1, 2, 3],\n        [10, 20, 30],\n    ]);\n\n    const displayData = (x, y) => {\n        return data?.[y]?.[x]?.toFixed?.(2);\n    };\n\n    return (\n        <div className=\"sheet-box\">\n            <Sheet\n                sourceData={data} // array of arrays of data\n                displayData={displayData}\n            />\n        </div>\n    );\n}\n","import React from 'react';\nimport { useRef, useState } from 'react';\nimport { SheetBoxHeader } from './SheetBox';\nimport GitIcon from '../assets/git.svg';\n\nfunction Header() {\n    const textAreaRef = useRef(null);\n    const [copySuccess, setCopySuccess] = useState('');\n\n    const copyToClipboard = (e) => {\n        textAreaRef.current.select();\n        document.execCommand('copy');\n        e.target.focus();\n        setCopySuccess('Copied!');\n        setTimeout(() => {\n            setCopySuccess('');\n        }, 1000);\n    };\n\n    return (\n        <div className=\"container blue-bg\" id=\"home\">\n            <div className=\"content flex-row header\">\n                <div className=\"box text-box\">\n                    <div>\n                        <h1>Beautiful and fast spreadsheet component for React</h1>\n                        <p className=\"lightblue-p\">\n                            Sheet Happens is easy to implement and extend.\n                            <br></br>\n                            And it's super fast.\n                        </p>\n                    </div>\n                    <div className=\"lib-box\">\n                        <div className=\"install-box\" onClick={copyToClipboard}>\n                            <input readOnly ref={textAreaRef} value=\"npm install --save sheet-happens\" />\n                            {copySuccess !== '' && <div className=\"copy-success\">{copySuccess}</div>}\n                        </div>\n                        <a\n                            href=\"https://github.com/farseerdev/sheet-happens\"\n                            rel=\"noopener noreferrer\"\n                            className=\"git-box\"\n                            target=\"_blank\"\n                        >\n                            <img src={GitIcon} alt=\"Git\" />\n                            view on github\n                        </a>\n                    </div>\n                </div>\n                <div className=\"box\">\n                    <SheetBoxHeader />\n                </div>\n            </div>\n        </div>\n    );\n}\n\nexport default Header;\n","import React from 'react';\n\nfunction TitleSeparator({ title, id }) {\n    return (\n        <div className=\"title-separator\" id={id ? id : ''}>\n            <p>{title ? title : 'No title'}</p>\n            <div className=\"separator\"></div>\n        </div>\n    );\n}\n\nexport default TitleSeparator;\n","import React from 'react';\n\nfunction Wrap({ children }) {\n    return (\n        <div className=\"container\">\n            <div className=\"content flex-row\">{children}</div>\n        </div>\n    );\n}\n\nexport default Wrap;\n","import React from 'react';\nimport SyntaxHighlighter from 'react-syntax-highlighter';\nimport { xcode } from 'react-syntax-highlighter/dist/esm/styles/hljs';\nxcode.hljs.padding = '10px 20px';\nxcode.hljs.background = '#f8f9fa';\nxcode.hljs.width = '100%';\nxcode.hljs.maxWidth = '100%';\nxcode.hljs.overflow = 'auto';\nxcode.hljs.borderRadius = '3px';\nxcode.hljs.fontSize = '14px';\n\nfunction Code() {\n    return (\n        <SyntaxHighlighter language=\"javascript\" style={xcode}>\n            {`function SheetBox() {\n    const [data, setData] = useState(initialData);\n    const [cellWidth, setCellWidth] = useState([]);\n    const [cellHeight, setCellHeight] = useState([]);\n\n    const onSelectionChanged = (x1, y1, x2, y2) => {};\n    const onRightClick = () => {};\n    const columnHeaders = ['A', 'B', 'C'];\n    const cellStyle = (x, y) => {\n        return {};\n    };\n    const editData = (x, y) => {\n        return data?.[y]?.[x];\n    };\n    const displayData = (x, y) => {\n        return data?.[y]?.[x];\n    };\n    const sourceData = (x, y) => {\n        return data?.[y]?.[x];\n    };\n\n    const onChange = (changes) => {\n        const newData = [...data];\n        for (const change of changes) {\n            if (!newData[change.y]) {\n                newData[change.y] = [];\n            }\n            newData[change.y][change.x] = change.value;\n        }\n        setData(newData);\n    };\n\n    const isReadOnly = (x, y) => {\n        return false;\n    };\n\n    const onCellWidthChange = (columnIdx, newWidth) => {\n        const cw = [...cellWidth];\n        if (columnIdx > cw.length) {\n            for (let i = cw.length; i <= columnIdx; i++) {\n                cw.push(100);\n            }\n        }\n        cw[columnIdx] = newWidth;\n        setCellWidth(cw);\n    };\n    const onCellHeightChange = (rowIdx, newHeight) => {\n        const ch = [...cellHeight];\n        if (rowIdx > ch.length) {\n            for (let i = ch.length; i <= rowIdx; i++) {\n                ch.push(22);\n            }\n        }\n        ch[rowIdx] = newHeight;\n        setCellHeight(ch);\n    };\n\n    return (\n        <div className=\"sheet-box\">\n            <Sheet\n                onSelectionChanged={onSelectionChanged}\n                onRightClick={onRightClick}\n                columnHeaders={columnHeaders}\n                cellStyle={cellStyle}\n                editData={editData}\n                displayData={displayData}\n                sourceData={sourceData}\n                cellWidth={cellWidth}\n                cellHeight={cellHeight}\n                onChange={onChange}\n                readOnly={isReadOnly}\n                onCellWidthChange={onCellWidthChange}\n                onCellHeightChange={onCellHeightChange}\n                freezeColumns={0}\n                freezeRows={0}\n            />\n        </div>\n    );\n}`}\n        </SyntaxHighlighter>\n    );\n}\n\nexport default Code;\n\nexport function SourceDisplayDataCode() {\n    let xcode2 = { ...xcode };\n    xcode2.hljs.height = '100%';\n    return (\n        <SyntaxHighlighter language=\"javascript\" style={xcode2}>\n            {`const [data, setData] = useState([[1,2,3], [10,20,30]]);\n    \nconst displayData = (x, y) => {\n    return data?.[y]?.[x]?.toFixed?.(2);\n};\n\nreturn (\n    <div className=\"sheet-box\">\n        <Sheet\n            sourceData={data} // array of arrays of data \n            displayData={displayData} // function example\n        />\n    </div>\n);`}\n        </SyntaxHighlighter>\n    );\n}\n\nexport function InitSheetCode() {\n    return (\n        <SyntaxHighlighter language=\"javascript\" style={xcode}>\n            {`import React, { Component } from 'react'\nimport Sheet from 'sheet-happens'\nimport 'sheet-happens/dist/index.css'\n\nclass Example extends Component {\n  render() {\n    return <Sheet />\n  }\n}`}\n        </SyntaxHighlighter>\n    );\n}\n\nexport function InitSheetWithDataCode() {\n    return (\n        <SyntaxHighlighter language=\"javascript\" style={xcode}>\n            {`const [data, setData] = useState([[1,2,3], [10,20,30]]);\n    \nconst displayData = (x, y) => {\n    return data?.[y]?.[x]?.toFixed?.(2);\n};\n\nreturn (\n    <div className=\"sheet-box\">\n        <Sheet\n            sourceData={data}\n            displayData={displayData}\n        />\n    </div>\n);`}\n        </SyntaxHighlighter>\n    );\n}\n\nexport function EditDataCode() {\n    return (\n        <SyntaxHighlighter language=\"javascript\" style={xcode}>\n            {`...\n\nconst editData = (x, y) => {\n    return data?.[y]?.[x];\n};\n\nconst onChange = (changes) => {\n    const newData = [...data];\n    for (const change of changes) {\n        if (!newData[change.y]) {\n            newData[change.y] = [];\n        }\n        newData[change.y][change.x] = change.value;\n    }\n    setData(newData);\n};\n\nconst isReadOnly = (x, y) => {\n    return false;\n};\n\nreturn (\n    <div className=\"sheet-box\">\n        <Sheet\n            ...\n            sourceData={sourceData}\n            onChange={onChange}\n            readOnly={isReadOnly}\n        />\n    </div>\n);`}\n        </SyntaxHighlighter>\n    );\n}\n\nexport function CellStyleSizeCode() {\n    return (\n        <SyntaxHighlighter language=\"javascript\" style={xcode}>\n            {`...\n\nconst cellStyle = (x, y) => {\n    return { textAlign: 'right' };\n};\n\nconst [cellWidth, setCellWidth] = useState([]);\n\nconst onCellWidthChange = (columnIdx, newWidth) => {\n    const cw = [...cellWidth];\n    if (columnIdx > cw.length) {\n        for (let i = cw.length; i <= columnIdx; i++) {\n            cw.push(100);\n        }\n    }\n    cw[columnIdx] = newWidth;\n    setCellWidth(cw);\n};\n\nreturn (\n    <div className=\"sheet-box\">\n        <Sheet\n            ...\n            cellStyle={cellStyle}\n            cellWidth={cellWidth}\n            onCellWidthChange={onCellWidthChange}\n        />\n    </div>\n);`}\n        </SyntaxHighlighter>\n    );\n}\n","import React from 'react';\n\nfunction Footer() {\n    return (\n        <div className=\"footer\">\n            <p className=\"copy\">made by <a href=\"https://www.farseer.io\">farseer</a></p>\n        </div>\n    );\n}\n\nexport default Footer;\n","import React from 'react';\nimport './index.css';\n\nimport Menu from './components/Menu';\nimport Header from './components/Header';\nimport TitleSeparator from './components/TitleSeparator';\nimport Wrap from './components/Wrap';\nimport {\n    InitSheetCode,\n    InitSheetWithDataCode,\n    SourceDisplayDataCode,\n    EditDataCode,\n    CellStyleSizeCode,\n} from './components/Code';\nimport {\n    SheetBoxStyle,\n    SheetBoxBasic,\n    SheetBoxFormatting,\n    SheetBoxVeryBigData,\n    SheetBoxCustomInput,\n    SheetBoxSourceDisplayData,\n} from './components/SheetBox';\nimport Footer from './components/Footer';\n\nconst App = () => {\n    return (\n        <>\n            <Menu />\n            <Header />\n\n            <TitleSeparator title=\"Get started\" id=\"usage\" />\n            <Wrap>\n                <div className=\"box full-width colored-pre\" style={{ overflowX: 'auto' }}>\n                    <p>Import the component and its style, and render it</p>\n                    <InitSheetCode />\n\n                    <div className=\"spacer\" />\n\n                    <p>Display some data</p>\n                    <InitSheetWithDataCode />\n                </div>\n            </Wrap>\n\n            <TitleSeparator title=\"Learn more about features\" id=\"features\" />\n            <Wrap>\n                <div className=\"box\">\n                    <SheetBoxBasic />\n                </div>\n                <div className=\"box\">\n                    <h3>Basic spreadsheet</h3>\n                    <p>\n                        It has all the features you'd expect from the spreadsheet: keyboard navigation, copy cells by\n                        dragging the small square, copy/paste from and to Excel and Google Sheets, resize and reorder columns and\n                        rows.\n                    </p>\n                </div>\n            </Wrap>\n            <Wrap>\n                <div className=\"box\">\n                    <SheetBoxStyle />\n                </div>\n                <div className=\"box\">\n                    <h3>Styling</h3>\n                    <p>\n                        You can change the cell color, alignment, font weight, margins and more. It's also possible to\n                        freeze first rows or columns, and add clickable images.\n                    </p>\n                </div>\n            </Wrap>\n            <Wrap>\n                <div className=\"box\">\n                    <SheetBoxFormatting />\n                </div>\n                <div className=\"box\">\n                    <h3>Formatting</h3>\n                    <p>\n                        Sheet Happens uses different datasets for display and edit so you can apply different formatting\n                        when displaying the cell and editing the cell.\n                    </p>\n                </div>\n            </Wrap>\n\n            <div className=\"spacer\" />\n\n            <TitleSeparator title=\"Big dataset example\" id=\"big dataset example\" />\n            <Wrap>\n                <div className=\"box full-width\">\n                    <p>\n                        Our Sheet is designed and built with big datasets in mind. No matter the size of your data, it\n                        will be handled blazingly fast and super responsive because component is canvas-based and it\n                        draws only the small chunk of data user sees at the moment.\n                    </p>\n                    <br />\n                    <SheetBoxVeryBigData />\n                </div>\n            </Wrap>\n\n            <div className=\"spacer\" />\n\n            <TitleSeparator title=\"Custom input fields\" id=\"custom input example\" />\n            <Wrap>\n                <div className=\"box\">\n                    <SheetBoxCustomInput />\n                </div>\n                <div className=\"box\">\n                    <h3>Custom input component</h3>\n                    <p>\n                        If basic text input isn't enough, you can send your own React component to be displayed instead.\n                    </p>\n                </div>\n            </Wrap>\n\n            <div className=\"spacer\" />\n\n            <TitleSeparator title=\"Documentation\" id=\"documentation\" />\n            <Wrap>\n                <div className=\"box full-width\">\n                    {/* sourceData displayData */}\n                    <h3>Displaying data</h3>\n                    <p>\n                        If you have some data you want to display, you send it via <Emphased text=\"sourceData\" /> and{' '}\n                        <Emphased text=\"displayData\" /> props.\n                    </p>\n                    <p>\n                        The first one receives unformatted data which is used for data manipulation, and the second one\n                        formatted which is used for displaying in cells.\n                    </p>\n                    <br />\n                    <p>\n                        Each of this can be either array of arrays of values (where each array is representing data for\n                        one row) or function (which returns value based on x and y coordinates that are sent as\n                        arguments to your function).\n                    </p>\n                </div>\n            </Wrap>\n\n            <Wrap>\n                <div className=\"box colored-pre unmargin-pre\" style={{ maxWidth: '100%', overflow: 'auto' }}>\n                    <SourceDisplayDataCode />\n                </div>\n                <div className=\"box\">\n                    <SheetBoxSourceDisplayData />\n                </div>\n            </Wrap>\n\n            <div className=\"spacer\" />\n\n            <Wrap>\n                <div className=\"box\">\n                    {/*editData onChange readOnly */}\n                    <h3>Editing data</h3>\n                    <p>\n                        Same as the previous two, prop <Emphased text=\"editData\" /> can recieve either array of arrays\n                        of values or function for data which will be displayed in edit mode. Edit mode is activated by\n                        double click on the cell.\n                    </p>\n                    <br />\n                    <p>\n                        Once edit is done, function sent in <Emphased text=\"onChange\" /> prop will be called with array\n                        of changes as an argument. Each element of this array has value, x and y coordinates. Use this\n                        information to change values in your data array.\n                    </p>\n                    <br />\n                    <p>\n                        Sheet also accepts <Emphased text=\"readOnly\" /> prop which you can use if some cells should not\n                        be editable. Same as the most of sheet's props, you can send function, array of arrays, or a\n                        single value which then is applied to the whole table.\n                    </p>\n                </div>\n\n                <div className=\"box unmargin-pre\">\n                    <EditDataCode />\n                </div>\n            </Wrap>\n\n            <div className=\"spacer\" />\n\n            <Wrap>\n                <div className=\"box full-width\">\n                    {/* columnHeaders */}\n                    <h3>Column headers</h3>\n                    <p>\n                        By default, sheet has excel-like headers (A, B, C, ...) but you can send yours via{' '}\n                        <Emphased text=\"columnHeaders\" /> prop as an array or function.\n                    </p>\n                </div>\n            </Wrap>\n\n            <div className=\"spacer\" />\n\n            <Wrap>\n                <div className=\"box\">\n                    {/* cellStyle cellWidth cellHeight onCellWidthChange onCellHeightChange */}\n                    <h3>Cell style and width/height</h3>\n                    <p>\n                        Use prop <Emphased text=\"cellStyle\" /> and <Emphased text=\"columnHeaderStyle\" /> for customizing\n                        cells visually.\n                    </p>\n                    <br />\n                    <p>\n                        You can also use <Emphased text=\"cellWidth\" /> and <Emphased text=\"cellHeight\" /> props to\n                        customize cell size. If you send single value {`cellWidth={200}`}, it will be applied to all\n                        cells. If you send array of values {`cellWidth={[200, 80, 80]}`}, they will be applied in\n                        respect to the index number.\n                    </p>\n                    <br />\n                    <p>\n                        There are also <Emphased text=\"onCellWidthChange\" /> and <Emphased text=\"onCellHeightChange\" />{' '}\n                        props for functions which are called when user drags cell for resize. You can use these for\n                        updating your cellWidth/cellHeight arrays.\n                    </p>\n                </div>\n                <div className=\"box unmargin-pre\">\n                    <CellStyleSizeCode />\n                </div>\n            </Wrap>\n\n            <div className=\"spacer\" />\n\n            <Wrap>\n                <div className=\"box full-width\">\n                    {/* onSelectionChanged */}\n                    <h3>Selection</h3>\n                    <p>\n                        You can send a function to the <Emphased text=\"onSelectionChanged\" /> prop. It will be called on\n                        selection change with x1, y1, x2 and y2 arguments.\n                    </p>\n                </div>\n            </Wrap>\n\n            <div className=\"spacer\" />\n\n            <Wrap>\n                <div className=\"box full-width\">\n                    {/* onRightClick */}\n                    <h3>Right click handler</h3>\n                    <p>\n                        If you send a function to <Emphased text=\"onRightClick\" /> prop, it will be called on right\n                        click with whole mouse event (extended with cellX and cellY values) as an argument.\n                    </p>\n                </div>\n            </Wrap>\n\n            <div className=\"spacer\" />\n\n            <Wrap>\n                <div className=\"box full-width\">\n                    {/* freezeColumns freezeRows */}\n                    <h3>Sticky columns/rows</h3>\n                    <p>\n                        Send a number to <Emphased text=\"freezeColumns\" /> and/or <Emphased text=\"freezeRows\" /> to make\n                        first n of columns/rows sticky.\n                    </p>\n                </div>\n            </Wrap>\n\n            <div className=\"spacer\" />\n\n            <Wrap>\n                <div className=\"box full-width\">\n                    {/* inputComponent */}\n                    <h3>Custom input</h3>\n                    <p>\n                        By default edit mode turns the cell into a text edit component. But you can send your custom input\n                        component via <Emphased text=\"inputComponent\" /> props. It will be called with{' '}\n                        <Emphased text=\"x\" />, <Emphased text=\"y\" />, <Emphased text=\"inputProps\" /> and{' '}\n                        <Emphased text=\"commitEditingCell\" /> arguments.\n                    </p>\n                </div>\n            </Wrap>\n\n            <div className=\"spacer\" />\n\n            <Footer />\n        </>\n    );\n};\n\nfunction Emphased({ text }) {\n    return <span className=\"emphased\">{text}</span>;\n}\n\nexport default App;\n","import './index.css'\n\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\n\nReactDOM.render(<App />, document.getElementById('root'))\n"],"sourceRoot":""}